Readme for the Arduino VSCP CAN sample 1
=========================================
Version 0.0.1 2012-08-29
Copyright (C) Åke Hedman, Grodans Paradis AB
akhe@grodansparadis.com, http://www.vscp.org

This is a simple implementation of VSCP on an Arduino Duemilanove board
(http://arduino.cc/en/Main/arduinoBoardDuemilanove) with a CAN shield
from sparkfun.com (https://www.sparkfun.com/products/10039). It may or
may not work on other board combinations.

As the CAN library written for the shield did not handle extended id's
which are needed by VSCP and is very poorly written I decided to use a
library by David Harding and changed this code to my needs.

If you are new to VSCP please start by reading this short primer
http://sourceforge.net/projects/m2m/files/VSCP%20Documentation/VSCP_primer.pdf/download
also there is some introduction videos at http://vscp.org/docs.php and you
can also find the full specification at that address.

VSCP is constructed to make it easy (and fun) to build control systems that
can be controlled remotely and work with or without a master device. VSCP is free
and will always be free to use and implement i products.

A software suite called VSCP & Friends is available that can be run on Windows
and Linux. Can be downloaded here 
https://sourceforge.net/projects/m2m/files/vscp/

-------------------------------------------------------------------------------

This sample module implements support for the Joystick of the CAN shield and it
also allow you to control some outputs and read one analog input. Additional support
such as supporting an LCD display, supporting the GPS, supporting the memory card
can easily be added.

The sample code has a eight line decision matrix which can be programmed to perform 
actions when events (CAN messages) is received by the unit.

Registers
=========

Register  0:		Zone for module (r/w).
Register  1:		Subzone for module (r/w).
Register  2:		Control register for D3 (r/w).
						Bit 0: Current state of bit.
						Bit 1: 0=Input, 1=output.
						Bit 2: Enable pull up if set to one.
Register  3:		Control register for D4 (r/w).
						Bit 0: Current state of bit.	
						Bit 1: 0=Input, 1=output.
						Bit 2: Enable pull up if set to one.
Register  4:		Control register for D5 (r/w).
						Bit 0: Current state of bit.
						Bit 1: 0=Input, 1=output.
						Bit 2: Enable pull up if set to one.
Register  5:		Control register for D6 (r/w).
						Bit 0: Current state of bit.
						Bit 1: 0=Input, 1=output.
						Bit 2: Enable pull up if set to one.
Register  6:		Control register for A0 (r/w).
Register  7:		Analog converter 0 - MSB byte(read only).		
Register  8:		Analog converter 0 - LSB byte(read only).
Register  9:		Serial port control (r/w).
					Bit 0: Activate port if set to one. This is
							persistant so if set to one the port
							will be open automatically on next restart
							of board.
					Bit 1: If set to one send stream events for
							incoming data on serial port.
					Bit 2: Set to one to send stream data with zone/subzone.	 		
Register 10:		Serial baudrate MSB (r/w).
Register 11:		Serial baudrate LSB (r/w). The actual baudrate change
						happens when the LSB byte is written so it is 
						important to write MSB byte first and then LSB.
Register 12:		Joystick control (r/w).  
					Bit 0: Add index of joystick button to subzone
							before sending On-event.
					Bit 1: Add code of joystick button to subzone
							before sending Button-event.
					Bit 2: On event is sent if zero, button events if
							set to one.
Register 13:		Zone used for On events. (r/w).		
Register 14:		Subzone used for On events. (r/w). 
Register 15:		Zone used for Button events. (r/w).		
Register 16:		Subzone used for Button events. (r/w). 
Register 17:		Second between I/O state events. Set to zero
						to disable. See events below. (r/w).
Register 18:		Second between A/D state events. Set to zero
						to disable. See events below. (r/w)
Register 19:		Control LED's D7/D8(status).
					Bit 0: LED D7. 1=On, 0=Off.
					Bit 1: LED D8. 1=On, 0=Off.
Register 64-127:	A eight row decision matrix.						
						
Decision matrix
===============

Actions
-------
Action = 0. NOOP, no operation.
Action = 1. CLASS1.INFORMATION(20), Type = 18 (0x12) Good day event
				is sent.
Action = 2.	Open serial port.
Action = 3. Close serial port. 
Action = 4. Send data on serial port. Index into data by action parameter.
Action = 5. CLASS1.DATA(15), Type = 1 (0x01) I/O – value event
				is sent. Se description in events section below.
Action = 6. CLASS1.DATA(15), Type = 2 (0x02) A/D value event
				is sent. Se description in events section below.				

Events generated by the node
============================

CLASS1.INFORMATION(20), Type = 9 (0x09) Node Heartbeat
------------------------------------------------------
This event is sent every minute by the node.

byte 0: Allways zero.
byte 1: Zone for module. Always 0xff.
byte 2: Subzone for module. Always 0xff.

CLASS1.INFORMATION(20), Type=3 On
---------------------------------
This event will be generated for the joystick of the CAN shield. The datapart
of the event will contain information on the joystick direction. 

byte 0: Index coded as below.
byte 1: Zone for module.
byte 2:	subzone for module.
 
Index coding.

UP		1
RIGHT	2
DOWN	3
CLICK	4
LEFT	5

The CLICK position of the joystick is special as it also will take the baord into
init-mode if held for more then two seconds.

CLASS1.INFORMATION(20), Type=1 Button
-------------------------------------
This event will be generated for the joystick of the CAN shield. The datapart
of the event will contain information on the joystick direction. 

byte 0: Zone for module.
byte 1: Subzone for module.
byte 2:	0
byte 3:	Code for button.

Button coding

UP		1
RIGHT	2
DOWN	3
CLICK	4
LEFT	5	

CLASS1.INFORMATION(20), Type = 36 (0x24) Stream Data.	
-----------------------------------------------------
Serial data is sent as stream event if enabled.

byte 0: Index of package. Icreased by one for each event sent.
byte 1-7: Serial data. Number of bytes varies.

CLASS1.INFORMATION(20), Type = 38 (0x26) Stream Data with zone.
---------------------------------------------------------------
Serial data is sent as stream event if enabled.

byte 0: Index of package. Icreased by one for each event sent.
byte 1: Zone for module.
byte 2: Subzone for module.
byte 3-7: Serial data. Number of bytes varies.

CLASS1.INFORMATION(20), Type = 18 (0x12) Good day
-------------------------------------------------
This event is sent as a result of Action=1.

byte 0: Always set to 0.
byte 1: Zone for module.
byte 2: Subzone for module.

CLASS1.DATA(15), Type = 1 (0x01) I/O – value
--------------------------------------------
This event is sent as a result of Action=5 and/or is sent
on regular intervals specified in register 16.

byte 0: Datacoding=0, bitfield. See section 8 in specification. 
byte 1: Representing state of I/O pins
			bit 0: D3
			bit 1: D4
			bit 2: D5
			bit 3: D6
		The rest of the pins are set to zero.	

CLASS1.DATA(15), Type = 2 (0x02) A/D value – value
--------------------------------------------------
This event is sent as a result of Action=6 and/or is sent
on regular intervals specyfied in register 17.

byte 0: Datacoding=96, 16-bit integer. See section 8 in specification.
byte 1: MSB of integer.
byte 2: LSB of integer. 

Bootloader
===========
No CAN bootloader is implemented.