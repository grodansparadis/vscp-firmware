###############################################################################
#                                                                             #
# IAR ARM ANSI C/C++ Compiler V5.12.0.50667/W32         18/Apr/2008  14:00:26 #
# Copyright 1999-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Program\IAR Systems\Embedded Workbench                #
#                    5.0\ARM\examples\ST\STR75x\STR75xLibrary\library\src\75x #
#                    _tim.c                                                   #
#    Command line =  "D:\Program\IAR Systems\Embedded Workbench               #
#                    5.0\ARM\examples\ST\STR75x\STR75xLibrary\library\src\75x #
#                    _tim.c" -lC D:\development\gediminas\CAN4USB\project\REL #
#                    EASE\List\ -lA D:\development\gediminas\CAN4USB\project\ #
#                    RELEASE\List\ -o D:\development\gediminas\CAN4USB\projec #
#                    t\RELEASE\Obj\ --no_cse --no_unroll --no_inline          #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian little --cpu            #
#                    ARM7TDMI-S -e --fpu None --dlib_config "D:\Program\IAR   #
#                    Systems\Embedded Workbench 5.0\ARM\INC\DLib_Config_Norma #
#                    l.h" -I D:\development\gediminas\CAN4USB\project\ -I     #
#                    D:\development\gediminas\CAN4USB\project\app\ -I         #
#                    D:\development\gediminas\CAN4USB\project\board\ -I       #
#                    D:\development\gediminas\CAN4USB\project\module\ -I      #
#                    D:\development\gediminas\CAN4USB\project\STR75xLibrary\l #
#                    ibrary\inc\ -I j:\common\ -I "D:\Program\IAR             #
#                    Systems\Embedded Workbench 5.0\ARM\INC\" --interwork     #
#                    --cpu_mode thumb -On                                     #
#    List file    =  D:\development\gediminas\CAN4USB\project\RELEASE\List\75 #
#                    x_tim.lst                                                #
#    Object file  =  D:\development\gediminas\CAN4USB\project\RELEASE\Obj\75x #
#                    _tim.o                                                   #
#                                                                             #
#                                                                             #
###############################################################################

D:\Program\IAR Systems\Embedded Workbench 5.0\ARM\examples\ST\STR75x\STR75xLibrary\library\src\75x_tim.c
      1          /******************** (C) COPYRIGHT 2006 STMicroelectronics ********************
      2          * File Name          : 75x_tim.c
      3          * Author             : MCD Application Team
      4          * Date First Issued  : 03/10/2006
      5          * Description        : This file provides all the TIM software functions.
      6          ********************************************************************************
      7          * History:
      8          * 07/17/2006 : V1.0
      9          * 03/10/2006 : V0.1
     10          ********************************************************************************
     11          * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     13          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     14          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     15          * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     16          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17          *******************************************************************************/
     18          
     19          /* Includes ------------------------------------------------------------------*/
     20          #include "75x_tim.h" 
     21          #include "75x_mrcc.h"
     22          
     23          /* Private typedef -----------------------------------------------------------*/
     24          /* Private define ------------------------------------------------------------*/
     25          /* Private macro -------------------------------------------------------------*/
     26          /* Private variables ---------------------------------------------------------*/
     27          /* TIM interrupt masks */
     28          #define TIM_IT_Clear_Mask   0x7FFF
     29          #define TIM_IT_Enable_Mask  0x7FFF
     30          
     31          /* TIM Input Capture Selection Set/Reset */
     32          #define TIM_IC1S_Set    0x0001
     33          #define TIM_IC1S_Reset  0x003E
     34          
     35          /* TIM Input Capture Selection Set/Reset */
     36          #define TIM_IC2S_Set    0x0002
     37          #define TIM_IC2S_Reset  0x003D
     38          
     39          /* TIM_SCR Masks bit */
     40          #define TIM_Encoder_Mask                   0x731C
     41          #define TIM_SlaveModeSelection_Mask        0x7307
     42          #define TIM_TriggerSelection_Mask          0x701F
     43          #define TIM_InternalTriggerSelection_Mask  0x031F
     44          
     45          /* TIM Encoder mode Set value */
     46          #define TIM_Encoder1_Set  0x0001
     47          #define TIM_Encoder2_Set  0x0002
     48          #define TIM_Encoder3_Set  0x0003
     49          
     50          /* TIM Slave Mode Enable Set/Reset value */
     51          #define TIM_SME_Reset  0x731B
     52          #define TIM_SME_Set    0x0004
     53          
     54          /* TIM Internal Trigger Selection value */
     55          #define TIM_ITS_TIM0  0x1000
     56          #define TIM_ITS_TIM1  0x2000
     57          #define TIM_ITS_TIM2  0x3000
     58          #define TIM_ITS_PWM   0x4000
     59          
     60          /* TIM Trigger Selection value */
     61          #define TIM_TS_IC1_Set  0x0200
     62          #define TIM_TS_IC2_Set  0x0300
     63          
     64          /* TIM Slave Mode selction external clock Set value */
     65          #define TIM_SMS_EXTCLK_Set    0x0008
     66          #define TIM_SMS_RESETCLK_Set  0x0000
     67          
     68          /* TIM_CR Masks bit */
     69          #define TIM_DBASE_Mask                0x077F
     70          #define TIM_MasterModeSelection_Mask  0xFC7F
     71          #define TIM_CounterMode_Mask          0xFF8F
     72          
     73          /* TIM Update flag selection Set/Reset value */
     74          #define TIM_UFS_Reset  0xFFFE
     75          #define TIM_UFS_Set    0x0001
     76          
     77          /* TIM Counter value */
     78          #define TIM_COUNTER_Reset  0x0002
     79          #define TIM_COUNTER_Start  0x0004
     80          #define TIM_COUNTER_Stop   0xFFFB
     81          
     82          /* TIM One pulse Mode set value */
     83          #define TIM_OPM_Set    0x0008
     84          #define TIM_OPM_Reset  0xFFF7
     85          
     86          /* TIM Debug Mode Set/Reset value */
     87          #define TIM_DBGC_Set    0x0400
     88          #define TIM_DBGC_Reset  0xFB7F
     89          
     90          /* TIM Input Capture Enable/Disable value */
     91          #define TIM_IC1_Enable  0x0004
     92          #define TIM_IC2_Enable  0x0010
     93          
     94          /* TIM Input Capture Polarity Set/Reset value */
     95          #define TIM_IC1P_Set    0x0008
     96          #define TIM_IC2P_Set    0x0020
     97          #define TIM_IC1P_Reset  0x0037
     98          #define TIM_IC2P_Reset  0x001F
     99          
    100          /* TIM Output Compare Polarity Set/Reset value */
    101          #define TIM_OC1P_Set    0x0020
    102          #define TIM_OC2P_Set    0x2000
    103          #define TIM_OC1P_Reset  0x3F1F
    104          #define TIM_OC2P_Reset  0x1F3F
    105          
    106          /* TIM Output Compare control mode constant */
    107          #define TIM_OCControl_PWM         0x000C
    108          #define TIM_OCControl_OCToggle    0x0006
    109          #define TIM_OCControl_OCInactive  0x0004
    110          #define TIM_OCControl_OCActive    0x0002
    111          #define TIM_OCControl_OCTiming    0x0000
    112          
    113          /* TIM Output Compare mode Enable value */
    114          #define TIM_OC1_Enable  0x0010
    115          #define TIM_OC2_Enable  0x1000
    116          
    117          /* TIM Output Compare mode Mask value */
    118          #define TIM_OC1C_Mask  0x3F31
    119          #define TIM_OC2C_Mask  0x313F
    120          
    121          /* TIM Preload bit Set/Reset value */
    122          #define TIM_PLD1_Set    0x0001
    123          #define TIM_PLD1_Reset  0xFFFE
    124          
    125          #define TIM_PLD2_Set    0x0100
    126          #define TIM_PLD2_Reset  0xFEFF
    127          
    128          /* TIM OCRM Set/Reset value */
    129          #define TIM_OCRM_Set    0x0080
    130          #define TIM_OCRM_Reset  0x030D
    131          
    132          /* Reset Register Masks */
    133          #define TIM_Pulse2_Reset_Mask     0x0000
    134          #define TIM_Prescaler_Reset_Mask  0x0000
    135          #define TIM_Pulse1_Reset_Mask     0x0000
    136          #define TIM_Period_Reset_Mask     0xFFFF
    137          #define TIM_Counter_Reset         0x0002
    138          
    139          /* Private function prototypes -----------------------------------------------*/
    140          static void ICAP_ModuleConfig(TIM_TypeDef* TIMx, TIM_InitTypeDef* TIM_InitStruct);
    141          static void Encoder_ModeConfig(TIM_TypeDef* TIMx, TIM_InitTypeDef* TIM_InitStruct);
    142          static void OCM_ModuleConfig(TIM_TypeDef* TIMx, TIM_InitTypeDef* TIM_InitStruct);
    143          
    144          /* Private functions ---------------------------------------------------------*/
    145          
    146          /******************************************************************************
    147          * Function Name  : TIM_DeInit
    148          * Description    : Deinitializes TIM peripheral registers to their default reset
    149          *                  values.
    150          * Input          : TIMx: where x can be 0, 1 or 2 to select the TIM peripheral.
    151          * Output         : None
    152          * Return         : None
    153          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    154          void TIM_DeInit(TIM_TypeDef *TIMx)
    155          { 
   \                     TIM_DeInit:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    156            if(TIMx == TIM0)
   \   00000004   ....               LDR      R0,??DataTable9  ;; 0xffff8c00
   \   00000006   8442               CMP      R4,R0
   \   00000008   08D1               BNE      ??TIM_DeInit_0
    157            {
    158              MRCC_PeripheralSWResetConfig(MRCC_Peripheral_TIM0,ENABLE);
   \   0000000A   0121               MOVS     R1,#+1
   \   0000000C   0420               MOVS     R0,#+4
   \   0000000E   ........           BL       MRCC_PeripheralSWResetConfig
    159              MRCC_PeripheralSWResetConfig(MRCC_Peripheral_TIM0,DISABLE);
   \   00000012   0021               MOVS     R1,#+0
   \   00000014   0420               MOVS     R0,#+4
   \   00000016   ........           BL       MRCC_PeripheralSWResetConfig
   \   0000001A   16E0               B        ??TIM_DeInit_1
    160            }
    161            else if(TIMx == TIM1)
   \                     ??TIM_DeInit_0:
   \   0000001C   ....               LDR      R0,??DataTable1  ;; 0xffff9000
   \   0000001E   8442               CMP      R4,R0
   \   00000020   08D1               BNE      ??TIM_DeInit_2
    162            {
    163              MRCC_PeripheralSWResetConfig(MRCC_Peripheral_TIM1,ENABLE);
   \   00000022   0121               MOVS     R1,#+1
   \   00000024   0820               MOVS     R0,#+8
   \   00000026   ........           BL       MRCC_PeripheralSWResetConfig
    164              MRCC_PeripheralSWResetConfig(MRCC_Peripheral_TIM1,DISABLE);
   \   0000002A   0021               MOVS     R1,#+0
   \   0000002C   0820               MOVS     R0,#+8
   \   0000002E   ........           BL       MRCC_PeripheralSWResetConfig
   \   00000032   0AE0               B        ??TIM_DeInit_1
    165            }
    166            else if(TIMx == TIM2)
   \                     ??TIM_DeInit_2:
   \   00000034   ....               LDR      R0,??DataTable2  ;; 0xffff9400
   \   00000036   8442               CMP      R4,R0
   \   00000038   07D1               BNE      ??TIM_DeInit_1
    167            {
    168              MRCC_PeripheralSWResetConfig(MRCC_Peripheral_TIM2,ENABLE);
   \   0000003A   0121               MOVS     R1,#+1
   \   0000003C   1020               MOVS     R0,#+16
   \   0000003E   ........           BL       MRCC_PeripheralSWResetConfig
    169              MRCC_PeripheralSWResetConfig(MRCC_Peripheral_TIM2,DISABLE);
   \   00000042   0021               MOVS     R1,#+0
   \   00000044   1020               MOVS     R0,#+16
   \   00000046   ........           BL       MRCC_PeripheralSWResetConfig
    170            }
    171          }
   \                     ??TIM_DeInit_1:
   \   0000004A   10BC               POP      {R4}
   \   0000004C   01BC               POP      {R0}
   \   0000004E   0047               BX       R0               ;; return
    172          
    173          /*******************************************************************************
    174          * Function Name  : TIM_Init
    175          * Description    : Initializes the TIMx peripheral according to the specified
    176          *                  parameters in the TIM_InitStruct .
    177          * Input          : - TIMx: where x can be 0, 1 or 2 to select the TIM peripheral.
    178          *                  - TIM_InitStruct: pointer to a TIM_InitTypeDef structure that
    179          *                    contains the configuration information for the specified TIM
    180          *                    peripheral.
    181          * Output         : None
    182          * Return         : None
    183          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    184          void TIM_Init(TIM_TypeDef* TIMx, TIM_InitTypeDef* TIM_InitStruct)
    185          {
   \                     TIM_Init:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
    186            /* Set the prescaler value */
    187            TIMx->PSC = TIM_InitStruct->TIM_Prescaler;
   \   00000006   6888               LDRH     R0,[R5, #+2]
   \   00000008   2085               STRH     R0,[R4, #+40]
    188          
    189            /* Select the clock source */
    190            TIM_ClockSourceConfig(TIMx, TIM_InitStruct->TIM_ClockSource,
    191                                     TIM_InitStruct->TIM_ExtCLKEdge);
   \   0000000A   EA88               LDRH     R2,[R5, #+6]
   \   0000000C   A988               LDRH     R1,[R5, #+4]
   \   0000000E   2000               MOVS     R0,R4
   \   00000010   ........           BL       TIM_ClockSourceConfig
    192          
    193            /* Select the counter mode */
    194            TIMx->CR &= TIM_CounterMode_Mask;
   \   00000014   2088               LDRH     R0,[R4, #+0]
   \   00000016   ....               LDR      R1,??DataTable3  ;; 0xff8f
   \   00000018   0140               ANDS     R1,R1,R0
   \   0000001A   2180               STRH     R1,[R4, #+0]
    195            TIMx->CR |= TIM_InitStruct->TIM_CounterMode;
   \   0000001C   2088               LDRH     R0,[R4, #+0]
   \   0000001E   2989               LDRH     R1,[R5, #+8]
   \   00000020   0143               ORRS     R1,R1,R0
   \   00000022   2180               STRH     R1,[R4, #+0]
    196          
    197            /* Set the period value */
    198            TIMx->ARR = TIM_InitStruct->TIM_Period;
   \   00000024   6889               LDRH     R0,[R5, #+10]
   \   00000026   2086               STRH     R0,[R4, #+48]
    199          
    200            switch(TIM_InitStruct->TIM_Mode)
   \   00000028   2888               LDRH     R0,[R5, #+0]
   \   0000002A   401E               SUBS     R0,R0,#+1
   \   0000002C   0428               CMP      R0,#+4
   \   0000002E   09D9               BLS      ??TIM_Init_0
   \   00000030   401F               SUBS     R0,R0,#+5
   \   00000032   0128               CMP      R0,#+1
   \   00000034   0BD9               BLS      ??TIM_Init_1
   \   00000036   801E               SUBS     R0,R0,#+2
   \   00000038   0228               CMP      R0,#+2
   \   0000003A   0DD9               BLS      ??TIM_Init_2
   \   0000003C   C01E               SUBS     R0,R0,#+3
   \   0000003E   0228               CMP      R0,#+2
   \   00000040   0FD9               BLS      ??TIM_Init_3
   \   00000042   26E0               B        ??TIM_Init_4
    201            {
    202              case TIM_Mode_OCTiming: case TIM_Mode_OCActive: case TIM_Mode_OCInactive:
    203              case TIM_Mode_OCToggle: case TIM_Mode_PWM:
    204                OCM_ModuleConfig(TIMx, TIM_InitStruct);
   \                     ??TIM_Init_0:
   \   00000044   2900               MOVS     R1,R5
   \   00000046   2000               MOVS     R0,R4
   \   00000048   ........           BL       OCM_ModuleConfig
   \   0000004C   21E0               B        ??TIM_Init_4
    205              break;
    206          
    207              case TIM_Mode_PWMI: case TIM_Mode_IC:
    208                ICAP_ModuleConfig(TIMx, TIM_InitStruct);
   \                     ??TIM_Init_1:
   \   0000004E   2900               MOVS     R1,R5
   \   00000050   2000               MOVS     R0,R4
   \   00000052   ........           BL       ICAP_ModuleConfig
   \   00000056   1CE0               B        ??TIM_Init_4
    209              break;
    210          
    211              case TIM_Mode_Encoder1: case TIM_Mode_Encoder2: case TIM_Mode_Encoder3:
    212                Encoder_ModeConfig(TIMx, TIM_InitStruct);
   \                     ??TIM_Init_2:
   \   00000058   2900               MOVS     R1,R5
   \   0000005A   2000               MOVS     R0,R4
   \   0000005C   ........           BL       Encoder_ModeConfig
   \   00000060   17E0               B        ??TIM_Init_4
    213              break;
    214          
    215              case TIM_Mode_OPM_PWM: case TIM_Mode_OPM_Toggle: case TIM_Mode_OPM_Active:
    216          
    217                /* Output module configuration */
    218                OCM_ModuleConfig(TIMx, TIM_InitStruct);
   \                     ??TIM_Init_3:
   \   00000062   2900               MOVS     R1,R5
   \   00000064   2000               MOVS     R0,R4
   \   00000066   ........           BL       OCM_ModuleConfig
    219          
    220                /* Input module configuration */
    221                ICAP_ModuleConfig(TIMx, TIM_InitStruct);
   \   0000006A   2900               MOVS     R1,R5
   \   0000006C   2000               MOVS     R0,R4
   \   0000006E   ........           BL       ICAP_ModuleConfig
    222                
    223                /* Set the slave mode to trigger Mode */
    224                TIMx->SCR |= TIM_SynchroMode_Trigger;
   \   00000072   A088               LDRH     R0,[R4, #+4]
   \   00000074   1821               MOVS     R1,#+24
   \   00000076   0143               ORRS     R1,R1,R0
   \   00000078   A180               STRH     R1,[R4, #+4]
    225          
    226                /* Repetitive pulse state selection */
    227                if(TIM_InitStruct->TIM_RepetitivePulse == TIM_RepetitivePulse_Disable)
   \   0000007A   688A               LDRH     R0,[R5, #+18]
   \   0000007C   0528               CMP      R0,#+5
   \   0000007E   04D1               BNE      ??TIM_Init_5
    228                {
    229                  TIMx->CR |= TIM_OPM_Set;
   \   00000080   2088               LDRH     R0,[R4, #+0]
   \   00000082   0821               MOVS     R1,#+8
   \   00000084   0143               ORRS     R1,R1,R0
   \   00000086   2180               STRH     R1,[R4, #+0]
   \   00000088   03E0               B        ??TIM_Init_4
    230                }
    231                else
    232                {
    233                  TIMx->CR &= TIM_OPM_Reset;
   \                     ??TIM_Init_5:
   \   0000008A   2088               LDRH     R0,[R4, #+0]
   \   0000008C   0249               LDR      R1,??TIM_Init_6  ;; 0xfff7
   \   0000008E   0140               ANDS     R1,R1,R0
   \   00000090   2180               STRH     R1,[R4, #+0]
    234                }
    235              break;
    236          
    237              default:
    238              break;
    239            }
    240          }
   \                     ??TIM_Init_4:
   \   00000092   38BC               POP      {R3-R5}
   \   00000094   01BC               POP      {R0}
   \   00000096   0047               BX       R0               ;; return
   \                     ??TIM_Init_6:
   \   00000098   F7FF0000           DC32     0xfff7
    241          
    242          /*******************************************************************************
    243          * Function Name  : TIM_StructInit
    244          * Description    : Fills each TIM_InitStruct member with its default value.
    245          * Input          : TIM_InitStruct : pointer to a TIM_InitTypeDef structure
    246          *                  which will be initialized.
    247          * Output         : None                        
    248          * Return         : None.
    249          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    250          void TIM_StructInit(TIM_InitTypeDef *TIM_InitStruct)
    251          {
    252            /* Set the default configuration */
    253            TIM_InitStruct->TIM_Mode = TIM_Mode_OCTiming;
   \                     TIM_StructInit:
   \   00000000   0121               MOVS     R1,#+1
   \   00000002   0180               STRH     R1,[R0, #+0]
    254            TIM_InitStruct->TIM_Prescaler = TIM_Prescaler_Reset_Mask;
   \   00000004   0021               MOVS     R1,#+0
   \   00000006   4180               STRH     R1,[R0, #+2]
    255            TIM_InitStruct->TIM_ClockSource = TIM_ClockSource_Internal;
   \   00000008   0121               MOVS     R1,#+1
   \   0000000A   8180               STRH     R1,[R0, #+4]
    256            TIM_InitStruct->TIM_ExtCLKEdge = TIM_ExtCLKEdge_Rising;
   \   0000000C   0221               MOVS     R1,#+2
   \   0000000E   C180               STRH     R1,[R0, #+6]
    257            TIM_InitStruct->TIM_CounterMode = TIM_CounterMode_Up;
   \   00000010   0021               MOVS     R1,#+0
   \   00000012   0181               STRH     R1,[R0, #+8]
    258            TIM_InitStruct->TIM_Period = TIM_Period_Reset_Mask;
   \   00000014   0D49               LDR      R1,??TIM_StructInit_0  ;; 0xffff
   \   00000016   4181               STRH     R1,[R0, #+10]
    259            TIM_InitStruct->TIM_Channel = TIM_Channel_ALL;
   \   00000018   0321               MOVS     R1,#+3
   \   0000001A   8181               STRH     R1,[R0, #+12]
    260            TIM_InitStruct->TIM_Pulse1 = TIM_Pulse1_Reset_Mask;
   \   0000001C   0021               MOVS     R1,#+0
   \   0000001E   C181               STRH     R1,[R0, #+14]
    261            TIM_InitStruct->TIM_Pulse2 = TIM_Pulse2_Reset_Mask;
   \   00000020   0021               MOVS     R1,#+0
   \   00000022   0182               STRH     R1,[R0, #+16]
    262            TIM_InitStruct->TIM_RepetitivePulse = TIM_RepetitivePulse_Disable;
   \   00000024   0521               MOVS     R1,#+5
   \   00000026   4182               STRH     R1,[R0, #+18]
    263            TIM_InitStruct->TIM_Polarity1 = TIM_Polarity1_Low;
   \   00000028   0221               MOVS     R1,#+2
   \   0000002A   8182               STRH     R1,[R0, #+20]
    264            TIM_InitStruct->TIM_Polarity2 = TIM_Polarity2_Low;
   \   0000002C   0221               MOVS     R1,#+2
   \   0000002E   C182               STRH     R1,[R0, #+22]
    265            TIM_InitStruct->TIM_IC1Selection = TIM_IC1Selection_TI1;
   \   00000030   0121               MOVS     R1,#+1
   \   00000032   0183               STRH     R1,[R0, #+24]
    266            TIM_InitStruct->TIM_IC2Selection = TIM_IC2Selection_TI1;
   \   00000034   0121               MOVS     R1,#+1
   \   00000036   4183               STRH     R1,[R0, #+26]
    267            TIM_InitStruct->TIM_IC1Polarity = TIM_IC1Polarity_Rising;
   \   00000038   0221               MOVS     R1,#+2
   \   0000003A   8183               STRH     R1,[R0, #+28]
    268            TIM_InitStruct->TIM_IC2Polarity = TIM_IC2Polarity_Rising;
   \   0000003C   0221               MOVS     R1,#+2
   \   0000003E   C183               STRH     R1,[R0, #+30]
    269            TIM_InitStruct->TIM_PWMI_ICSelection = TIM_PWMI_ICSelection_TI1;
   \   00000040   0121               MOVS     R1,#+1
   \   00000042   0184               STRH     R1,[R0, #+32]
    270            TIM_InitStruct->TIM_PWMI_ICPolarity = TIM_PWMI_ICPolarity_Rising;
   \   00000044   0421               MOVS     R1,#+4
   \   00000046   4184               STRH     R1,[R0, #+34]
    271          }
   \   00000048   7047               BX       LR               ;; return
   \   0000004A   C046               Nop      
   \                     ??TIM_StructInit_0:
   \   0000004C   FFFF0000           DC32     0xffff
    272          
    273          /*******************************************************************************
    274          * Function Name  : TIM_Cmd
    275          * Description    : Enables or disables the specified TIM peripheral.
    276          * Input          : - TIMx: where x can be 0, 1 or 2 to select the TIM peripheral.
    277          *                  - Newstate: new state of the TIMx peripheral.
    278          *                    This parameter can be: ENABLE or DISABLE.
    279          * Output         : None
    280          * Return         : None
    281          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    282          void TIM_Cmd(TIM_TypeDef *TIMx, FunctionalState Newstate)
    283          {
   \                     TIM_Cmd:
   \   00000000   01B5               PUSH     {R0,LR}
    284           if(Newstate == ENABLE)
   \   00000002   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000004   090E               LSRS     R1,R1,#+24
   \   00000006   0129               CMP      R1,#+1
   \   00000008   04D1               BNE      ??TIM_Cmd_0
    285            { 
    286              TIMx->CR |= TIM_COUNTER_Start;
   \   0000000A   0288               LDRH     R2,[R0, #+0]
   \   0000000C   0423               MOVS     R3,#+4
   \   0000000E   1343               ORRS     R3,R3,R2
   \   00000010   0380               STRH     R3,[R0, #+0]
   \   00000012   03E0               B        ??TIM_Cmd_1
    287            }
    288            else
    289            {
    290              TIMx->CR &= TIM_COUNTER_Stop;
   \                     ??TIM_Cmd_0:
   \   00000014   0288               LDRH     R2,[R0, #+0]
   \   00000016   034B               LDR      R3,??TIM_Cmd_2   ;; 0xfffb
   \   00000018   1340               ANDS     R3,R3,R2
   \   0000001A   0380               STRH     R3,[R0, #+0]
    291            }
    292          }
   \                     ??TIM_Cmd_1:
   \   0000001C   08BC               POP      {R3}
   \   0000001E   01BC               POP      {R0}
   \   00000020   0047               BX       R0               ;; return
   \   00000022   C046               Nop      
   \                     ??TIM_Cmd_2:
   \   00000024   FBFF0000           DC32     0xfffb
    293          
    294          /*******************************************************************************
    295          * Function Name  : TIM_ITConfig
    296          * Description    : Enables or disables the TIM interrupts.
    297          * Input          : - TIMx: where x can be 0, 1 or 2 to select the TIM peripheral.
    298          *                  - TIM_IT: specifies the TIM interrupts sources to be enabled
    299          *                    or disabled.
    300          *                    This parameter can be any combination of the following values:
    301          *                         - TIM_IT_IC1: Input Capture 1 Interrupt 
    302          *                         - TIM_IT_OC1: Output Compare 1 Interrupt 
    303          *                         - TIM_IT_Update: Timer update Interrupt 
    304          *                         - TIM_IT_GlobalUpdate: Timer global update Interrupt 
    305          *                         - TIM_IT_IC2: Input Capture 2 Interrupt 
    306          *                         - TIM_IT_OC2: Output Compare 2 Interrupt 
    307          *                  - Newstate: new state of the specified TIMx interrupts. 
    308          *                    This parameter can be: ENABLE or DISABLE.
    309          * Output         : None
    310          * Return         : None
    311          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    312          void TIM_ITConfig(TIM_TypeDef *TIMx, u16 TIM_IT, FunctionalState Newstate)
    313          { 
   \                     TIM_ITConfig:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
    314            u16 TIM_IT_Enable = 0;
   \   00000002   0024               MOVS     R4,#+0
   \   00000004   2300               MOVS     R3,R4
    315          
    316            TIM_IT_Enable = TIM_IT & TIM_IT_Enable_Mask;
   \   00000006   4C04               LSLS     R4,R1,#+17       ;; ZeroExtS R4,R1,#+17,#+17
   \   00000008   640C               LSRS     R4,R4,#+17
   \   0000000A   2300               MOVS     R3,R4
    317          
    318            if(Newstate == ENABLE)
   \   0000000C   1206               LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \   0000000E   120E               LSRS     R2,R2,#+24
   \   00000010   012A               CMP      R2,#+1
   \   00000012   1AD1               BNE      ??TIM_ITConfig_0
    319            {
    320              /* Update interrupt global source: overflow/undeflow, counter reset operation
    321              or slave mode controller in reset mode */
    322              if((TIM_IT & TIM_IT_GlobalUpdate) == TIM_IT_GlobalUpdate)
   \   00000014   0904               LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
   \   00000016   090C               LSRS     R1,R1,#+16
   \   00000018   104C               LDR      R4,??TIM_ITConfig_1  ;; 0x1001
   \   0000001A   0C40               ANDS     R4,R4,R1
   \   0000001C   0F4D               LDR      R5,??TIM_ITConfig_1  ;; 0x1001
   \   0000001E   AC42               CMP      R4,R5
   \   00000020   04D1               BNE      ??TIM_ITConfig_2
    323              {
    324                TIMx->CR &= TIM_UFS_Reset;
   \   00000022   0488               LDRH     R4,[R0, #+0]
   \   00000024   ....               LDR      R5,??DataTable5  ;; 0xfffe
   \   00000026   2540               ANDS     R5,R5,R4
   \   00000028   0580               STRH     R5,[R0, #+0]
   \   0000002A   07E0               B        ??TIM_ITConfig_3
    325              }
    326              /* Update interrupt source: counter overflow/underflow */
    327              else if((TIM_IT & TIM_IT_Update) == TIM_IT_Update)
   \                     ??TIM_ITConfig_2:
   \   0000002C   0904               LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
   \   0000002E   090C               LSRS     R1,R1,#+16
   \   00000030   CC07               LSLS     R4,R1,#+31
   \   00000032   03D5               BPL      ??TIM_ITConfig_3
    328              {
    329                TIMx->CR |= TIM_UFS_Set;
   \   00000034   0488               LDRH     R4,[R0, #+0]
   \   00000036   0125               MOVS     R5,#+1
   \   00000038   2543               ORRS     R5,R5,R4
   \   0000003A   0580               STRH     R5,[R0, #+0]
    330              }
    331              /* Select and enable the interrupts requests */
    332              TIMx->RSR |= TIM_IT_Enable;
   \                     ??TIM_ITConfig_3:
   \   0000003C   048B               LDRH     R4,[R0, #+24]
   \   0000003E   1C43               ORRS     R4,R4,R3
   \   00000040   0483               STRH     R4,[R0, #+24]
    333              TIMx->RER |= TIM_IT_Enable;
   \   00000042   848B               LDRH     R4,[R0, #+28]
   \   00000044   1C43               ORRS     R4,R4,R3
   \   00000046   8483               STRH     R4,[R0, #+28]
   \   00000048   05E0               B        ??TIM_ITConfig_4
    334            }
    335            /* Disable the interrupts requests */
    336            else
    337            {
    338              TIMx->RSR &= ~TIM_IT_Enable;
   \                     ??TIM_ITConfig_0:
   \   0000004A   048B               LDRH     R4,[R0, #+24]
   \   0000004C   9C43               BICS     R4,R4,R3
   \   0000004E   0483               STRH     R4,[R0, #+24]
    339              TIMx->RER &= ~TIM_IT_Enable;
   \   00000050   848B               LDRH     R4,[R0, #+28]
   \   00000052   9C43               BICS     R4,R4,R3
   \   00000054   8483               STRH     R4,[R0, #+28]
    340            }
    341          }
   \                     ??TIM_ITConfig_4:
   \   00000056   38BC               POP      {R3-R5}
   \   00000058   01BC               POP      {R0}
   \   0000005A   0047               BX       R0               ;; return
   \                     ??TIM_ITConfig_1:
   \   0000005C   01100000           DC32     0x1001
    342          
    343          /*******************************************************************************
    344          * Function Name  : TIM_PreloadConfig
    345          * Description    : Enables or disables TIM peripheral Preload register on OCRx.
    346          * Input          : - TIMx: where x can be 0, 1 or 2 to select the TIM peripheral.
    347          *                  - TIM_Channel: specifies the TIM channel to be used.
    348          *                    This parameter can be one of the following values:
    349          *                         - TIM_Channel_1: TIM Channel 1 is used
    350          *                         - TIM_Channel_2: TIM Channel 2 is used
    351          *                         - TIM_Channel_ALL: TIM Channel 1and 2 are used
    352          *                  - Newstate: new state of the TIMx peripheral Preload register
    353          *                    This parameter can be: ENABLE or DISABLE.
    354          * Output         : None
    355          * Return         : None
    356          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    357          void TIM_PreloadConfig(TIM_TypeDef *TIMx, u16 TIM_Channel, FunctionalState Newstate)
    358          {
   \                     TIM_PreloadConfig:
   \   00000000   10B5               PUSH     {R4,LR}
    359            if(Newstate == ENABLE)
   \   00000002   1206               LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \   00000004   120E               LSRS     R2,R2,#+24
   \   00000006   012A               CMP      R2,#+1
   \   00000008   1AD1               BNE      ??TIM_PreloadConfig_0
    360            {
    361              switch (TIM_Channel)
   \   0000000A   0904               LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
   \   0000000C   090C               LSRS     R1,R1,#+16
   \   0000000E   0B00               MOVS     R3,R1
   \   00000010   5B1E               SUBS     R3,R3,#+1
   \   00000012   04D0               BEQ      ??TIM_PreloadConfig_1
   \   00000014   5B1E               SUBS     R3,R3,#+1
   \   00000016   07D0               BEQ      ??TIM_PreloadConfig_2
   \   00000018   5B1E               SUBS     R3,R3,#+1
   \   0000001A   0BD0               BEQ      ??TIM_PreloadConfig_3
   \   0000001C   28E0               B        ??TIM_PreloadConfig_4
    362              {
    363                case TIM_Channel_1:
    364                TIMx->OMR1 |= TIM_PLD1_Set;
   \                     ??TIM_PreloadConfig_1:
   \   0000001E   8389               LDRH     R3,[R0, #+12]
   \   00000020   0124               MOVS     R4,#+1
   \   00000022   1C43               ORRS     R4,R4,R3
   \   00000024   8481               STRH     R4,[R0, #+12]
   \   00000026   23E0               B        ??TIM_PreloadConfig_4
    365                break;
    366             
    367                case TIM_Channel_2:
    368                TIMx->OMR1 |= TIM_PLD2_Set;
   \                     ??TIM_PreloadConfig_2:
   \   00000028   8389               LDRH     R3,[R0, #+12]
   \   0000002A   8024               MOVS     R4,#+128
   \   0000002C   6400               LSLS     R4,R4,#+1        ;; #+256
   \   0000002E   1C43               ORRS     R4,R4,R3
   \   00000030   8481               STRH     R4,[R0, #+12]
   \   00000032   1DE0               B        ??TIM_PreloadConfig_4
    369                break;
    370          
    371                case TIM_Channel_ALL:
    372                TIMx->OMR1 |= TIM_PLD1_Set | TIM_PLD2_Set;
   \                     ??TIM_PreloadConfig_3:
   \   00000034   8389               LDRH     R3,[R0, #+12]
   \   00000036   FF24               MOVS     R4,#+255
   \   00000038   A41C               ADDS     R4,R4,#+2        ;; #+257
   \   0000003A   1C43               ORRS     R4,R4,R3
   \   0000003C   8481               STRH     R4,[R0, #+12]
   \   0000003E   17E0               B        ??TIM_PreloadConfig_4
    373                break;
    374          
    375                default:
    376                break;
    377             }
    378            }
    379            else
    380            {
    381              switch (TIM_Channel)
   \                     ??TIM_PreloadConfig_0:
   \   00000040   0904               LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
   \   00000042   090C               LSRS     R1,R1,#+16
   \   00000044   0B00               MOVS     R3,R1
   \   00000046   5B1E               SUBS     R3,R3,#+1
   \   00000048   04D0               BEQ      ??TIM_PreloadConfig_5
   \   0000004A   5B1E               SUBS     R3,R3,#+1
   \   0000004C   07D0               BEQ      ??TIM_PreloadConfig_6
   \   0000004E   5B1E               SUBS     R3,R3,#+1
   \   00000050   0AD0               BEQ      ??TIM_PreloadConfig_7
   \   00000052   0DE0               B        ??TIM_PreloadConfig_4
    382              {
    383                case TIM_Channel_1:
    384                TIMx->OMR1 &= TIM_PLD1_Reset;
   \                     ??TIM_PreloadConfig_5:
   \   00000054   8389               LDRH     R3,[R0, #+12]
   \   00000056   ....               LDR      R4,??DataTable5  ;; 0xfffe
   \   00000058   1C40               ANDS     R4,R4,R3
   \   0000005A   8481               STRH     R4,[R0, #+12]
   \   0000005C   08E0               B        ??TIM_PreloadConfig_4
    385                break;
    386             
    387                case TIM_Channel_2:
    388                TIMx->OMR1 &= TIM_PLD2_Reset;
   \                     ??TIM_PreloadConfig_6:
   \   0000005E   8389               LDRH     R3,[R0, #+12]
   \   00000060   054C               LDR      R4,??TIM_PreloadConfig_8  ;; 0xfeff
   \   00000062   1C40               ANDS     R4,R4,R3
   \   00000064   8481               STRH     R4,[R0, #+12]
   \   00000066   03E0               B        ??TIM_PreloadConfig_4
    389                break;
    390          
    391                case TIM_Channel_ALL:
    392                TIMx->OMR1 &= TIM_PLD1_Reset & TIM_PLD2_Reset;
   \                     ??TIM_PreloadConfig_7:
   \   00000068   8389               LDRH     R3,[R0, #+12]
   \   0000006A   044C               LDR      R4,??TIM_PreloadConfig_8+0x4  ;; 0xfefe
   \   0000006C   1C40               ANDS     R4,R4,R3
   \   0000006E   8481               STRH     R4,[R0, #+12]
    393                break;
    394          
    395                default:
    396                break;
    397              }
    398            }  
    399          }
   \                     ??TIM_PreloadConfig_4:
   \   00000070   10BC               POP      {R4}
   \   00000072   01BC               POP      {R0}
   \   00000074   0047               BX       R0               ;; return
   \   00000076   C046               Nop      
   \                     ??TIM_PreloadConfig_8:
   \   00000078   FFFE0000           DC32     0xfeff
   \   0000007C   FEFE0000           DC32     0xfefe
    400          
    401          /*******************************************************************************
    402          * Function Name  : TIM_DMAConfig
    403          * Description    : Configures the TIM0’s DMA interface.
    404          * Input          : - TIM_DMASources: specifies the DMA Request sources.
    405          *                    This parameter can be any combination of the following values:
    406          *                         - TIM_DMASource_OC1: Output Compare 1 DMA source
    407          *                         - TIM_DMASource_OC2: Output Compare 2 DMA source
    408          *                         - TIM_DMASource_IC1: Input Capture 1 DMA source
    409          *                         - TIM_DMASource_IC2: Input Capture 2 DMA source
    410          *                         - TIM_DMASource_Update: Timer Update DMA source
    411          *                  - TIM_OCRMState: the state of output compare request mode.
    412          *                    This parameter can be one of the following values:
    413          *                         - TIM_OCRMState_Enable 
    414          *                         - TIM_OCRMState_Disable 
    415          *                  - TIM_DMABase:DMA Base address.
    416          *                    This parameter can be one of the following values:
    417          *                    TIM_DMABase_CR, TIM_DMABase_SCR, TIM_DMABase_IMCR,
    418          *                    TIM_DMABase_OMR1, TIM_DMABase_RSR,
    419          *                    TIM_DMABase_RER, TIM_DMABase_ISR, TIM_DMABase_CNT, 
    420          *                    TIM_DMABase_PSC, TIM_DMABase_ARR, TIM_DMABase_OCR1, 
    421          *                    TIM_DMABase_OCR2, TIM_DMABase_ICR1, TIM_DMABase_ICR2
    422          * Output         : None
    423          * Return         : None
    424          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    425          void TIM_DMAConfig(u16 TIM_DMASources, u16 TIM_OCRMState, u16 TIM_DMABase)
    426          {
   \                     TIM_DMAConfig:
   \   00000000   10B5               PUSH     {R4,LR}
    427            /* Select the DMA requests */
    428            TIM0->RSR &= TIM_DMASources;
   \   00000002   124B               LDR      R3,??TIM_DMAConfig_0  ;; 0xffff8c18
   \   00000004   1B88               LDRH     R3,[R3, #+0]
   \   00000006   0340               ANDS     R3,R3,R0
   \   00000008   104C               LDR      R4,??TIM_DMAConfig_0  ;; 0xffff8c18
   \   0000000A   2380               STRH     R3,[R4, #+0]
    429          
    430            /* Set the OCRM state */
    431            if(TIM_OCRMState == TIM_OCRMState_Enable)
   \   0000000C   0904               LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
   \   0000000E   090C               LSRS     R1,R1,#+16
   \   00000010   0529               CMP      R1,#+5
   \   00000012   06D1               BNE      ??TIM_DMAConfig_1
    432            {
    433              TIM0->RSR |= TIM_OCRM_Set;
   \   00000014   0D4B               LDR      R3,??TIM_DMAConfig_0  ;; 0xffff8c18
   \   00000016   1B88               LDRH     R3,[R3, #+0]
   \   00000018   8024               MOVS     R4,#+128
   \   0000001A   1C43               ORRS     R4,R4,R3
   \   0000001C   0B4B               LDR      R3,??TIM_DMAConfig_0  ;; 0xffff8c18
   \   0000001E   1C80               STRH     R4,[R3, #+0]
   \   00000020   05E0               B        ??TIM_DMAConfig_2
    434            }
    435            else
    436            {
    437              TIM0->RSR &= TIM_OCRM_Reset;
   \                     ??TIM_DMAConfig_1:
   \   00000022   0A4B               LDR      R3,??TIM_DMAConfig_0  ;; 0xffff8c18
   \   00000024   1B88               LDRH     R3,[R3, #+0]
   \   00000026   0A4C               LDR      R4,??TIM_DMAConfig_0+0x4  ;; 0x30d
   \   00000028   1C40               ANDS     R4,R4,R3
   \   0000002A   084B               LDR      R3,??TIM_DMAConfig_0  ;; 0xffff8c18
   \   0000002C   1C80               STRH     R4,[R3, #+0]
    438            }
    439          
    440            /* Set the DMA Base address */
    441            TIM0->CR &= TIM_DBASE_Mask;
   \                     ??TIM_DMAConfig_2:
   \   0000002E   ....               LDR      R3,??DataTable9  ;; 0xffff8c00
   \   00000030   1B88               LDRH     R3,[R3, #+0]
   \   00000032   084C               LDR      R4,??TIM_DMAConfig_0+0x8  ;; 0x77f
   \   00000034   1C40               ANDS     R4,R4,R3
   \   00000036   ....               LDR      R3,??DataTable9  ;; 0xffff8c00
   \   00000038   1C80               STRH     R4,[R3, #+0]
    442            TIM0->CR |= TIM_DMABase;
   \   0000003A   ....               LDR      R3,??DataTable9  ;; 0xffff8c00
   \   0000003C   1B88               LDRH     R3,[R3, #+0]
   \   0000003E   1343               ORRS     R3,R3,R2
   \   00000040   ....               LDR      R4,??DataTable9  ;; 0xffff8c00
   \   00000042   2380               STRH     R3,[R4, #+0]
    443          }
   \   00000044   10BC               POP      {R4}
   \   00000046   01BC               POP      {R0}
   \   00000048   0047               BX       R0               ;; return
   \   0000004A   C046               Nop      
   \                     ??TIM_DMAConfig_0:
   \   0000004C   188CFFFF           DC32     0xffff8c18
   \   00000050   0D030000           DC32     0x30d
   \   00000054   7F070000           DC32     0x77f
    444          
    445          /*******************************************************************************
    446          * Function Name  : TIM_DMACmd
    447          * Description    : Enables or disables the TIM0’s DMA interface.
    448          * Input          : - TIM_DMASources: specifies the DMA Request sources.
    449          *                    This parameter can be any combination of the following values:
    450          *                         - TIM_DMASource_OC1: Output Compare 1 DMA source
    451          *                         - TIM_DMASource_OC2: Output Compare 2 DMA source
    452          *                         - TIM_DMASource_IC1: Input Capture 1 DMA source
    453          *                         - TIM_DMASource_IC2: Input Capture 2 DMA source
    454          *                         - TIM_DMASource_Update: Timer Update DMA source
    455          *                  - Newstate: new state of the DMA Request sources.
    456          *                    This parameter can be: ENABLE or DISABLE.
    457          * Output         : None
    458          * Return         : None
    459          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    460          void TIM_DMACmd(u16 TIM_DMASources, FunctionalState Newstate)
    461          {
   \                     TIM_DMACmd:
   \   00000000   01B5               PUSH     {R0,LR}
    462            if(Newstate == ENABLE)
   \   00000002   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000004   090E               LSRS     R1,R1,#+24
   \   00000006   0129               CMP      R1,#+1
   \   00000008   05D1               BNE      ??TIM_DMACmd_0
    463            {
    464              TIM0->RER |= TIM_DMASources;
   \   0000000A   074A               LDR      R2,??TIM_DMACmd_1  ;; 0xffff8c1c
   \   0000000C   1288               LDRH     R2,[R2, #+0]
   \   0000000E   0243               ORRS     R2,R2,R0
   \   00000010   054B               LDR      R3,??TIM_DMACmd_1  ;; 0xffff8c1c
   \   00000012   1A80               STRH     R2,[R3, #+0]
   \   00000014   04E0               B        ??TIM_DMACmd_2
    465            }
    466            else
    467            {
    468              TIM0->RER &= ~TIM_DMASources;
   \                     ??TIM_DMACmd_0:
   \   00000016   044A               LDR      R2,??TIM_DMACmd_1  ;; 0xffff8c1c
   \   00000018   1288               LDRH     R2,[R2, #+0]
   \   0000001A   8243               BICS     R2,R2,R0
   \   0000001C   024B               LDR      R3,??TIM_DMACmd_1  ;; 0xffff8c1c
   \   0000001E   1A80               STRH     R2,[R3, #+0]
    469            }
    470          }
   \                     ??TIM_DMACmd_2:
   \   00000020   08BC               POP      {R3}
   \   00000022   01BC               POP      {R0}
   \   00000024   0047               BX       R0               ;; return
   \   00000026   C046               Nop      
   \                     ??TIM_DMACmd_1:
   \   00000028   1C8CFFFF           DC32     0xffff8c1c
    471          
    472          /*******************************************************************************
    473          * Function Name  : TIM_ClockSourceConfig
    474          * Description    : Configures the TIM clock source.
    475          * Input          : - TIMx: where x can be 0, 1 or 2 to select the TIM peripheral.
    476          *                  - TIM_ClockSource: specifies the TIM clock source to be 
    477          *                    selected.
    478          *                    This parameter can be one of the following values:
    479          *                         - TIM_ClockSource_Internal: CK_TIM internal clock
    480          *                         - TIM_ClockSource_TI11: External input pin TI1 
    481          *                           connected to IC1 channel.
    482          *                         - TIM_ClockSource_TI12: External input pin TI1
    483          *                           connected to IC2 channel.
    484          *                         - TIM_ClockSource_TI22: External input pin TI2
    485          *                           connected to IC2 channel.
    486          *                         - TIM_ClockSource_TI21: External input pin TI2
    487          *                           connected to IC1 channel.
    488          *                  - TIM_ExtCLKEdge: specifies the External input signal edge.
    489          *                    This parameter can be one of the following values:
    490          *                         - TIM_ExtCLKEdge_Falling : Falling edge selected.
    491          *                         - TIM_ExtCLKEdge_Rising : Rising edge selected.
    492          * Output         : None
    493          * Return         : None
    494          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    495          void TIM_ClockSourceConfig(TIM_TypeDef *TIMx, u16 TIM_ClockSource,
    496                                     u16 TIM_ExtCLKEdge)
    497          {
   \                     TIM_ClockSourceConfig:
   \   00000000   10B5               PUSH     {R4,LR}
    498            if(TIM_ClockSource == TIM_ClockSource_Internal)
   \   00000002   0904               LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
   \   00000004   090C               LSRS     R1,R1,#+16
   \   00000006   0129               CMP      R1,#+1
   \   00000008   04D1               BNE      ??TIM_ClockSourceConfig_0
    499            {
    500              /* CK_TIM is used as clock source */
    501              TIMx->SCR &= TIM_SME_Reset & TIM_SlaveModeSelection_Mask & TIM_TriggerSelection_Mask;
   \   0000000A   8388               LDRH     R3,[R0, #+4]
   \   0000000C   2E4C               LDR      R4,??TIM_ClockSourceConfig_1  ;; 0x7003
   \   0000000E   1C40               ANDS     R4,R4,R3
   \   00000010   8480               STRH     R4,[R0, #+4]
   \   00000012   56E0               B        ??TIM_ClockSourceConfig_2
    502            }
    503            else
    504            /* Input Captures are used as TIM external clock */
    505            {
    506              TIMx->SCR &= TIM_SME_Reset & TIM_SlaveModeSelection_Mask & TIM_TriggerSelection_Mask;
   \                     ??TIM_ClockSourceConfig_0:
   \   00000014   8388               LDRH     R3,[R0, #+4]
   \   00000016   2C4C               LDR      R4,??TIM_ClockSourceConfig_1  ;; 0x7003
   \   00000018   1C40               ANDS     R4,R4,R3
   \   0000001A   8480               STRH     R4,[R0, #+4]
    507              TIMx->SCR |= TIM_SMS_EXTCLK_Set | TIM_SME_Set;
   \   0000001C   8388               LDRH     R3,[R0, #+4]
   \   0000001E   0C24               MOVS     R4,#+12
   \   00000020   1C43               ORRS     R4,R4,R3
   \   00000022   8480               STRH     R4,[R0, #+4]
    508          
    509              if((TIM_ClockSource == TIM_ClockSource_TI11) ||
    510                (TIM_ClockSource == TIM_ClockSource_TI21))
   \   00000024   0904               LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
   \   00000026   090C               LSRS     R1,R1,#+16
   \   00000028   0229               CMP      R1,#+2
   \   0000002A   03D0               BEQ      ??TIM_ClockSourceConfig_3
   \   0000002C   0904               LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
   \   0000002E   090C               LSRS     R1,R1,#+16
   \   00000030   0529               CMP      R1,#+5
   \   00000032   23D1               BNE      ??TIM_ClockSourceConfig_4
    511              /* Input Capture 1 is selected */
    512              {
    513               /* Input capture  Enable */
    514                TIMx->IMCR |= TIM_IC1_Enable;
   \                     ??TIM_ClockSourceConfig_3:
   \   00000034   0389               LDRH     R3,[R0, #+8]
   \   00000036   0424               MOVS     R4,#+4
   \   00000038   1C43               ORRS     R4,R4,R3
   \   0000003A   0481               STRH     R4,[R0, #+8]
    515                TIMx->SCR |= TIM_TS_IC1_Set;
   \   0000003C   8388               LDRH     R3,[R0, #+4]
   \   0000003E   8024               MOVS     R4,#+128
   \   00000040   A400               LSLS     R4,R4,#+2        ;; #+512
   \   00000042   1C43               ORRS     R4,R4,R3
   \   00000044   8480               STRH     R4,[R0, #+4]
    516          
    517                if(TIM_ExtCLKEdge == TIM_ExtCLKEdge_Falling)
   \   00000046   1204               LSLS     R2,R2,#+16       ;; ZeroExtS R2,R2,#+16,#+16
   \   00000048   120C               LSRS     R2,R2,#+16
   \   0000004A   012A               CMP      R2,#+1
   \   0000004C   04D1               BNE      ??TIM_ClockSourceConfig_5
    518                /* Set the corresponding polarity */
    519                {
    520                  TIMx->IMCR |= TIM_IC1P_Set;
   \   0000004E   0389               LDRH     R3,[R0, #+8]
   \   00000050   0824               MOVS     R4,#+8
   \   00000052   1C43               ORRS     R4,R4,R3
   \   00000054   0481               STRH     R4,[R0, #+8]
   \   00000056   03E0               B        ??TIM_ClockSourceConfig_6
    521                }
    522                else
    523                {   
    524                  TIMx->IMCR &= TIM_IC1P_Reset;
   \                     ??TIM_ClockSourceConfig_5:
   \   00000058   0389               LDRH     R3,[R0, #+8]
   \   0000005A   3724               MOVS     R4,#+55
   \   0000005C   1C40               ANDS     R4,R4,R3
   \   0000005E   0481               STRH     R4,[R0, #+8]
    525                }
    526                if(TIM_ClockSource == TIM_ClockSource_TI11)
   \                     ??TIM_ClockSourceConfig_6:
   \   00000060   0904               LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
   \   00000062   090C               LSRS     R1,R1,#+16
   \   00000064   0229               CMP      R1,#+2
   \   00000066   04D1               BNE      ??TIM_ClockSourceConfig_7
    527                {
    528                  /* External signal TI1 connected to IC1 channel */
    529                  TIMx->IMCR &= TIM_IC1S_Reset;
   \   00000068   0389               LDRH     R3,[R0, #+8]
   \   0000006A   3E24               MOVS     R4,#+62
   \   0000006C   1C40               ANDS     R4,R4,R3
   \   0000006E   0481               STRH     R4,[R0, #+8]
   \   00000070   27E0               B        ??TIM_ClockSourceConfig_2
    530                }
    531                else
    532                {
    533                  /* External signal TI2 connected to IC1 channel */
    534                  TIMx->IMCR |= TIM_IC1S_Set;
   \                     ??TIM_ClockSourceConfig_7:
   \   00000072   0389               LDRH     R3,[R0, #+8]
   \   00000074   0124               MOVS     R4,#+1
   \   00000076   1C43               ORRS     R4,R4,R3
   \   00000078   0481               STRH     R4,[R0, #+8]
   \   0000007A   22E0               B        ??TIM_ClockSourceConfig_2
    535                }
    536              }
    537              else
    538              /* Input Capture 2 is selected */
    539              {
    540                /* Input capture  Enable */
    541                TIMx->IMCR |= TIM_IC2_Enable;
   \                     ??TIM_ClockSourceConfig_4:
   \   0000007C   0389               LDRH     R3,[R0, #+8]
   \   0000007E   1024               MOVS     R4,#+16
   \   00000080   1C43               ORRS     R4,R4,R3
   \   00000082   0481               STRH     R4,[R0, #+8]
    542                TIMx->SCR |= TIM_TS_IC2_Set;
   \   00000084   8388               LDRH     R3,[R0, #+4]
   \   00000086   C024               MOVS     R4,#+192
   \   00000088   A400               LSLS     R4,R4,#+2        ;; #+768
   \   0000008A   1C43               ORRS     R4,R4,R3
   \   0000008C   8480               STRH     R4,[R0, #+4]
    543          
    544                if(TIM_ExtCLKEdge == TIM_ExtCLKEdge_Falling)
   \   0000008E   1204               LSLS     R2,R2,#+16       ;; ZeroExtS R2,R2,#+16,#+16
   \   00000090   120C               LSRS     R2,R2,#+16
   \   00000092   012A               CMP      R2,#+1
   \   00000094   04D1               BNE      ??TIM_ClockSourceConfig_8
    545                /* Set the corresponding polarity */
    546                {
    547                  TIMx->IMCR |= TIM_IC2P_Set;
   \   00000096   0389               LDRH     R3,[R0, #+8]
   \   00000098   2024               MOVS     R4,#+32
   \   0000009A   1C43               ORRS     R4,R4,R3
   \   0000009C   0481               STRH     R4,[R0, #+8]
   \   0000009E   03E0               B        ??TIM_ClockSourceConfig_9
    548                }
    549                else
    550                {
    551                   TIMx->IMCR &= TIM_IC2P_Reset;
   \                     ??TIM_ClockSourceConfig_8:
   \   000000A0   0389               LDRH     R3,[R0, #+8]
   \   000000A2   DB06               LSLS     R3,R3,#+27       ;; ZeroExtS R3,R3,#+27,#+27
   \   000000A4   DB0E               LSRS     R3,R3,#+27
   \   000000A6   0381               STRH     R3,[R0, #+8]
    552                }
    553                if(TIM_ClockSource == TIM_ClockSource_TI22)
   \                     ??TIM_ClockSourceConfig_9:
   \   000000A8   0904               LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
   \   000000AA   090C               LSRS     R1,R1,#+16
   \   000000AC   0429               CMP      R1,#+4
   \   000000AE   04D1               BNE      ??TIM_ClockSourceConfig_10
    554                {
    555                  /* External signal TI2 connected to IC2 channel */
    556                  TIMx->IMCR &= TIM_IC2S_Reset;
   \   000000B0   0389               LDRH     R3,[R0, #+8]
   \   000000B2   3D24               MOVS     R4,#+61
   \   000000B4   1C40               ANDS     R4,R4,R3
   \   000000B6   0481               STRH     R4,[R0, #+8]
   \   000000B8   03E0               B        ??TIM_ClockSourceConfig_2
    557                }
    558                else
    559                {
    560                  /* External signal TI1 connected to IC2 channel */
    561                  TIMx->IMCR |= TIM_IC2S_Set;
   \                     ??TIM_ClockSourceConfig_10:
   \   000000BA   0389               LDRH     R3,[R0, #+8]
   \   000000BC   0224               MOVS     R4,#+2
   \   000000BE   1C43               ORRS     R4,R4,R3
   \   000000C0   0481               STRH     R4,[R0, #+8]
    562                }
    563              }
    564            }
    565          }
   \                     ??TIM_ClockSourceConfig_2:
   \   000000C2   10BC               POP      {R4}
   \   000000C4   01BC               POP      {R0}
   \   000000C6   0047               BX       R0               ;; return
   \                     ??TIM_ClockSourceConfig_1:
   \   000000C8   03700000           DC32     0x7003
    566          
    567          /*******************************************************************************
    568          * Function Name  : TIM_SetPrescaler
    569          * Description    : Sets the TIM prescaler value.
    570          * Input          : - TIMx: where x can be 0, 1 or 2 to select the TIM peripheral
    571          *                  - Prescaler: TIM prescaler new value.
    572          * Output         : None
    573          * Return         : None
    574          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    575          void TIM_SetPrescaler(TIM_TypeDef* TIMx, u16 Prescaler)
    576          {
    577            TIMx->PSC = Prescaler;
   \                     TIM_SetPrescaler:
   \   00000000   0185               STRH     R1,[R0, #+40]
    578          }
   \   00000002   7047               BX       LR               ;; return
    579          
    580          /*******************************************************************************
    581          * Function Name  : TIM_SetPeriod
    582          * Description    : Sets the TIM period value.
    583          * Input          : - TIMx: where x can be 0, 1 or 2 to select the TIM peripheral
    584          *                  - Period: TIM period new value.
    585          * Output         : None
    586          * Return         : None
    587          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    588          void TIM_SetPeriod(TIM_TypeDef* TIMx, u16 Period)
    589          {
    590            TIMx->ARR = Period;
   \                     TIM_SetPeriod:
   \   00000000   0186               STRH     R1,[R0, #+48]
    591          }
   \   00000002   7047               BX       LR               ;; return
    592          
    593          /*******************************************************************************
    594          * Function Name  : TIM_SetPulse
    595          * Description    : Sets the TIM pulse value.
    596          * Input          : - TIMx: where x can be 0, 1 or 2 to select the TIM peripheral
    597          *                  - TIM_Channel: specifies the TIM channel to be used.
    598          *                    This parameter can be one of the following values:
    599          *                         - TIM_Channel_1: TIM Channel 1 is used
    600          *                         - TIM_Channel_2: TIM Channel 2 is used
    601          *                         - TIM_Channel_ALL: TIM Channel 1and 2 are used
    602          *                  - Pulse: TIM pulse new value.
    603          * Output         : None
    604          * Return         : None
    605          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    606          void TIM_SetPulse(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 Pulse)
    607          {
   \                     TIM_SetPulse:
   \   00000000   01B5               PUSH     {R0,LR}
    608            /* Set Channel 1 pulse value */
    609            if(TIM_Channel == TIM_Channel_1)
   \   00000002   0904               LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
   \   00000004   090C               LSRS     R1,R1,#+16
   \   00000006   0129               CMP      R1,#+1
   \   00000008   01D1               BNE      ??TIM_SetPulse_0
    610            {
    611              TIMx->OCR1 = Pulse;
   \   0000000A   8286               STRH     R2,[R0, #+52]
   \   0000000C   0BE0               B        ??TIM_SetPulse_1
    612            }
    613            /* Set Channel 2 pulse value */
    614            else if(TIM_Channel == TIM_Channel_2)
   \                     ??TIM_SetPulse_0:
   \   0000000E   0904               LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
   \   00000010   090C               LSRS     R1,R1,#+16
   \   00000012   0229               CMP      R1,#+2
   \   00000014   01D1               BNE      ??TIM_SetPulse_2
    615            {
    616             TIMx->OCR2 = Pulse;
   \   00000016   0287               STRH     R2,[R0, #+56]
   \   00000018   05E0               B        ??TIM_SetPulse_1
    617            }
    618            /* Set Channel 1 and Channel 2 pulse values */
    619            else if(TIM_Channel == TIM_Channel_ALL)
   \                     ??TIM_SetPulse_2:
   \   0000001A   0904               LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
   \   0000001C   090C               LSRS     R1,R1,#+16
   \   0000001E   0329               CMP      R1,#+3
   \   00000020   01D1               BNE      ??TIM_SetPulse_1
    620            {
    621              TIMx->OCR1 = Pulse;
   \   00000022   8286               STRH     R2,[R0, #+52]
    622              TIMx->OCR2 = Pulse;
   \   00000024   0287               STRH     R2,[R0, #+56]
    623            }
    624          }
   \                     ??TIM_SetPulse_1:
   \   00000026   08BC               POP      {R3}
   \   00000028   01BC               POP      {R0}
   \   0000002A   0047               BX       R0               ;; return
    625          
    626          /*******************************************************************************
    627          * Function Name  : TIM_GetICAP1
    628          * Description    : Gets the Input Capture 1 value. 
    629          * Input          : TIMx: where x can be 0, 1 or 2 to select the TIM peripheral
    630          * Output         : None
    631          * Return         : Input Capture 1 Register value.
    632          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    633          u16 TIM_GetICAP1(TIM_TypeDef *TIMx)
    634          {
    635            return TIMx->ICR1;
   \                     TIM_GetICAP1:
   \   00000000   4C30               ADDS     R0,R0,#+76
   \   00000002   0088               LDRH     R0,[R0, #+0]
   \   00000004   7047               BX       LR               ;; return
    636          }
    637          
    638          /*******************************************************************************
    639          * Function Name  : TIM_GetICAP2
    640          * Description    : Gets the Input Capture 2 value.
    641          * Input          : TIMx: where x can be 0, 1 or 2 to select the TIM peripheral
    642          * Output         : None
    643          * Return         : Input Capture 2 Register value
    644          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    645          u16 TIM_GetICAP2(TIM_TypeDef *TIMx)
    646          {
    647            return TIMx->ICR2;
   \                     TIM_GetICAP2:
   \   00000000   5030               ADDS     R0,R0,#+80
   \   00000002   0088               LDRH     R0,[R0, #+0]
   \   00000004   7047               BX       LR               ;; return
    648          }
    649          
    650          /*******************************************************************************
    651          * Function Name  : TIM_GetPWMIPulse
    652          * Description    : Gets the PWM Input pulse value.
    653          * Input          : TIMx: where x can be 0, 1 or 2 to select the TIM peripheral
    654          * Output         : None
    655          * Return         : Input Capture 2 Register value
    656          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    657          u16 TIM_GetPWMIPulse(TIM_TypeDef *TIMx)
    658          {
    659            return TIMx->ICR2;
   \                     TIM_GetPWMIPulse:
   \   00000000   5030               ADDS     R0,R0,#+80
   \   00000002   0088               LDRH     R0,[R0, #+0]
   \   00000004   7047               BX       LR               ;; return
    660          }
    661          
    662          /*******************************************************************************
    663          * Function Name  : TIM_GetPWMIPeriod
    664          * Description    : Gets the PWM Input period value.
    665          * Input          : TIMx: where x can be 0, 1 or 2 to select the TIM peripheral
    666          * Output         : None
    667          * Return         : Input Capture 1 Register value
    668          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    669          u16 TIM_GetPWMIPeriod(TIM_TypeDef *TIMx)
    670          {
    671            return TIMx->ICR1;
   \                     TIM_GetPWMIPeriod:
   \   00000000   4C30               ADDS     R0,R0,#+76
   \   00000002   0088               LDRH     R0,[R0, #+0]
   \   00000004   7047               BX       LR               ;; return
    672          }
    673          
    674          /*******************************************************************************
    675          * Function Name  : TIM_DebugCmd
    676          * Description    : Enables or disables the specified TIM peripheral Debug control.
    677          * Input          : - TIMx: where x can be 0, 1 or 2 to select the TIM peripheral
    678          *                  - Newstate: new state of the TIMx Debug control.
    679                               This parameter can be: ENABLE or DISABLE.
    680          * Output         : None
    681          * Return         : None
    682          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    683          void TIM_DebugCmd(TIM_TypeDef *TIMx, FunctionalState Newstate)
    684          {
   \                     TIM_DebugCmd:
   \   00000000   01B5               PUSH     {R0,LR}
    685            if(Newstate == ENABLE)
   \   00000002   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000004   090E               LSRS     R1,R1,#+24
   \   00000006   0129               CMP      R1,#+1
   \   00000008   05D1               BNE      ??TIM_DebugCmd_0
    686            {
    687              TIMx->CR |= TIM_DBGC_Set;
   \   0000000A   0288               LDRH     R2,[R0, #+0]
   \   0000000C   8023               MOVS     R3,#+128
   \   0000000E   DB00               LSLS     R3,R3,#+3        ;; #+1024
   \   00000010   1343               ORRS     R3,R3,R2
   \   00000012   0380               STRH     R3,[R0, #+0]
   \   00000014   03E0               B        ??TIM_DebugCmd_1
    688            }
    689            else
    690            {
    691              TIMx->CR &= TIM_DBGC_Reset;
   \                     ??TIM_DebugCmd_0:
   \   00000016   0288               LDRH     R2,[R0, #+0]
   \   00000018   024B               LDR      R3,??TIM_DebugCmd_2  ;; 0xfb7f
   \   0000001A   1340               ANDS     R3,R3,R2
   \   0000001C   0380               STRH     R3,[R0, #+0]
    692            }
    693          }
   \                     ??TIM_DebugCmd_1:
   \   0000001E   08BC               POP      {R3}
   \   00000020   01BC               POP      {R0}
   \   00000022   0047               BX       R0               ;; return
   \                     ??TIM_DebugCmd_2:
   \   00000024   7FFB0000           DC32     0xfb7f
    694          
    695          /*******************************************************************************
    696          * Function Name  : TIM_CounterModeConfig
    697          * Description    : Specifies the Counter Mode to be used.
    698          * Input          : - TIMx: where x can be 0, 1 or 2 to select the TIM peripheral.
    699          *                  - TIM_CounterMode: specifies the Counter Mode to be used
    700          *                    This parameter can be one of the following values:
    701          *                       - TIM_CounterMode_Up: TIM Up Counting Mode
    702          *                       - TIM_CounterMode_Down: TIM Down Counting Mode
    703          *                       - TIM_CounterMode_CenterAligned1: TIM Center Aligned Mode1
    704          *                       - TIM_CounterMode_CenterAligned2: TIM Center Aligned Mode2
    705          *                       - TIM_CounterMode_CenterAligned3: TIM Center Aligned Mode3
    706          * Output         : None
    707          * Return         : None
    708          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    709          void TIM_CounterModeConfig(TIM_TypeDef* TIMx, u16 TIM_CounterMode)
    710          {
    711            /* Counter mode configuration */
    712            TIMx->CR &= TIM_CounterMode_Mask;
   \                     TIM_CounterModeConfig:
   \   00000000   0288               LDRH     R2,[R0, #+0]
   \   00000002   034B               LDR      R3,??TIM_CounterModeConfig_0  ;; 0xff8f
   \   00000004   1340               ANDS     R3,R3,R2
   \   00000006   0380               STRH     R3,[R0, #+0]
    713            TIMx->CR |= TIM_CounterMode;
   \   00000008   0288               LDRH     R2,[R0, #+0]
   \   0000000A   0A43               ORRS     R2,R2,R1
   \   0000000C   0280               STRH     R2,[R0, #+0]
    714          }
   \   0000000E   7047               BX       LR               ;; return
   \                     ??TIM_CounterModeConfig_0:
   \   00000010   8FFF0000           DC32     0xff8f
    715          
    716          /*******************************************************************************
    717          * Function Name  : TIM_ForcedOCConfig
    718          * Description    : Forces the TIM output waveform to active or inactive level.
    719          * Input          : - TIMx: where x can be 0, 1 or 2 to select the TIM peripheral.
    720          *                  - TIM_Channel: specifies the TIM channel to be used.
    721          *                    This parameter can be one of the following values:
    722          *                       - TIM_Channel_1: Timer Channel 1 is used
    723          *                       - TIM_Channel_2: Timer Channel 2 is used
    724          *                       - TIM_Channel_ALL: Timer Channel 1 and 2 are used
    725          *                 - TIM_ForcedAction: specifies the forced Action to be set to
    726          *                  the output waveform.
    727          *                    This parameter can be one of the following values:
    728          *                       - TIM_ForcedAction_Active: Force active level on OCxREF
    729          *                       - TIM_ForcedAction_InActive: Force inactive level on 
    730          *                         OCxREF.
    731          * Output         : None
    732          * Return         : None
    733          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    734          void TIM_ForcedOCConfig(TIM_TypeDef* TIMx, u16 TIM_Channel,u16 TIM_ForcedAction)
    735          {
   \                     TIM_ForcedOCConfig:
   \   00000000   10B5               PUSH     {R4,LR}
    736            /* Channel 1 Forced Output Compare mode configuration */
    737            if(TIM_Channel == TIM_Channel_1)
   \   00000002   0904               LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
   \   00000004   090C               LSRS     R1,R1,#+16
   \   00000006   0129               CMP      R1,#+1
   \   00000008   07D1               BNE      ??TIM_ForcedOCConfig_0
    738            {
    739              TIMx->OMR1 &= TIM_OC1C_Mask;
   \   0000000A   8389               LDRH     R3,[R0, #+12]
   \   0000000C   0F4C               LDR      R4,??TIM_ForcedOCConfig_1  ;; 0x3f31
   \   0000000E   1C40               ANDS     R4,R4,R3
   \   00000010   8481               STRH     R4,[R0, #+12]
    740              TIMx->OMR1 |= TIM_ForcedAction;
   \   00000012   8389               LDRH     R3,[R0, #+12]
   \   00000014   1343               ORRS     R3,R3,R2
   \   00000016   8381               STRH     R3,[R0, #+12]
   \   00000018   15E0               B        ??TIM_ForcedOCConfig_2
    741            }
    742            /* Channel 2 Forced Output Compare mode configuration */
    743            else
    744            {
    745              if(TIM_Channel == TIM_Channel_2)
   \                     ??TIM_ForcedOCConfig_0:
   \   0000001A   0904               LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
   \   0000001C   090C               LSRS     R1,R1,#+16
   \   0000001E   0229               CMP      R1,#+2
   \   00000020   08D1               BNE      ??TIM_ForcedOCConfig_3
    746              {
    747                TIMx->OMR1 &= TIM_OC2C_Mask;
   \   00000022   8389               LDRH     R3,[R0, #+12]
   \   00000024   0A4C               LDR      R4,??TIM_ForcedOCConfig_1+0x4  ;; 0x313f
   \   00000026   1C40               ANDS     R4,R4,R3
   \   00000028   8481               STRH     R4,[R0, #+12]
    748                TIMx->OMR1 |= (TIM_ForcedAction<<8);
   \   0000002A   8389               LDRH     R3,[R0, #+12]
   \   0000002C   1402               LSLS     R4,R2,#+8
   \   0000002E   1C43               ORRS     R4,R4,R3
   \   00000030   8481               STRH     R4,[R0, #+12]
   \   00000032   08E0               B        ??TIM_ForcedOCConfig_2
    749              }
    750              /* Channel 1 and Channel 2 Forced Output Compare mode configuration */
    751              else
    752              {
    753                TIMx->OMR1 &= TIM_OC1C_Mask & TIM_OC2C_Mask;
   \                     ??TIM_ForcedOCConfig_3:
   \   00000034   8389               LDRH     R3,[R0, #+12]
   \   00000036   074C               LDR      R4,??TIM_ForcedOCConfig_1+0x8  ;; 0x3131
   \   00000038   1C40               ANDS     R4,R4,R3
   \   0000003A   8481               STRH     R4,[R0, #+12]
    754                TIMx->OMR1 |= TIM_ForcedAction |(TIM_ForcedAction<<8);
   \   0000003C   8389               LDRH     R3,[R0, #+12]
   \   0000003E   1402               LSLS     R4,R2,#+8
   \   00000040   1443               ORRS     R4,R4,R2
   \   00000042   1C43               ORRS     R4,R4,R3
   \   00000044   8481               STRH     R4,[R0, #+12]
    755              }
    756            }
    757          }
   \                     ??TIM_ForcedOCConfig_2:
   \   00000046   10BC               POP      {R4}
   \   00000048   01BC               POP      {R0}
   \   0000004A   0047               BX       R0               ;; return
   \                     ??TIM_ForcedOCConfig_1:
   \   0000004C   313F0000           DC32     0x3f31
   \   00000050   3F310000           DC32     0x313f
   \   00000054   31310000           DC32     0x3131
    758          
    759          /*******************************************************************************
    760          * Function Name  : TIM_ResetCounter
    761          * Description    : Re-intializes the TIM counter and generates an update of the
    762          *                  registers.
    763          * Input          : TIMx: where x can be 0, 1 or 2 to select the TIM peripheral
    764          * Output         : None
    765          * Return         : None
    766          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    767          void TIM_ResetCounter(TIM_TypeDef* TIMx)
    768          {
    769            /* Re-intialize the TIM counter */
    770            TIMx->CR |= TIM_COUNTER_Reset;
   \                     TIM_ResetCounter:
   \   00000000   0188               LDRH     R1,[R0, #+0]
   \   00000002   0222               MOVS     R2,#+2
   \   00000004   0A43               ORRS     R2,R2,R1
   \   00000006   0280               STRH     R2,[R0, #+0]
    771          }
   \   00000008   7047               BX       LR               ;; return
    772          
    773          /*******************************************************************************
    774          * Function Name  : TIM_SynchroConfig
    775          * Description    : Synchronizes two Timers in a specified mode.
    776          * Input          : - Master: specifies the peripheral master.
    777          *                    This parameter can be one of the following values:
    778          *                    PWM_Master, TIM0_Master, TIM1_Master or TIM2_Master.
    779          *                  - Slave: specifies the peripheral slave.
    780          *                    This parameter can be one of the following values:
    781          *                    PWM_Slave, TIM0_Slave, TIM1_Slave or TIM2_Slave.
    782          *                  - TIM_SynchroAction: specifies the synchronization Action to 
    783          *                    be used.
    784          *                    This parameter can be one of the following values:
    785          *                         - TIM_SynchroAction_Enable: The CNT_EN bit is used as TRGO
    786          *                         - TIM_SynchroAction_Update: The Update event is used as TRGO
    787          *                         - TIM_SynchroAction_Reset: The CNT_RST bit is used as TRGO
    788          *                         - TIM_SynchroAction_OC: The OC1 signal is used as TRGO
    789          *                  - TIM_SynchroMode: specifies the synchronization Mode to be used.
    790          *                    This parameter can be one of the following values:
    791          *                         - TIM_SynchroMode_Gated: Both start and stop of the 
    792          *                           counter is controlled.
    793          *                         - TIM_SynchroMode_Trigger: Only the start of the 
    794          *                           counter is controlled.
    795          *                         - TIM_SynchroMode_External: The rising edge of selected trigger 
    796          *                           clocks the counter.
    797          *                         - TIM_SynchroMode_Reset: The rising edge of the selected trigger 
    798          *                           signal resets the counter and generates an update of the registers.
    799          * Output         : None
    800          * Return         : None
    801          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    802          void TIM_SynchroConfig(Master_TypeDef Master, Slave_TypeDef Slave,
    803                                 u16 TIM_SynchroAction, u16 TIM_SynchroMode)
    804          {
   \                     TIM_SynchroConfig:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
    805            switch (Slave)
   \   00000002   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000004   090E               LSRS     R1,R1,#+24
   \   00000006   0C00               MOVS     R4,R1
   \   00000008   641F               SUBS     R4,R4,#+5
   \   0000000A   08D0               BEQ      ??TIM_SynchroConfig_0
   \   0000000C   641E               SUBS     R4,R4,#+1
   \   0000000E   59D0               BEQ      ??TIM_SynchroConfig_1
   \   00000010   641E               SUBS     R4,R4,#+1
   \   00000012   00D1               BNE      .+4
   \   00000014   A9E0               B        ??TIM_SynchroConfig_2
   \   00000016   641E               SUBS     R4,R4,#+1
   \   00000018   00D1               BNE      .+4
   \   0000001A   F8E0               B        ??TIM_SynchroConfig_3
   \   0000001C   48E1               B        ??TIM_SynchroConfig_4
    806            {
    807              case PWM_Slave:
    808              {
    809                PWM->SCR &= TIM_SME_Reset & TIM_TriggerSelection_Mask & TIM_SlaveModeSelection_Mask &
    810                            TIM_InternalTriggerSelection_Mask;
   \                     ??TIM_SynchroConfig_0:
   \   0000001E   A64C               LDR      R4,??TIM_SynchroConfig_5  ;; 0xffff9804
   \   00000020   2488               LDRH     R4,[R4, #+0]
   \   00000022   A407               LSLS     R4,R4,#+30       ;; ZeroExtS R4,R4,#+30,#+30
   \   00000024   A40F               LSRS     R4,R4,#+30
   \   00000026   A44D               LDR      R5,??TIM_SynchroConfig_5  ;; 0xffff9804
   \   00000028   2C80               STRH     R4,[R5, #+0]
    811                PWM->SCR |= TIM_SynchroMode | TIM_SME_Set;
   \   0000002A   A34C               LDR      R4,??TIM_SynchroConfig_5  ;; 0xffff9804
   \   0000002C   2488               LDRH     R4,[R4, #+0]
   \   0000002E   0425               MOVS     R5,#+4
   \   00000030   1D43               ORRS     R5,R5,R3
   \   00000032   2543               ORRS     R5,R5,R4
   \   00000034   A04C               LDR      R4,??TIM_SynchroConfig_5  ;; 0xffff9804
   \   00000036   2580               STRH     R5,[R4, #+0]
    812          
    813                if(Master == TIM1_Master)
   \   00000038   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000003A   000E               LSRS     R0,R0,#+24
   \   0000003C   0328               CMP      R0,#+3
   \   0000003E   12D1               BNE      ??TIM_SynchroConfig_6
    814                {
    815                  /* Set the internal trigger */
    816                	PWM->SCR |= TIM_ITS_TIM1;
   \   00000040   9D4C               LDR      R4,??TIM_SynchroConfig_5  ;; 0xffff9804
   \   00000042   2488               LDRH     R4,[R4, #+0]
   \   00000044   8025               MOVS     R5,#+128
   \   00000046   AD01               LSLS     R5,R5,#+6        ;; #+8192
   \   00000048   2543               ORRS     R5,R5,R4
   \   0000004A   9B4C               LDR      R4,??TIM_SynchroConfig_5  ;; 0xffff9804
   \   0000004C   2580               STRH     R5,[R4, #+0]
    817          
    818                  /* Set the synchronization action */
    819                  TIM1->CR &= TIM_MasterModeSelection_Mask;
   \   0000004E   9B4C               LDR      R4,??TIM_SynchroConfig_5+0x4  ;; 0xffff9000
   \   00000050   2488               LDRH     R4,[R4, #+0]
   \   00000052   9B4D               LDR      R5,??TIM_SynchroConfig_5+0x8  ;; 0xfc7f
   \   00000054   2540               ANDS     R5,R5,R4
   \   00000056   994C               LDR      R4,??TIM_SynchroConfig_5+0x4  ;; 0xffff9000
   \   00000058   2580               STRH     R5,[R4, #+0]
    820                  TIM1->CR |= TIM_SynchroAction;
   \   0000005A   984C               LDR      R4,??TIM_SynchroConfig_5+0x4  ;; 0xffff9000
   \   0000005C   2488               LDRH     R4,[R4, #+0]
   \   0000005E   1443               ORRS     R4,R4,R2
   \   00000060   964D               LDR      R5,??TIM_SynchroConfig_5+0x4  ;; 0xffff9000
   \   00000062   2C80               STRH     R4,[R5, #+0]
   \   00000064   24E1               B        ??TIM_SynchroConfig_4
    821                }
    822          
    823                else if(Master == TIM0_Master)
   \                     ??TIM_SynchroConfig_6:
   \   00000066   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000068   000E               LSRS     R0,R0,#+24
   \   0000006A   0228               CMP      R0,#+2
   \   0000006C   12D1               BNE      ??TIM_SynchroConfig_7
    824                {
    825                  /* Set the internal trigger */
    826                  PWM->SCR |= TIM_ITS_TIM0;
   \   0000006E   924C               LDR      R4,??TIM_SynchroConfig_5  ;; 0xffff9804
   \   00000070   2488               LDRH     R4,[R4, #+0]
   \   00000072   8025               MOVS     R5,#+128
   \   00000074   6D01               LSLS     R5,R5,#+5        ;; #+4096
   \   00000076   2543               ORRS     R5,R5,R4
   \   00000078   8F4C               LDR      R4,??TIM_SynchroConfig_5  ;; 0xffff9804
   \   0000007A   2580               STRH     R5,[R4, #+0]
    827          
    828                  /* Set the synchronization action */
    829                  TIM0->CR &= TIM_MasterModeSelection_Mask;
   \   0000007C   914C               LDR      R4,??TIM_SynchroConfig_5+0xC  ;; 0xffff8c00
   \   0000007E   2488               LDRH     R4,[R4, #+0]
   \   00000080   8F4D               LDR      R5,??TIM_SynchroConfig_5+0x8  ;; 0xfc7f
   \   00000082   2540               ANDS     R5,R5,R4
   \   00000084   8F4C               LDR      R4,??TIM_SynchroConfig_5+0xC  ;; 0xffff8c00
   \   00000086   2580               STRH     R5,[R4, #+0]
    830                  TIM0->CR |= TIM_SynchroAction;
   \   00000088   8E4C               LDR      R4,??TIM_SynchroConfig_5+0xC  ;; 0xffff8c00
   \   0000008A   2488               LDRH     R4,[R4, #+0]
   \   0000008C   1443               ORRS     R4,R4,R2
   \   0000008E   8D4D               LDR      R5,??TIM_SynchroConfig_5+0xC  ;; 0xffff8c00
   \   00000090   2C80               STRH     R4,[R5, #+0]
   \   00000092   0DE1               B        ??TIM_SynchroConfig_4
    831                }
    832          
    833                else if(Master == TIM2_Master)
   \                     ??TIM_SynchroConfig_7:
   \   00000094   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000096   000E               LSRS     R0,R0,#+24
   \   00000098   0428               CMP      R0,#+4
   \   0000009A   00D0               BEQ      .+4
   \   0000009C   08E1               B        ??TIM_SynchroConfig_4
    834                {
    835                  /* Set the internal trigger */
    836                  PWM->SCR |= TIM_ITS_TIM2;
   \   0000009E   864C               LDR      R4,??TIM_SynchroConfig_5  ;; 0xffff9804
   \   000000A0   2488               LDRH     R4,[R4, #+0]
   \   000000A2   C025               MOVS     R5,#+192
   \   000000A4   AD01               LSLS     R5,R5,#+6        ;; #+12288
   \   000000A6   2543               ORRS     R5,R5,R4
   \   000000A8   834C               LDR      R4,??TIM_SynchroConfig_5  ;; 0xffff9804
   \   000000AA   2580               STRH     R5,[R4, #+0]
    837          
    838                  /* Set the synchronization action */
    839                  TIM2->CR &= TIM_MasterModeSelection_Mask;
   \   000000AC   864C               LDR      R4,??TIM_SynchroConfig_5+0x10  ;; 0xffff9400
   \   000000AE   2488               LDRH     R4,[R4, #+0]
   \   000000B0   834D               LDR      R5,??TIM_SynchroConfig_5+0x8  ;; 0xfc7f
   \   000000B2   2540               ANDS     R5,R5,R4
   \   000000B4   844C               LDR      R4,??TIM_SynchroConfig_5+0x10  ;; 0xffff9400
   \   000000B6   2580               STRH     R5,[R4, #+0]
    840                  TIM2->CR |= TIM_SynchroAction;
   \   000000B8   834C               LDR      R4,??TIM_SynchroConfig_5+0x10  ;; 0xffff9400
   \   000000BA   2488               LDRH     R4,[R4, #+0]
   \   000000BC   1443               ORRS     R4,R4,R2
   \   000000BE   824D               LDR      R5,??TIM_SynchroConfig_5+0x10  ;; 0xffff9400
   \   000000C0   2C80               STRH     R4,[R5, #+0]
   \   000000C2   F5E0               B        ??TIM_SynchroConfig_4
    841                }
    842              }
    843              break;
    844          
    845              case TIM0_Slave:
    846              {
    847                TIM0->SCR &= TIM_SME_Reset & TIM_TriggerSelection_Mask & TIM_SlaveModeSelection_Mask &
    848                             TIM_InternalTriggerSelection_Mask;
   \                     ??TIM_SynchroConfig_1:
   \   000000C4   814C               LDR      R4,??TIM_SynchroConfig_5+0x14  ;; 0xffff8c04
   \   000000C6   2488               LDRH     R4,[R4, #+0]
   \   000000C8   A407               LSLS     R4,R4,#+30       ;; ZeroExtS R4,R4,#+30,#+30
   \   000000CA   A40F               LSRS     R4,R4,#+30
   \   000000CC   7F4D               LDR      R5,??TIM_SynchroConfig_5+0x14  ;; 0xffff8c04
   \   000000CE   2C80               STRH     R4,[R5, #+0]
    849                TIM0->SCR |= TIM_SynchroMode | TIM_SME_Set;
   \   000000D0   7E4C               LDR      R4,??TIM_SynchroConfig_5+0x14  ;; 0xffff8c04
   \   000000D2   2488               LDRH     R4,[R4, #+0]
   \   000000D4   0425               MOVS     R5,#+4
   \   000000D6   1D43               ORRS     R5,R5,R3
   \   000000D8   2543               ORRS     R5,R5,R4
   \   000000DA   7C4C               LDR      R4,??TIM_SynchroConfig_5+0x14  ;; 0xffff8c04
   \   000000DC   2580               STRH     R5,[R4, #+0]
    850          
    851                if(Master == PWM_Master)
   \   000000DE   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   000000E0   000E               LSRS     R0,R0,#+24
   \   000000E2   0128               CMP      R0,#+1
   \   000000E4   12D1               BNE      ??TIM_SynchroConfig_8
    852                {
    853                  /* Set the internal trigger */
    854                  TIM0->SCR |= TIM_ITS_PWM;
   \   000000E6   794C               LDR      R4,??TIM_SynchroConfig_5+0x14  ;; 0xffff8c04
   \   000000E8   2488               LDRH     R4,[R4, #+0]
   \   000000EA   8025               MOVS     R5,#+128
   \   000000EC   ED01               LSLS     R5,R5,#+7        ;; #+16384
   \   000000EE   2543               ORRS     R5,R5,R4
   \   000000F0   764C               LDR      R4,??TIM_SynchroConfig_5+0x14  ;; 0xffff8c04
   \   000000F2   2580               STRH     R5,[R4, #+0]
    855          
    856                  /* Set the synchronization action */
    857                  PWM->CR &= TIM_MasterModeSelection_Mask;
   \   000000F4   764C               LDR      R4,??TIM_SynchroConfig_5+0x18  ;; 0xffff9800
   \   000000F6   2488               LDRH     R4,[R4, #+0]
   \   000000F8   714D               LDR      R5,??TIM_SynchroConfig_5+0x8  ;; 0xfc7f
   \   000000FA   2540               ANDS     R5,R5,R4
   \   000000FC   744C               LDR      R4,??TIM_SynchroConfig_5+0x18  ;; 0xffff9800
   \   000000FE   2580               STRH     R5,[R4, #+0]
    858                  PWM->CR |= TIM_SynchroAction;
   \   00000100   734C               LDR      R4,??TIM_SynchroConfig_5+0x18  ;; 0xffff9800
   \   00000102   2488               LDRH     R4,[R4, #+0]
   \   00000104   1443               ORRS     R4,R4,R2
   \   00000106   724D               LDR      R5,??TIM_SynchroConfig_5+0x18  ;; 0xffff9800
   \   00000108   2C80               STRH     R4,[R5, #+0]
   \   0000010A   D1E0               B        ??TIM_SynchroConfig_4
    859                }
    860          
    861                else if(Master == TIM1_Master)
   \                     ??TIM_SynchroConfig_8:
   \   0000010C   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000010E   000E               LSRS     R0,R0,#+24
   \   00000110   0328               CMP      R0,#+3
   \   00000112   12D1               BNE      ??TIM_SynchroConfig_9
    862                {
    863                  /* Set the internal trigger */
    864                  TIM0->SCR |= TIM_ITS_TIM1;
   \   00000114   6D4C               LDR      R4,??TIM_SynchroConfig_5+0x14  ;; 0xffff8c04
   \   00000116   2488               LDRH     R4,[R4, #+0]
   \   00000118   8025               MOVS     R5,#+128
   \   0000011A   AD01               LSLS     R5,R5,#+6        ;; #+8192
   \   0000011C   2543               ORRS     R5,R5,R4
   \   0000011E   6B4C               LDR      R4,??TIM_SynchroConfig_5+0x14  ;; 0xffff8c04
   \   00000120   2580               STRH     R5,[R4, #+0]
    865          
    866                  /* Set the synchronization action */
    867                  TIM1->CR &= TIM_MasterModeSelection_Mask;
   \   00000122   664C               LDR      R4,??TIM_SynchroConfig_5+0x4  ;; 0xffff9000
   \   00000124   2488               LDRH     R4,[R4, #+0]
   \   00000126   664D               LDR      R5,??TIM_SynchroConfig_5+0x8  ;; 0xfc7f
   \   00000128   2540               ANDS     R5,R5,R4
   \   0000012A   644C               LDR      R4,??TIM_SynchroConfig_5+0x4  ;; 0xffff9000
   \   0000012C   2580               STRH     R5,[R4, #+0]
    868                  TIM1->CR |= TIM_SynchroAction;
   \   0000012E   634C               LDR      R4,??TIM_SynchroConfig_5+0x4  ;; 0xffff9000
   \   00000130   2488               LDRH     R4,[R4, #+0]
   \   00000132   1443               ORRS     R4,R4,R2
   \   00000134   614D               LDR      R5,??TIM_SynchroConfig_5+0x4  ;; 0xffff9000
   \   00000136   2C80               STRH     R4,[R5, #+0]
   \   00000138   BAE0               B        ??TIM_SynchroConfig_4
    869                }
    870          
    871                else if(Master == TIM2_Master)
   \                     ??TIM_SynchroConfig_9:
   \   0000013A   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000013C   000E               LSRS     R0,R0,#+24
   \   0000013E   0428               CMP      R0,#+4
   \   00000140   00D0               BEQ      .+4
   \   00000142   B5E0               B        ??TIM_SynchroConfig_4
    872                {
    873                  /* Set the internal trigger */
    874                  TIM0->SCR |= TIM_ITS_TIM2;
   \   00000144   614C               LDR      R4,??TIM_SynchroConfig_5+0x14  ;; 0xffff8c04
   \   00000146   2488               LDRH     R4,[R4, #+0]
   \   00000148   C025               MOVS     R5,#+192
   \   0000014A   AD01               LSLS     R5,R5,#+6        ;; #+12288
   \   0000014C   2543               ORRS     R5,R5,R4
   \   0000014E   5F4C               LDR      R4,??TIM_SynchroConfig_5+0x14  ;; 0xffff8c04
   \   00000150   2580               STRH     R5,[R4, #+0]
    875          
    876                  /* Set the synchronization action */
    877                  TIM2->CR &= TIM_MasterModeSelection_Mask;
   \   00000152   5D4C               LDR      R4,??TIM_SynchroConfig_5+0x10  ;; 0xffff9400
   \   00000154   2488               LDRH     R4,[R4, #+0]
   \   00000156   5A4D               LDR      R5,??TIM_SynchroConfig_5+0x8  ;; 0xfc7f
   \   00000158   2540               ANDS     R5,R5,R4
   \   0000015A   5B4C               LDR      R4,??TIM_SynchroConfig_5+0x10  ;; 0xffff9400
   \   0000015C   2580               STRH     R5,[R4, #+0]
    878                  TIM2->CR |= TIM_SynchroAction;
   \   0000015E   5A4C               LDR      R4,??TIM_SynchroConfig_5+0x10  ;; 0xffff9400
   \   00000160   2488               LDRH     R4,[R4, #+0]
   \   00000162   1443               ORRS     R4,R4,R2
   \   00000164   584D               LDR      R5,??TIM_SynchroConfig_5+0x10  ;; 0xffff9400
   \   00000166   2C80               STRH     R4,[R5, #+0]
   \   00000168   A2E0               B        ??TIM_SynchroConfig_4
    879                }
    880              }
    881              break;
    882          
    883              case TIM1_Slave:
    884              {
    885          
    886                TIM1->SCR &= TIM_SME_Reset & TIM_TriggerSelection_Mask & TIM_SlaveModeSelection_Mask &
    887                             TIM_InternalTriggerSelection_Mask;
   \                     ??TIM_SynchroConfig_2:
   \   0000016A   5A4C               LDR      R4,??TIM_SynchroConfig_5+0x1C  ;; 0xffff9004
   \   0000016C   2488               LDRH     R4,[R4, #+0]
   \   0000016E   A407               LSLS     R4,R4,#+30       ;; ZeroExtS R4,R4,#+30,#+30
   \   00000170   A40F               LSRS     R4,R4,#+30
   \   00000172   584D               LDR      R5,??TIM_SynchroConfig_5+0x1C  ;; 0xffff9004
   \   00000174   2C80               STRH     R4,[R5, #+0]
    888                TIM1->SCR |= TIM_SynchroMode | TIM_SME_Set;
   \   00000176   574C               LDR      R4,??TIM_SynchroConfig_5+0x1C  ;; 0xffff9004
   \   00000178   2488               LDRH     R4,[R4, #+0]
   \   0000017A   0425               MOVS     R5,#+4
   \   0000017C   1D43               ORRS     R5,R5,R3
   \   0000017E   2543               ORRS     R5,R5,R4
   \   00000180   544C               LDR      R4,??TIM_SynchroConfig_5+0x1C  ;; 0xffff9004
   \   00000182   2580               STRH     R5,[R4, #+0]
    889               
    890                if(Master == PWM_Master)
   \   00000184   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000186   000E               LSRS     R0,R0,#+24
   \   00000188   0128               CMP      R0,#+1
   \   0000018A   12D1               BNE      ??TIM_SynchroConfig_10
    891                {
    892                	 /* Set the internal trigger */
    893                	 TIM1->SCR |= TIM_ITS_PWM;
   \   0000018C   514C               LDR      R4,??TIM_SynchroConfig_5+0x1C  ;; 0xffff9004
   \   0000018E   2488               LDRH     R4,[R4, #+0]
   \   00000190   8025               MOVS     R5,#+128
   \   00000192   ED01               LSLS     R5,R5,#+7        ;; #+16384
   \   00000194   2543               ORRS     R5,R5,R4
   \   00000196   4F4C               LDR      R4,??TIM_SynchroConfig_5+0x1C  ;; 0xffff9004
   \   00000198   2580               STRH     R5,[R4, #+0]
    894          
    895                  /* Set the synchronization action */
    896                  PWM->CR &= TIM_MasterModeSelection_Mask;
   \   0000019A   4D4C               LDR      R4,??TIM_SynchroConfig_5+0x18  ;; 0xffff9800
   \   0000019C   2488               LDRH     R4,[R4, #+0]
   \   0000019E   484D               LDR      R5,??TIM_SynchroConfig_5+0x8  ;; 0xfc7f
   \   000001A0   2540               ANDS     R5,R5,R4
   \   000001A2   4B4C               LDR      R4,??TIM_SynchroConfig_5+0x18  ;; 0xffff9800
   \   000001A4   2580               STRH     R5,[R4, #+0]
    897                  PWM->CR |= TIM_SynchroAction;
   \   000001A6   4A4C               LDR      R4,??TIM_SynchroConfig_5+0x18  ;; 0xffff9800
   \   000001A8   2488               LDRH     R4,[R4, #+0]
   \   000001AA   1443               ORRS     R4,R4,R2
   \   000001AC   484D               LDR      R5,??TIM_SynchroConfig_5+0x18  ;; 0xffff9800
   \   000001AE   2C80               STRH     R4,[R5, #+0]
   \   000001B0   7EE0               B        ??TIM_SynchroConfig_4
    898                }
    899                else if(Master == TIM0_Master)
   \                     ??TIM_SynchroConfig_10:
   \   000001B2   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   000001B4   000E               LSRS     R0,R0,#+24
   \   000001B6   0228               CMP      R0,#+2
   \   000001B8   12D1               BNE      ??TIM_SynchroConfig_11
    900                {
    901                  /* Set the internal trigger */
    902                  TIM1->SCR |= TIM_ITS_TIM0;
   \   000001BA   464C               LDR      R4,??TIM_SynchroConfig_5+0x1C  ;; 0xffff9004
   \   000001BC   2488               LDRH     R4,[R4, #+0]
   \   000001BE   8025               MOVS     R5,#+128
   \   000001C0   6D01               LSLS     R5,R5,#+5        ;; #+4096
   \   000001C2   2543               ORRS     R5,R5,R4
   \   000001C4   434C               LDR      R4,??TIM_SynchroConfig_5+0x1C  ;; 0xffff9004
   \   000001C6   2580               STRH     R5,[R4, #+0]
    903          
    904                  /* Set the synchronization action */
    905                  TIM0->CR &= TIM_MasterModeSelection_Mask;
   \   000001C8   3E4C               LDR      R4,??TIM_SynchroConfig_5+0xC  ;; 0xffff8c00
   \   000001CA   2488               LDRH     R4,[R4, #+0]
   \   000001CC   3C4D               LDR      R5,??TIM_SynchroConfig_5+0x8  ;; 0xfc7f
   \   000001CE   2540               ANDS     R5,R5,R4
   \   000001D0   3C4C               LDR      R4,??TIM_SynchroConfig_5+0xC  ;; 0xffff8c00
   \   000001D2   2580               STRH     R5,[R4, #+0]
    906                  TIM0->CR |= TIM_SynchroAction;
   \   000001D4   3B4C               LDR      R4,??TIM_SynchroConfig_5+0xC  ;; 0xffff8c00
   \   000001D6   2488               LDRH     R4,[R4, #+0]
   \   000001D8   1443               ORRS     R4,R4,R2
   \   000001DA   3A4D               LDR      R5,??TIM_SynchroConfig_5+0xC  ;; 0xffff8c00
   \   000001DC   2C80               STRH     R4,[R5, #+0]
   \   000001DE   67E0               B        ??TIM_SynchroConfig_4
    907                }
    908          
    909                else if(Master == TIM2_Master)
   \                     ??TIM_SynchroConfig_11:
   \   000001E0   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   000001E2   000E               LSRS     R0,R0,#+24
   \   000001E4   0428               CMP      R0,#+4
   \   000001E6   63D1               BNE      ??TIM_SynchroConfig_4
    910                {
    911                  /* Set the internal trigger */
    912                  TIM1->SCR |= TIM_ITS_TIM2;
   \   000001E8   3A4C               LDR      R4,??TIM_SynchroConfig_5+0x1C  ;; 0xffff9004
   \   000001EA   2488               LDRH     R4,[R4, #+0]
   \   000001EC   C025               MOVS     R5,#+192
   \   000001EE   AD01               LSLS     R5,R5,#+6        ;; #+12288
   \   000001F0   2543               ORRS     R5,R5,R4
   \   000001F2   384C               LDR      R4,??TIM_SynchroConfig_5+0x1C  ;; 0xffff9004
   \   000001F4   2580               STRH     R5,[R4, #+0]
    913          
    914                  /* Set the synchronization action */
    915                  TIM2->CR &= TIM_MasterModeSelection_Mask;
   \   000001F6   344C               LDR      R4,??TIM_SynchroConfig_5+0x10  ;; 0xffff9400
   \   000001F8   2488               LDRH     R4,[R4, #+0]
   \   000001FA   314D               LDR      R5,??TIM_SynchroConfig_5+0x8  ;; 0xfc7f
   \   000001FC   2540               ANDS     R5,R5,R4
   \   000001FE   324C               LDR      R4,??TIM_SynchroConfig_5+0x10  ;; 0xffff9400
   \   00000200   2580               STRH     R5,[R4, #+0]
    916                  TIM2->CR |= TIM_SynchroAction;
   \   00000202   314C               LDR      R4,??TIM_SynchroConfig_5+0x10  ;; 0xffff9400
   \   00000204   2488               LDRH     R4,[R4, #+0]
   \   00000206   1443               ORRS     R4,R4,R2
   \   00000208   2F4D               LDR      R5,??TIM_SynchroConfig_5+0x10  ;; 0xffff9400
   \   0000020A   2C80               STRH     R4,[R5, #+0]
   \   0000020C   50E0               B        ??TIM_SynchroConfig_4
    917                }
    918              }
    919              break;
    920          
    921              case TIM2_Slave:
    922              {
    923               
    924                TIM2->SCR &= TIM_SME_Reset & TIM_TriggerSelection_Mask & TIM_SlaveModeSelection_Mask &
    925                             TIM_InternalTriggerSelection_Mask;
   \                     ??TIM_SynchroConfig_3:
   \   0000020E   324C               LDR      R4,??TIM_SynchroConfig_5+0x20  ;; 0xffff9404
   \   00000210   2488               LDRH     R4,[R4, #+0]
   \   00000212   A407               LSLS     R4,R4,#+30       ;; ZeroExtS R4,R4,#+30,#+30
   \   00000214   A40F               LSRS     R4,R4,#+30
   \   00000216   304D               LDR      R5,??TIM_SynchroConfig_5+0x20  ;; 0xffff9404
   \   00000218   2C80               STRH     R4,[R5, #+0]
    926                TIM2->SCR |= TIM_SynchroMode | TIM_SME_Set;
   \   0000021A   2F4C               LDR      R4,??TIM_SynchroConfig_5+0x20  ;; 0xffff9404
   \   0000021C   2488               LDRH     R4,[R4, #+0]
   \   0000021E   0425               MOVS     R5,#+4
   \   00000220   1D43               ORRS     R5,R5,R3
   \   00000222   2543               ORRS     R5,R5,R4
   \   00000224   2C4C               LDR      R4,??TIM_SynchroConfig_5+0x20  ;; 0xffff9404
   \   00000226   2580               STRH     R5,[R4, #+0]
    927          
    928                if(Master == PWM_Master)
   \   00000228   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000022A   000E               LSRS     R0,R0,#+24
   \   0000022C   0128               CMP      R0,#+1
   \   0000022E   12D1               BNE      ??TIM_SynchroConfig_12
    929                {
    930                  /* Internal trigger selection */
    931                  TIM2->SCR |= TIM_ITS_PWM;
   \   00000230   294C               LDR      R4,??TIM_SynchroConfig_5+0x20  ;; 0xffff9404
   \   00000232   2488               LDRH     R4,[R4, #+0]
   \   00000234   8025               MOVS     R5,#+128
   \   00000236   ED01               LSLS     R5,R5,#+7        ;; #+16384
   \   00000238   2543               ORRS     R5,R5,R4
   \   0000023A   274C               LDR      R4,??TIM_SynchroConfig_5+0x20  ;; 0xffff9404
   \   0000023C   2580               STRH     R5,[R4, #+0]
    932          
    933                  /* Set the synchronization action */
    934                  PWM->CR &= TIM_MasterModeSelection_Mask;
   \   0000023E   244C               LDR      R4,??TIM_SynchroConfig_5+0x18  ;; 0xffff9800
   \   00000240   2488               LDRH     R4,[R4, #+0]
   \   00000242   1F4D               LDR      R5,??TIM_SynchroConfig_5+0x8  ;; 0xfc7f
   \   00000244   2540               ANDS     R5,R5,R4
   \   00000246   224C               LDR      R4,??TIM_SynchroConfig_5+0x18  ;; 0xffff9800
   \   00000248   2580               STRH     R5,[R4, #+0]
    935                  PWM->CR |= TIM_SynchroAction;
   \   0000024A   214C               LDR      R4,??TIM_SynchroConfig_5+0x18  ;; 0xffff9800
   \   0000024C   2488               LDRH     R4,[R4, #+0]
   \   0000024E   1443               ORRS     R4,R4,R2
   \   00000250   1F4D               LDR      R5,??TIM_SynchroConfig_5+0x18  ;; 0xffff9800
   \   00000252   2C80               STRH     R4,[R5, #+0]
   \   00000254   2CE0               B        ??TIM_SynchroConfig_4
    936                }
    937          
    938                else if(Master == TIM1_Master)
   \                     ??TIM_SynchroConfig_12:
   \   00000256   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000258   000E               LSRS     R0,R0,#+24
   \   0000025A   0328               CMP      R0,#+3
   \   0000025C   12D1               BNE      ??TIM_SynchroConfig_13
    939                {
    940                  /* Internal trigger selection */
    941                  TIM2->SCR |= TIM_ITS_TIM1;
   \   0000025E   1E4C               LDR      R4,??TIM_SynchroConfig_5+0x20  ;; 0xffff9404
   \   00000260   2488               LDRH     R4,[R4, #+0]
   \   00000262   8025               MOVS     R5,#+128
   \   00000264   AD01               LSLS     R5,R5,#+6        ;; #+8192
   \   00000266   2543               ORRS     R5,R5,R4
   \   00000268   1B4C               LDR      R4,??TIM_SynchroConfig_5+0x20  ;; 0xffff9404
   \   0000026A   2580               STRH     R5,[R4, #+0]
    942          
    943                  /* Set the synchronization action */
    944                  TIM1->CR &= TIM_MasterModeSelection_Mask;
   \   0000026C   134C               LDR      R4,??TIM_SynchroConfig_5+0x4  ;; 0xffff9000
   \   0000026E   2488               LDRH     R4,[R4, #+0]
   \   00000270   134D               LDR      R5,??TIM_SynchroConfig_5+0x8  ;; 0xfc7f
   \   00000272   2540               ANDS     R5,R5,R4
   \   00000274   114C               LDR      R4,??TIM_SynchroConfig_5+0x4  ;; 0xffff9000
   \   00000276   2580               STRH     R5,[R4, #+0]
    945                  TIM1->CR |= TIM_SynchroAction;
   \   00000278   104C               LDR      R4,??TIM_SynchroConfig_5+0x4  ;; 0xffff9000
   \   0000027A   2488               LDRH     R4,[R4, #+0]
   \   0000027C   1443               ORRS     R4,R4,R2
   \   0000027E   0F4D               LDR      R5,??TIM_SynchroConfig_5+0x4  ;; 0xffff9000
   \   00000280   2C80               STRH     R4,[R5, #+0]
   \   00000282   15E0               B        ??TIM_SynchroConfig_4
    946                }
    947          
    948                else if(Master == TIM0_Master)
   \                     ??TIM_SynchroConfig_13:
   \   00000284   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000286   000E               LSRS     R0,R0,#+24
   \   00000288   0228               CMP      R0,#+2
   \   0000028A   11D1               BNE      ??TIM_SynchroConfig_4
    949                {
    950                  /* Internal trigger selection */
    951                  TIM2->SCR |= TIM_ITS_TIM0;
   \   0000028C   124C               LDR      R4,??TIM_SynchroConfig_5+0x20  ;; 0xffff9404
   \   0000028E   2488               LDRH     R4,[R4, #+0]
   \   00000290   8025               MOVS     R5,#+128
   \   00000292   6D01               LSLS     R5,R5,#+5        ;; #+4096
   \   00000294   2543               ORRS     R5,R5,R4
   \   00000296   104C               LDR      R4,??TIM_SynchroConfig_5+0x20  ;; 0xffff9404
   \   00000298   2580               STRH     R5,[R4, #+0]
    952          
    953                  /* Set the synchronization action */
    954                  TIM0->CR &= TIM_MasterModeSelection_Mask;
   \   0000029A   0A4C               LDR      R4,??TIM_SynchroConfig_5+0xC  ;; 0xffff8c00
   \   0000029C   2488               LDRH     R4,[R4, #+0]
   \   0000029E   084D               LDR      R5,??TIM_SynchroConfig_5+0x8  ;; 0xfc7f
   \   000002A0   2540               ANDS     R5,R5,R4
   \   000002A2   084C               LDR      R4,??TIM_SynchroConfig_5+0xC  ;; 0xffff8c00
   \   000002A4   2580               STRH     R5,[R4, #+0]
    955                  TIM0->CR |= TIM_SynchroAction;
   \   000002A6   074C               LDR      R4,??TIM_SynchroConfig_5+0xC  ;; 0xffff8c00
   \   000002A8   2488               LDRH     R4,[R4, #+0]
   \   000002AA   1443               ORRS     R4,R4,R2
   \   000002AC   054D               LDR      R5,??TIM_SynchroConfig_5+0xC  ;; 0xffff8c00
   \   000002AE   2C80               STRH     R4,[R5, #+0]
    956                }
    957              }
    958              break;
    959          
    960              default:
    961              break;
    962            }
    963          }
   \                     ??TIM_SynchroConfig_4:
   \   000002B0   38BC               POP      {R3-R5}
   \   000002B2   01BC               POP      {R0}
   \   000002B4   0047               BX       R0               ;; return
   \   000002B6   C046               Nop      
   \                     ??TIM_SynchroConfig_5:
   \   000002B8   0498FFFF           DC32     0xffff9804
   \   000002BC   0090FFFF           DC32     0xffff9000
   \   000002C0   7FFC0000           DC32     0xfc7f
   \   000002C4   008CFFFF           DC32     0xffff8c00
   \   000002C8   0094FFFF           DC32     0xffff9400
   \   000002CC   048CFFFF           DC32     0xffff8c04
   \   000002D0   0098FFFF           DC32     0xffff9800
   \   000002D4   0490FFFF           DC32     0xffff9004
   \   000002D8   0494FFFF           DC32     0xffff9404
    964          
    965          /*******************************************************************************
    966          * Function Name  : TIM_GetFlagStatus
    967          * Description    : Checks whether the specified TIM flag is set or not.
    968          * Input          : - TIMx: where x can be 0, 1 or 2 to select the TIM peripheral.
    969          *                  - TIM_FLAG: specifies the flag to check. 
    970          *                    This parameter can be one of the following values:
    971          *                         - TIM_FLAG_IC1: Input Capture 1 Flag
    972          *                         - TIM_FLAG_OC1: Output Compare 1 Flag
    973          *                         - TIM_FLAG_Update: Timer update Flag
    974          *                         - TIM_FLAG_IC2: Input Capture 2 Flag
    975          *                         - TIM_FLAG_OC2: Output Compare 2 Flag
    976          * Output         : None
    977          * Return         : The new state of TIM_FLAG (SET or RESET).
    978          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    979          FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, u16 TIM_FLAG)
    980          {
   \                     TIM_GetFlagStatus:
   \   00000000   0200               MOVS     R2,R0
    981            if((TIMx->ISR & TIM_FLAG) != RESET )
   \   00000002   138C               LDRH     R3,[R2, #+32]
   \   00000004   0B40               ANDS     R3,R3,R1
   \   00000006   1800               MOVS     R0,R3
   \   00000008   0004               LSLS     R0,R0,#+16       ;; ZeroExtS R0,R0,#+16,#+16
   \   0000000A   000C               LSRS     R0,R0,#+16
   \   0000000C   401E               SUBS     R0,R0,#+1
   \   0000000E   8041               SBCS     R0,R0,R0
   \   00000010   C043               MVNS     R0,R0
   \   00000012   C00F               LSRS     R0,R0,#+31
   \   00000014   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000016   000E               LSRS     R0,R0,#+24
    982            {
    983              return SET;
    984            }
    985            else
    986            {
    987              return RESET;
   \   00000018   7047               BX       LR               ;; return
    988            }
    989          }
    990          
    991          /*******************************************************************************
    992          * Function Name  : TIM_ClearFlag
    993          * Description    : Clears the TIMx's pending flags.
    994          * Input          : - TIMx: where x can be 0, 1 or 2 to select the TIM peripheral.
    995          *                  - TIM_FLAG: specifies the flag bit to clear.
    996          *                    This parameter can be any combination of the following values:
    997          *                         - TIM_FLAG_IC1: Timer Input Capture 1 flag
    998          *                         - TIM_FLAG_OC1: Timer Output Compare 1 flag
    999          *                         - TIM_FLAG_Update: Timer update flag
   1000          *                         - TIM_FLAG_IC2: Timer Input Capture 2 flag
   1001          *                         - TIM_FLAG_OC2: Timer Output Compare 2 flag
   1002          * Output         : None
   1003          * Return         : None
   1004          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1005          void TIM_ClearFlag(TIM_TypeDef* TIMx, u16 TIM_FLAG)
   1006          {
   1007            /* Clear the flags */
   1008            TIMx->ISR &= ~TIM_FLAG;
   \                     TIM_ClearFlag:
   \   00000000   028C               LDRH     R2,[R0, #+32]
   \   00000002   8A43               BICS     R2,R2,R1
   \   00000004   0284               STRH     R2,[R0, #+32]
   1009          }
   \   00000006   7047               BX       LR               ;; return
   1010          
   1011          /*******************************************************************************
   1012          * Function Name  : TIM_GetITStatus
   1013          * Description    : Checks whether the specified TIM interrupt has occurred or not.
   1014          * Input          : - TIMx: where x can be 0, 1 or 2 to select the TIM peripheral.
   1015          *                  - TIM_IT: specifies the TIM interrupt source to check.
   1016          *                    This parameter can be one of the following values:
   1017          *                         - TIM_IT_IC1: Input Capture 1 interrupt
   1018          *                         - TIM_IT_OC1: Output Compare 1 interrupt
   1019          *                         - TIM_IT_Update: Timer update interrupt
   1020          *                         - TIM_IT_GlobalUpdate: Timer global update interrupt
   1021          *                         - TIM_IT_IC2: Input Capture 2 interrupt
   1022          *                         - TIM_IT_OC2: Output Compare 2 interrupt
   1023          * Output         : None
   1024          * Return         : The new state of TIM_IT(SET or RESET).
   1025          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1026          ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, u16 TIM_IT)
   1027          {
   \                     TIM_GetITStatus:
   \   00000000   11B4               PUSH     {R0,R4}
   \   00000002   0200               MOVS     R2,R0
   1028            u16 TIM_IT_Check = 0;
   \   00000004   0020               MOVS     R0,#+0
   \   00000006   0300               MOVS     R3,R0
   1029          
   1030            /* Calculates the pending bits to be checked */
   1031            TIM_IT_Check = TIM_IT & TIM_IT_Clear_Mask;
   \   00000008   4804               LSLS     R0,R1,#+17       ;; ZeroExtS R0,R1,#+17,#+17
   \   0000000A   400C               LSRS     R0,R0,#+17
   \   0000000C   0300               MOVS     R3,R0
   1032            
   1033            if((TIMx->ISR & TIM_IT_Check) != RESET )
   \   0000000E   148C               LDRH     R4,[R2, #+32]
   \   00000010   1C40               ANDS     R4,R4,R3
   \   00000012   2000               MOVS     R0,R4
   \   00000014   0004               LSLS     R0,R0,#+16       ;; ZeroExtS R0,R0,#+16,#+16
   \   00000016   000C               LSRS     R0,R0,#+16
   \   00000018   401E               SUBS     R0,R0,#+1
   \   0000001A   8041               SBCS     R0,R0,R0
   \   0000001C   C043               MVNS     R0,R0
   \   0000001E   C00F               LSRS     R0,R0,#+31
   \   00000020   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000022   000E               LSRS     R0,R0,#+24
   1034            {
   1035              return SET;
   1036            }
   1037            else
   1038            {
   1039              return RESET;
   \   00000024   18BC               POP      {R3,R4}
   \   00000026   7047               BX       LR               ;; return
   1040            }
   1041          }
   1042          
   1043          /*******************************************************************************
   1044          * Function Name  : TIM_ClearITPendingBit
   1045          * Description    : Clears the TIM's interrupt pending bits.
   1046          * Input          : - TIMx: where x can be 0, 1 or 2 to select the TIM peripheral.
   1047          *                  - TIM_IT: specifies the interrupt pending bit to clear.
   1048          *                    This parameter can be one of the following values:
   1049          *                         - TIM_IT_IC1: Input Capture 1 Interrupt 
   1050          *                         - TIM_IT_OC1: Output Compare 1 Interrupt 
   1051          *                         - TIM_IT_Update: Timer update Interrupt 
   1052          *                         - TIM_IT_GlobalUpdate: Timer global update Interrupt 
   1053          *                         - TIM_IT_IC2: Input Capture 2 Interrupt 
   1054          *                         - TIM_IT_OC2: Output Compare 2 Interrupt 
   1055          * Output         : None
   1056          * Return         : None
   1057          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1058          void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, u16 TIM_IT)
   1059          {
   1060            u16 TIM_IT_Clear = 0;
   \                     TIM_ClearITPendingBit:
   \   00000000   0023               MOVS     R3,#+0
   \   00000002   1A00               MOVS     R2,R3
   1061          
   1062            /* Calculate the pending bits to be cleared */
   1063            TIM_IT_Clear = TIM_IT & TIM_IT_Clear_Mask;
   \   00000004   4B04               LSLS     R3,R1,#+17       ;; ZeroExtS R3,R1,#+17,#+17
   \   00000006   5B0C               LSRS     R3,R3,#+17
   \   00000008   1A00               MOVS     R2,R3
   1064          
   1065            /* Clear the pending bits */
   1066            TIMx->ISR &= ~TIM_IT_Clear;
   \   0000000A   038C               LDRH     R3,[R0, #+32]
   \   0000000C   9343               BICS     R3,R3,R2
   \   0000000E   0384               STRH     R3,[R0, #+32]
   1067          }
   \   00000010   7047               BX       LR               ;; return
   1068          
   1069          /*******************************************************************************
   1070          * Function Name  : OCM_ModuleConfig
   1071          * Description    : Output Compare Module configuration
   1072          * Input          : - TIMx: where x can be 0, 1 or 2 to select the TIM peripheral
   1073          *                  - TIM_InitStruct: pointer to a TIM_InitTypeDef structure that
   1074          *                  contains the configuration information for the specified TIM
   1075          *                  peripheral.
   1076          * Output         : None
   1077          * Return         : None
   1078          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1079          static void OCM_ModuleConfig(TIM_TypeDef* TIMx, TIM_InitTypeDef* TIM_InitStruct)
   1080          {
   \                     OCM_ModuleConfig:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   1081            u16 TIM_OCControl = 0x0000;
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   1A00               MOVS     R2,R3
   1082          
   1083            if(TIM_InitStruct->TIM_Mode == TIM_Mode_OCTiming)
   \   00000006   0B88               LDRH     R3,[R1, #+0]
   \   00000008   012B               CMP      R3,#+1
   \   0000000A   02D1               BNE      ??OCM_ModuleConfig_0
   1084            {
   1085              TIM_OCControl = TIM_OCControl_OCTiming;
   \   0000000C   0023               MOVS     R3,#+0
   \   0000000E   1A00               MOVS     R2,R3
   \   00000010   19E0               B        ??OCM_ModuleConfig_1
   1086            }
   1087            else
   1088            {
   1089              if((TIM_InitStruct->TIM_Mode == TIM_Mode_OCActive) || 
   1090                 (TIM_InitStruct->TIM_Mode == TIM_Mode_OPM_Active))
   \                     ??OCM_ModuleConfig_0:
   \   00000012   0B88               LDRH     R3,[R1, #+0]
   \   00000014   022B               CMP      R3,#+2
   \   00000016   02D0               BEQ      ??OCM_ModuleConfig_2
   \   00000018   0B88               LDRH     R3,[R1, #+0]
   \   0000001A   0D2B               CMP      R3,#+13
   \   0000001C   02D1               BNE      ??OCM_ModuleConfig_3
   1091              {
   1092                TIM_OCControl = TIM_OCControl_OCActive;
   \                     ??OCM_ModuleConfig_2:
   \   0000001E   0223               MOVS     R3,#+2
   \   00000020   1A00               MOVS     R2,R3
   \   00000022   10E0               B        ??OCM_ModuleConfig_1
   1093              }
   1094              else
   1095              {
   1096                if(TIM_InitStruct->TIM_Mode == TIM_Mode_OCInactive)
   \                     ??OCM_ModuleConfig_3:
   \   00000024   0B88               LDRH     R3,[R1, #+0]
   \   00000026   032B               CMP      R3,#+3
   \   00000028   02D1               BNE      ??OCM_ModuleConfig_4
   1097                {
   1098                  TIM_OCControl = TIM_OCControl_OCInactive;
   \   0000002A   0423               MOVS     R3,#+4
   \   0000002C   1A00               MOVS     R2,R3
   \   0000002E   0AE0               B        ??OCM_ModuleConfig_1
   1099                }
   1100                else
   1101                {
   1102                	 if((TIM_InitStruct->TIM_Mode == TIM_Mode_OCToggle) ||
   1103                      (TIM_InitStruct->TIM_Mode == TIM_Mode_OPM_Toggle))
   \                     ??OCM_ModuleConfig_4:
   \   00000030   0B88               LDRH     R3,[R1, #+0]
   \   00000032   042B               CMP      R3,#+4
   \   00000034   02D0               BEQ      ??OCM_ModuleConfig_5
   \   00000036   0B88               LDRH     R3,[R1, #+0]
   \   00000038   0C2B               CMP      R3,#+12
   \   0000003A   02D1               BNE      ??OCM_ModuleConfig_6
   1104                  {
   1105                    TIM_OCControl = TIM_OCControl_OCToggle;
   \                     ??OCM_ModuleConfig_5:
   \   0000003C   0623               MOVS     R3,#+6
   \   0000003E   1A00               MOVS     R2,R3
   \   00000040   01E0               B        ??OCM_ModuleConfig_1
   1106                  }
   1107                  else
   1108                  {
   1109                    TIM_OCControl = TIM_OCControl_PWM;
   \                     ??OCM_ModuleConfig_6:
   \   00000042   0C23               MOVS     R3,#+12
   \   00000044   1A00               MOVS     R2,R3
   1110          
   1111                  }
   1112                }
   1113              }
   1114            }
   1115          
   1116            if(TIM_InitStruct->TIM_Channel == TIM_Channel_1)
   \                     ??OCM_ModuleConfig_1:
   \   00000046   8B89               LDRH     R3,[R1, #+12]
   \   00000048   012B               CMP      R3,#+1
   \   0000004A   1BD1               BNE      ??OCM_ModuleConfig_7
   1117            {
   1118              /* Configure Channel 1 on Output Compare mode */
   1119              TIMx->OMR1 &= TIM_OC1C_Mask;
   \   0000004C   8389               LDRH     R3,[R0, #+12]
   \   0000004E   344C               LDR      R4,??OCM_ModuleConfig_8  ;; 0x3f31
   \   00000050   1C40               ANDS     R4,R4,R3
   \   00000052   8481               STRH     R4,[R0, #+12]
   1120              TIMx->OMR1 |= TIM_OCControl|TIM_OC1_Enable;
   \   00000054   8389               LDRH     R3,[R0, #+12]
   \   00000056   1024               MOVS     R4,#+16
   \   00000058   1443               ORRS     R4,R4,R2
   \   0000005A   1C43               ORRS     R4,R4,R3
   \   0000005C   8481               STRH     R4,[R0, #+12]
   1121              TIMx->OMR1 |= TIM_PLD1_Set;
   \   0000005E   8389               LDRH     R3,[R0, #+12]
   \   00000060   0124               MOVS     R4,#+1
   \   00000062   1C43               ORRS     R4,R4,R3
   \   00000064   8481               STRH     R4,[R0, #+12]
   1122              TIMx->OCR1 = TIM_InitStruct->TIM_Pulse1;
   \   00000066   CB89               LDRH     R3,[R1, #+14]
   \   00000068   8386               STRH     R3,[R0, #+52]
   1123          
   1124              /* Set the OC1 wave polarity */
   1125              if(TIM_InitStruct->TIM_Polarity1 == TIM_Polarity1_Low)
   \   0000006A   8B8A               LDRH     R3,[R1, #+20]
   \   0000006C   022B               CMP      R3,#+2
   \   0000006E   04D1               BNE      ??OCM_ModuleConfig_9
   1126              {
   1127                TIMx->OMR1 |= TIM_OC1P_Set;
   \   00000070   8389               LDRH     R3,[R0, #+12]
   \   00000072   2024               MOVS     R4,#+32
   \   00000074   1C43               ORRS     R4,R4,R3
   \   00000076   8481               STRH     R4,[R0, #+12]
   \   00000078   4FE0               B        ??OCM_ModuleConfig_10
   1128              }
   1129              else
   1130              {
   1131                TIMx->OMR1 &= TIM_OC1P_Reset;
   \                     ??OCM_ModuleConfig_9:
   \   0000007A   8389               LDRH     R3,[R0, #+12]
   \   0000007C   294C               LDR      R4,??OCM_ModuleConfig_8+0x4  ;; 0x3f1f
   \   0000007E   1C40               ANDS     R4,R4,R3
   \   00000080   8481               STRH     R4,[R0, #+12]
   \   00000082   4AE0               B        ??OCM_ModuleConfig_10
   1132              }
   1133            }
   1134            else
   1135            {
   1136              if(TIM_InitStruct->TIM_Channel == TIM_Channel_2)
   \                     ??OCM_ModuleConfig_7:
   \   00000084   8B89               LDRH     R3,[R1, #+12]
   \   00000086   022B               CMP      R3,#+2
   \   00000088   1FD1               BNE      ??OCM_ModuleConfig_11
   1137              {
   1138                /* Configure Channel 2 on Output Compare mode */
   1139                TIMx->OMR1 &= TIM_OC2C_Mask;
   \   0000008A   8389               LDRH     R3,[R0, #+12]
   \   0000008C   264C               LDR      R4,??OCM_ModuleConfig_8+0x8  ;; 0x313f
   \   0000008E   1C40               ANDS     R4,R4,R3
   \   00000090   8481               STRH     R4,[R0, #+12]
   1140                TIMx->OMR1 |= TIM_OCControl<<8|TIM_OC2_Enable;
   \   00000092   8389               LDRH     R3,[R0, #+12]
   \   00000094   1402               LSLS     R4,R2,#+8
   \   00000096   8025               MOVS     R5,#+128
   \   00000098   6D01               LSLS     R5,R5,#+5        ;; #+4096
   \   0000009A   2543               ORRS     R5,R5,R4
   \   0000009C   1D43               ORRS     R5,R5,R3
   \   0000009E   8581               STRH     R5,[R0, #+12]
   1141                TIMx->OMR1 |= TIM_PLD2_Set;
   \   000000A0   8389               LDRH     R3,[R0, #+12]
   \   000000A2   8024               MOVS     R4,#+128
   \   000000A4   6400               LSLS     R4,R4,#+1        ;; #+256
   \   000000A6   1C43               ORRS     R4,R4,R3
   \   000000A8   8481               STRH     R4,[R0, #+12]
   1142                TIMx->OCR2 = TIM_InitStruct->TIM_Pulse2;
   \   000000AA   0B8A               LDRH     R3,[R1, #+16]
   \   000000AC   0387               STRH     R3,[R0, #+56]
   1143          
   1144                /* Set the OCB wave polarity */
   1145                if(TIM_InitStruct->TIM_Polarity2 == TIM_Polarity2_Low)
   \   000000AE   CB8A               LDRH     R3,[R1, #+22]
   \   000000B0   022B               CMP      R3,#+2
   \   000000B2   05D1               BNE      ??OCM_ModuleConfig_12
   1146                {
   1147                  TIMx->OMR1 |= TIM_OC2P_Set;
   \   000000B4   8389               LDRH     R3,[R0, #+12]
   \   000000B6   8024               MOVS     R4,#+128
   \   000000B8   A401               LSLS     R4,R4,#+6        ;; #+8192
   \   000000BA   1C43               ORRS     R4,R4,R3
   \   000000BC   8481               STRH     R4,[R0, #+12]
   \   000000BE   2CE0               B        ??OCM_ModuleConfig_10
   1148                }
   1149                else
   1150                {
   1151                  TIMx->OMR1 &= TIM_OC2P_Reset;
   \                     ??OCM_ModuleConfig_12:
   \   000000C0   8389               LDRH     R3,[R0, #+12]
   \   000000C2   1A4C               LDR      R4,??OCM_ModuleConfig_8+0xC  ;; 0x1f3f
   \   000000C4   1C40               ANDS     R4,R4,R3
   \   000000C6   8481               STRH     R4,[R0, #+12]
   \   000000C8   27E0               B        ??OCM_ModuleConfig_10
   1152                }
   1153              }
   1154               /* Configure Channel 1 and Channel 2 on Output Compare mode */
   1155              else
   1156              {
   1157                TIMx->OMR1 &= TIM_OC1C_Mask & TIM_OC2C_Mask; 
   \                     ??OCM_ModuleConfig_11:
   \   000000CA   8389               LDRH     R3,[R0, #+12]
   \   000000CC   184C               LDR      R4,??OCM_ModuleConfig_8+0x10  ;; 0x3131
   \   000000CE   1C40               ANDS     R4,R4,R3
   \   000000D0   8481               STRH     R4,[R0, #+12]
   1158                TIMx->OMR1 |= TIM_OCControl|(TIM_OCControl<<8)|TIM_OC1_Enable|TIM_OC2_Enable|
   1159                             TIM_PLD1_Set|TIM_PLD2_Set;
   \   000000D2   8389               LDRH     R3,[R0, #+12]
   \   000000D4   1402               LSLS     R4,R2,#+8
   \   000000D6   1443               ORRS     R4,R4,R2
   \   000000D8   164D               LDR      R5,??OCM_ModuleConfig_8+0x14  ;; 0x1111
   \   000000DA   2543               ORRS     R5,R5,R4
   \   000000DC   1D43               ORRS     R5,R5,R3
   \   000000DE   8581               STRH     R5,[R0, #+12]
   1160          
   1161                TIMx->OCR1 = TIM_InitStruct->TIM_Pulse1;
   \   000000E0   CB89               LDRH     R3,[R1, #+14]
   \   000000E2   8386               STRH     R3,[R0, #+52]
   1162                TIMx->OCR2 = TIM_InitStruct->TIM_Pulse2;
   \   000000E4   0B8A               LDRH     R3,[R1, #+16]
   \   000000E6   0387               STRH     R3,[R0, #+56]
   1163          
   1164                /* Set the OC1 wave polarity */
   1165                if(TIM_InitStruct->TIM_Polarity1 == TIM_Polarity1_Low)
   \   000000E8   8B8A               LDRH     R3,[R1, #+20]
   \   000000EA   022B               CMP      R3,#+2
   \   000000EC   04D1               BNE      ??OCM_ModuleConfig_13
   1166                {
   1167                  TIMx->OMR1 |= TIM_OC1P_Set;
   \   000000EE   8389               LDRH     R3,[R0, #+12]
   \   000000F0   2024               MOVS     R4,#+32
   \   000000F2   1C43               ORRS     R4,R4,R3
   \   000000F4   8481               STRH     R4,[R0, #+12]
   \   000000F6   03E0               B        ??OCM_ModuleConfig_14
   1168                }
   1169                else
   1170                {
   1171                  TIMx->OMR1 &= TIM_OC1P_Reset;
   \                     ??OCM_ModuleConfig_13:
   \   000000F8   8389               LDRH     R3,[R0, #+12]
   \   000000FA   0A4C               LDR      R4,??OCM_ModuleConfig_8+0x4  ;; 0x3f1f
   \   000000FC   1C40               ANDS     R4,R4,R3
   \   000000FE   8481               STRH     R4,[R0, #+12]
   1172                }
   1173          
   1174                /* Set the OC2 wave polarity */
   1175                if(TIM_InitStruct->TIM_Polarity2 == TIM_Polarity2_Low)
   \                     ??OCM_ModuleConfig_14:
   \   00000100   CB8A               LDRH     R3,[R1, #+22]
   \   00000102   022B               CMP      R3,#+2
   \   00000104   05D1               BNE      ??OCM_ModuleConfig_15
   1176                {
   1177                  TIMx->OMR1 |= TIM_OC2P_Set;
   \   00000106   8389               LDRH     R3,[R0, #+12]
   \   00000108   8024               MOVS     R4,#+128
   \   0000010A   A401               LSLS     R4,R4,#+6        ;; #+8192
   \   0000010C   1C43               ORRS     R4,R4,R3
   \   0000010E   8481               STRH     R4,[R0, #+12]
   \   00000110   03E0               B        ??OCM_ModuleConfig_10
   1178                }
   1179                else
   1180                {
   1181                  TIMx->OMR1 &= TIM_OC2P_Reset;
   \                     ??OCM_ModuleConfig_15:
   \   00000112   8389               LDRH     R3,[R0, #+12]
   \   00000114   054C               LDR      R4,??OCM_ModuleConfig_8+0xC  ;; 0x1f3f
   \   00000116   1C40               ANDS     R4,R4,R3
   \   00000118   8481               STRH     R4,[R0, #+12]
   1182                }
   1183              }
   1184            }
   1185          }
   \                     ??OCM_ModuleConfig_10:
   \   0000011A   38BC               POP      {R3-R5}
   \   0000011C   01BC               POP      {R0}
   \   0000011E   0047               BX       R0               ;; return
   \                     ??OCM_ModuleConfig_8:
   \   00000120   313F0000           DC32     0x3f31
   \   00000124   1F3F0000           DC32     0x3f1f
   \   00000128   3F310000           DC32     0x313f
   \   0000012C   3F1F0000           DC32     0x1f3f
   \   00000130   31310000           DC32     0x3131
   \   00000134   11110000           DC32     0x1111
   1186          
   1187          /*******************************************************************************
   1188          * Function Name  : ICAP_ModuleConfig
   1189          * Description    : Input Capture Module configuration
   1190          * Input          : - TIMx: where x can be 0, 1 or 2 to select the TIM peripheral
   1191          *                  - TIM_InitStruct: pointer to a TIM_InitTypeDef structure that
   1192          *                  contains the configuration information for the specified TIM
   1193          *                  peripheral.
   1194          * Output         : None
   1195          * Return         : None
   1196          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1197          static void ICAP_ModuleConfig(TIM_TypeDef* TIMx, TIM_InitTypeDef* TIM_InitStruct)
   1198          {
   \                     ICAP_ModuleConfig:
   \   00000000   01B5               PUSH     {R0,LR}
   1199            if(TIM_InitStruct->TIM_Mode == TIM_Mode_PWMI)
   \   00000002   0A88               LDRH     R2,[R1, #+0]
   \   00000004   062A               CMP      R2,#+6
   \   00000006   31D1               BNE      ??ICAP_ModuleConfig_0
   1200            { /* PWM input mode configuration */
   1201              TIMx->SCR |= TIM_TS_IC1_Set|TIM_SMS_RESETCLK_Set|TIM_SME_Set;
   \   00000008   8288               LDRH     R2,[R0, #+4]
   \   0000000A   8123               MOVS     R3,#+129
   \   0000000C   9B00               LSLS     R3,R3,#+2        ;; #+516
   \   0000000E   1343               ORRS     R3,R3,R2
   \   00000010   8380               STRH     R3,[R0, #+4]
   1202          
   1203              /* Channel 1 and channel 2 input selection */
   1204              if(TIM_InitStruct->TIM_PWMI_ICSelection == TIM_PWMI_ICSelection_TI1)
   \   00000012   0A8C               LDRH     R2,[R1, #+32]
   \   00000014   012A               CMP      R2,#+1
   \   00000016   08D1               BNE      ??ICAP_ModuleConfig_1
   1205              {
   1206                TIMx->IMCR &= TIM_IC1S_Reset;
   \   00000018   0289               LDRH     R2,[R0, #+8]
   \   0000001A   3E23               MOVS     R3,#+62
   \   0000001C   1340               ANDS     R3,R3,R2
   \   0000001E   0381               STRH     R3,[R0, #+8]
   1207                TIMx->IMCR |= TIM_IC2S_Set;
   \   00000020   0289               LDRH     R2,[R0, #+8]
   \   00000022   0223               MOVS     R3,#+2
   \   00000024   1343               ORRS     R3,R3,R2
   \   00000026   0381               STRH     R3,[R0, #+8]
   \   00000028   07E0               B        ??ICAP_ModuleConfig_2
   1208              }
   1209              else
   1210              {
   1211                TIMx->IMCR |= TIM_IC1S_Set;
   \                     ??ICAP_ModuleConfig_1:
   \   0000002A   0289               LDRH     R2,[R0, #+8]
   \   0000002C   0123               MOVS     R3,#+1
   \   0000002E   1343               ORRS     R3,R3,R2
   \   00000030   0381               STRH     R3,[R0, #+8]
   1212                TIMx->IMCR &= TIM_IC2S_Reset;
   \   00000032   0289               LDRH     R2,[R0, #+8]
   \   00000034   3D23               MOVS     R3,#+61
   \   00000036   1340               ANDS     R3,R3,R2
   \   00000038   0381               STRH     R3,[R0, #+8]
   1213              }
   1214          
   1215              /* Channel polarity */
   1216              if(TIM_InitStruct->TIM_PWMI_ICPolarity == TIM_PWMI_ICPolarity_Rising)
   \                     ??ICAP_ModuleConfig_2:
   \   0000003A   4A8C               LDRH     R2,[R1, #+34]
   \   0000003C   042A               CMP      R2,#+4
   \   0000003E   08D1               BNE      ??ICAP_ModuleConfig_3
   1217              {
   1218                TIMx->IMCR &= TIM_IC1P_Reset;
   \   00000040   0289               LDRH     R2,[R0, #+8]
   \   00000042   3723               MOVS     R3,#+55
   \   00000044   1340               ANDS     R3,R3,R2
   \   00000046   0381               STRH     R3,[R0, #+8]
   1219                TIMx->IMCR |= TIM_IC2P_Set;
   \   00000048   0289               LDRH     R2,[R0, #+8]
   \   0000004A   2023               MOVS     R3,#+32
   \   0000004C   1343               ORRS     R3,R3,R2
   \   0000004E   0381               STRH     R3,[R0, #+8]
   \   00000050   07E0               B        ??ICAP_ModuleConfig_4
   1220              }
   1221              else
   1222              {
   1223                TIMx->IMCR |= TIM_IC1P_Set;
   \                     ??ICAP_ModuleConfig_3:
   \   00000052   0289               LDRH     R2,[R0, #+8]
   \   00000054   0823               MOVS     R3,#+8
   \   00000056   1343               ORRS     R3,R3,R2
   \   00000058   0381               STRH     R3,[R0, #+8]
   1224                TIMx->IMCR &= TIM_IC2P_Reset;
   \   0000005A   0289               LDRH     R2,[R0, #+8]
   \   0000005C   D206               LSLS     R2,R2,#+27       ;; ZeroExtS R2,R2,#+27,#+27
   \   0000005E   D20E               LSRS     R2,R2,#+27
   \   00000060   0281               STRH     R2,[R0, #+8]
   1225              }
   1226          
   1227              /* Input capture  Enable */
   1228              TIMx->IMCR |= TIM_IC1_Enable |TIM_IC2_Enable;
   \                     ??ICAP_ModuleConfig_4:
   \   00000062   0289               LDRH     R2,[R0, #+8]
   \   00000064   1423               MOVS     R3,#+20
   \   00000066   1343               ORRS     R3,R3,R2
   \   00000068   0381               STRH     R3,[R0, #+8]
   \   0000006A   4DE0               B        ??ICAP_ModuleConfig_5
   1229            }
   1230            else
   1231            {
   1232              if(TIM_InitStruct->TIM_Channel == TIM_Channel_1)
   \                     ??ICAP_ModuleConfig_0:
   \   0000006C   8A89               LDRH     R2,[R1, #+12]
   \   0000006E   012A               CMP      R2,#+1
   \   00000070   25D1               BNE      ??ICAP_ModuleConfig_6
   1233              {
   1234                /* Input Capture 1 mode configuration */
   1235                TIMx->SCR &= TIM_TriggerSelection_Mask & TIM_SlaveModeSelection_Mask;
   \   00000072   8288               LDRH     R2,[R0, #+4]
   \   00000074   264B               LDR      R3,??ICAP_ModuleConfig_7  ;; 0x7007
   \   00000076   1340               ANDS     R3,R3,R2
   \   00000078   8380               STRH     R3,[R0, #+4]
   1236                TIMx->SCR |= TIM_TS_IC1_Set|TIM_SMS_RESETCLK_Set|TIM_SME_Set;
   \   0000007A   8288               LDRH     R2,[R0, #+4]
   \   0000007C   8123               MOVS     R3,#+129
   \   0000007E   9B00               LSLS     R3,R3,#+2        ;; #+516
   \   00000080   1343               ORRS     R3,R3,R2
   \   00000082   8380               STRH     R3,[R0, #+4]
   1237                
   1238                /* Channel 1 input selection */
   1239                if(TIM_InitStruct->TIM_IC1Selection == TIM_IC1Selection_TI1)
   \   00000084   0A8B               LDRH     R2,[R1, #+24]
   \   00000086   012A               CMP      R2,#+1
   \   00000088   04D1               BNE      ??ICAP_ModuleConfig_8
   1240                {
   1241                  TIMx->IMCR &= TIM_IC1S_Reset;
   \   0000008A   0289               LDRH     R2,[R0, #+8]
   \   0000008C   3E23               MOVS     R3,#+62
   \   0000008E   1340               ANDS     R3,R3,R2
   \   00000090   0381               STRH     R3,[R0, #+8]
   \   00000092   03E0               B        ??ICAP_ModuleConfig_9
   1242                }
   1243                else
   1244                {
   1245                  TIMx->IMCR |= TIM_IC1S_Set;
   \                     ??ICAP_ModuleConfig_8:
   \   00000094   0289               LDRH     R2,[R0, #+8]
   \   00000096   0123               MOVS     R3,#+1
   \   00000098   1343               ORRS     R3,R3,R2
   \   0000009A   0381               STRH     R3,[R0, #+8]
   1246                }
   1247                /* Channel 1 polarity */
   1248                if(TIM_InitStruct->TIM_IC1Polarity == TIM_IC1Polarity_Rising)
   \                     ??ICAP_ModuleConfig_9:
   \   0000009C   8A8B               LDRH     R2,[R1, #+28]
   \   0000009E   022A               CMP      R2,#+2
   \   000000A0   04D1               BNE      ??ICAP_ModuleConfig_10
   1249                {
   1250                  TIMx->IMCR &= TIM_IC1P_Reset;
   \   000000A2   0289               LDRH     R2,[R0, #+8]
   \   000000A4   3723               MOVS     R3,#+55
   \   000000A6   1340               ANDS     R3,R3,R2
   \   000000A8   0381               STRH     R3,[R0, #+8]
   \   000000AA   03E0               B        ??ICAP_ModuleConfig_11
   1251                }
   1252                else
   1253                {
   1254                  TIMx->IMCR |= TIM_IC1P_Set;
   \                     ??ICAP_ModuleConfig_10:
   \   000000AC   0289               LDRH     R2,[R0, #+8]
   \   000000AE   0823               MOVS     R3,#+8
   \   000000B0   1343               ORRS     R3,R3,R2
   \   000000B2   0381               STRH     R3,[R0, #+8]
   1255                }
   1256          
   1257                /* Input capture  Enable */
   1258                TIMx->IMCR |= TIM_IC1_Enable;
   \                     ??ICAP_ModuleConfig_11:
   \   000000B4   0289               LDRH     R2,[R0, #+8]
   \   000000B6   0423               MOVS     R3,#+4
   \   000000B8   1343               ORRS     R3,R3,R2
   \   000000BA   0381               STRH     R3,[R0, #+8]
   \   000000BC   24E0               B        ??ICAP_ModuleConfig_5
   1259              }
   1260              else
   1261              {
   1262                /* Input Capture 2 mode configuration */
   1263                TIMx->SCR &= (TIM_TriggerSelection_Mask & TIM_SlaveModeSelection_Mask);
   \                     ??ICAP_ModuleConfig_6:
   \   000000BE   8288               LDRH     R2,[R0, #+4]
   \   000000C0   134B               LDR      R3,??ICAP_ModuleConfig_7  ;; 0x7007
   \   000000C2   1340               ANDS     R3,R3,R2
   \   000000C4   8380               STRH     R3,[R0, #+4]
   1264                TIMx->SCR |= TIM_TS_IC2_Set|TIM_SMS_RESETCLK_Set|TIM_SME_Set;
   \   000000C6   8288               LDRH     R2,[R0, #+4]
   \   000000C8   C123               MOVS     R3,#+193
   \   000000CA   9B00               LSLS     R3,R3,#+2        ;; #+772
   \   000000CC   1343               ORRS     R3,R3,R2
   \   000000CE   8380               STRH     R3,[R0, #+4]
   1265          
   1266                /* Channel 2 input selection */
   1267                if(TIM_InitStruct->TIM_IC2Selection == TIM_IC2Selection_TI2)
   \   000000D0   4A8B               LDRH     R2,[R1, #+26]
   \   000000D2   022A               CMP      R2,#+2
   \   000000D4   04D1               BNE      ??ICAP_ModuleConfig_12
   1268                {
   1269                  TIMx->IMCR &= TIM_IC2S_Reset;
   \   000000D6   0289               LDRH     R2,[R0, #+8]
   \   000000D8   3D23               MOVS     R3,#+61
   \   000000DA   1340               ANDS     R3,R3,R2
   \   000000DC   0381               STRH     R3,[R0, #+8]
   \   000000DE   03E0               B        ??ICAP_ModuleConfig_13
   1270                }
   1271                else
   1272                {
   1273                  TIMx->IMCR |= TIM_IC2S_Set;
   \                     ??ICAP_ModuleConfig_12:
   \   000000E0   0289               LDRH     R2,[R0, #+8]
   \   000000E2   0223               MOVS     R3,#+2
   \   000000E4   1343               ORRS     R3,R3,R2
   \   000000E6   0381               STRH     R3,[R0, #+8]
   1274                }
   1275          
   1276                /* Channel 2 polarity */
   1277                if(TIM_InitStruct->TIM_IC2Polarity == TIM_IC2Polarity_Rising)
   \                     ??ICAP_ModuleConfig_13:
   \   000000E8   CA8B               LDRH     R2,[R1, #+30]
   \   000000EA   022A               CMP      R2,#+2
   \   000000EC   04D1               BNE      ??ICAP_ModuleConfig_14
   1278                {
   1279                  TIMx->IMCR &= TIM_IC2P_Reset;
   \   000000EE   0289               LDRH     R2,[R0, #+8]
   \   000000F0   D206               LSLS     R2,R2,#+27       ;; ZeroExtS R2,R2,#+27,#+27
   \   000000F2   D20E               LSRS     R2,R2,#+27
   \   000000F4   0281               STRH     R2,[R0, #+8]
   \   000000F6   03E0               B        ??ICAP_ModuleConfig_15
   1280                }
   1281                else
   1282                {
   1283                  TIMx->IMCR |= TIM_IC2P_Set;
   \                     ??ICAP_ModuleConfig_14:
   \   000000F8   0289               LDRH     R2,[R0, #+8]
   \   000000FA   2023               MOVS     R3,#+32
   \   000000FC   1343               ORRS     R3,R3,R2
   \   000000FE   0381               STRH     R3,[R0, #+8]
   1284                }
   1285          
   1286                /* Input capture  Enable */
   1287                TIMx->IMCR |= TIM_IC2_Enable;
   \                     ??ICAP_ModuleConfig_15:
   \   00000100   0289               LDRH     R2,[R0, #+8]
   \   00000102   1023               MOVS     R3,#+16
   \   00000104   1343               ORRS     R3,R3,R2
   \   00000106   0381               STRH     R3,[R0, #+8]
   1288              }
   1289            }
   1290          }
   \                     ??ICAP_ModuleConfig_5:
   \   00000108   08BC               POP      {R3}
   \   0000010A   01BC               POP      {R0}
   \   0000010C   0047               BX       R0               ;; return
   \   0000010E   C046               Nop      
   \                     ??ICAP_ModuleConfig_7:
   \   00000110   07700000           DC32     0x7007
   1291          
   1292          /*******************************************************************************
   1293          * Function Name  : Encoder_ModeConfig
   1294          * Description    : Encoder Mode configuration
   1295          * Input          : - TIMx: where x can be 0, 1 or 2 to select the TIM peripheral
   1296          *                  - TIM_InitStruct: pointer to a TIM_InitTypeDef structure that
   1297          *                  contains the configuration information for the specified TIM
   1298          *                  peripheral.
   1299          * Output         : None
   1300          * Return         : None
   1301          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1302          static void Encoder_ModeConfig(TIM_TypeDef* TIMx, TIM_InitTypeDef* TIM_InitStruct)
   1303          {
   \                     Encoder_ModeConfig:
   \   00000000   01B5               PUSH     {R0,LR}
   1304            /* Set Encoder mode */
   1305            TIMx->SCR &= TIM_Encoder_Mask;
   \   00000002   8288               LDRH     R2,[R0, #+4]
   \   00000004   244B               LDR      R3,??Encoder_ModeConfig_0  ;; 0x731c
   \   00000006   1340               ANDS     R3,R3,R2
   \   00000008   8380               STRH     R3,[R0, #+4]
   1306            
   1307            if(TIM_InitStruct->TIM_Mode == TIM_Mode_Encoder1) 
   \   0000000A   0A88               LDRH     R2,[R1, #+0]
   \   0000000C   082A               CMP      R2,#+8
   \   0000000E   04D1               BNE      ??Encoder_ModeConfig_1
   1308            {
   1309              TIMx->SCR |= TIM_Encoder1_Set;
   \   00000010   8288               LDRH     R2,[R0, #+4]
   \   00000012   0123               MOVS     R3,#+1
   \   00000014   1343               ORRS     R3,R3,R2
   \   00000016   8380               STRH     R3,[R0, #+4]
   \   00000018   0BE0               B        ??Encoder_ModeConfig_2
   1310            }
   1311            else if (TIM_InitStruct->TIM_Mode == TIM_Mode_Encoder2)
   \                     ??Encoder_ModeConfig_1:
   \   0000001A   0A88               LDRH     R2,[R1, #+0]
   \   0000001C   092A               CMP      R2,#+9
   \   0000001E   04D1               BNE      ??Encoder_ModeConfig_3
   1312            {
   1313              TIMx->SCR |= TIM_Encoder2_Set;
   \   00000020   8288               LDRH     R2,[R0, #+4]
   \   00000022   0223               MOVS     R3,#+2
   \   00000024   1343               ORRS     R3,R3,R2
   \   00000026   8380               STRH     R3,[R0, #+4]
   \   00000028   03E0               B        ??Encoder_ModeConfig_2
   1314            }
   1315            else 
   1316            {
   1317              TIMx->SCR |= TIM_Encoder3_Set;
   \                     ??Encoder_ModeConfig_3:
   \   0000002A   8288               LDRH     R2,[R0, #+4]
   \   0000002C   0323               MOVS     R3,#+3
   \   0000002E   1343               ORRS     R3,R3,R2
   \   00000030   8380               STRH     R3,[R0, #+4]
   1318            }
   1319          
   1320            /* Channel 1 input selection */
   1321            if(TIM_InitStruct->TIM_IC1Selection == TIM_IC1Selection_TI2)
   \                     ??Encoder_ModeConfig_2:
   \   00000032   0A8B               LDRH     R2,[R1, #+24]
   \   00000034   022A               CMP      R2,#+2
   \   00000036   04D1               BNE      ??Encoder_ModeConfig_4
   1322            {
   1323              TIMx->IMCR |= TIM_IC1S_Set;
   \   00000038   0289               LDRH     R2,[R0, #+8]
   \   0000003A   0123               MOVS     R3,#+1
   \   0000003C   1343               ORRS     R3,R3,R2
   \   0000003E   0381               STRH     R3,[R0, #+8]
   \   00000040   03E0               B        ??Encoder_ModeConfig_5
   1324            }
   1325            else
   1326            {
   1327              TIMx->IMCR &= TIM_IC1S_Reset;
   \                     ??Encoder_ModeConfig_4:
   \   00000042   0289               LDRH     R2,[R0, #+8]
   \   00000044   3E23               MOVS     R3,#+62
   \   00000046   1340               ANDS     R3,R3,R2
   \   00000048   0381               STRH     R3,[R0, #+8]
   1328            }
   1329          
   1330             /* Channel 2 input selection */
   1331             if(TIM_InitStruct->TIM_IC2Selection == TIM_IC2Selection_TI1)
   \                     ??Encoder_ModeConfig_5:
   \   0000004A   4A8B               LDRH     R2,[R1, #+26]
   \   0000004C   012A               CMP      R2,#+1
   \   0000004E   04D1               BNE      ??Encoder_ModeConfig_6
   1332             {
   1333               TIMx->IMCR |= TIM_IC2S_Set;
   \   00000050   0289               LDRH     R2,[R0, #+8]
   \   00000052   0223               MOVS     R3,#+2
   \   00000054   1343               ORRS     R3,R3,R2
   \   00000056   0381               STRH     R3,[R0, #+8]
   \   00000058   03E0               B        ??Encoder_ModeConfig_7
   1334             }
   1335             else
   1336             {
   1337               TIMx->IMCR &= TIM_IC2S_Reset;
   \                     ??Encoder_ModeConfig_6:
   \   0000005A   0289               LDRH     R2,[R0, #+8]
   \   0000005C   3D23               MOVS     R3,#+61
   \   0000005E   1340               ANDS     R3,R3,R2
   \   00000060   0381               STRH     R3,[R0, #+8]
   1338             }
   1339          
   1340             /* Channel 1 polarity */
   1341             if(TIM_InitStruct->TIM_IC1Polarity == TIM_IC1Polarity_Falling)
   \                     ??Encoder_ModeConfig_7:
   \   00000062   8A8B               LDRH     R2,[R1, #+28]
   \   00000064   012A               CMP      R2,#+1
   \   00000066   04D1               BNE      ??Encoder_ModeConfig_8
   1342             {
   1343               TIMx->IMCR |= TIM_IC1P_Set;
   \   00000068   0289               LDRH     R2,[R0, #+8]
   \   0000006A   0823               MOVS     R3,#+8
   \   0000006C   1343               ORRS     R3,R3,R2
   \   0000006E   0381               STRH     R3,[R0, #+8]
   \   00000070   03E0               B        ??Encoder_ModeConfig_9
   1344             }
   1345             else
   1346             {
   1347               TIMx->IMCR &= TIM_IC1P_Reset;
   \                     ??Encoder_ModeConfig_8:
   \   00000072   0289               LDRH     R2,[R0, #+8]
   \   00000074   3723               MOVS     R3,#+55
   \   00000076   1340               ANDS     R3,R3,R2
   \   00000078   0381               STRH     R3,[R0, #+8]
   1348             }
   1349          
   1350             /* Channel 2 polarity */
   1351             if(TIM_InitStruct->TIM_IC2Polarity == TIM_IC2Polarity_Falling)
   \                     ??Encoder_ModeConfig_9:
   \   0000007A   CA8B               LDRH     R2,[R1, #+30]
   \   0000007C   012A               CMP      R2,#+1
   \   0000007E   04D1               BNE      ??Encoder_ModeConfig_10
   1352             {
   1353               TIMx->IMCR |= TIM_IC2P_Set;
   \   00000080   0289               LDRH     R2,[R0, #+8]
   \   00000082   2023               MOVS     R3,#+32
   \   00000084   1343               ORRS     R3,R3,R2
   \   00000086   0381               STRH     R3,[R0, #+8]
   \   00000088   03E0               B        ??Encoder_ModeConfig_11
   1354             }
   1355             else
   1356             {
   1357               TIMx->IMCR &= TIM_IC2P_Reset;
   \                     ??Encoder_ModeConfig_10:
   \   0000008A   0289               LDRH     R2,[R0, #+8]
   \   0000008C   D206               LSLS     R2,R2,#+27       ;; ZeroExtS R2,R2,#+27,#+27
   \   0000008E   D20E               LSRS     R2,R2,#+27
   \   00000090   0281               STRH     R2,[R0, #+8]
   1358             }
   1359          }
   \                     ??Encoder_ModeConfig_11:
   \   00000092   08BC               POP      {R3}
   \   00000094   01BC               POP      {R0}
   \   00000096   0047               BX       R0               ;; return
   \                     ??Encoder_ModeConfig_0:
   \   00000098   1C730000           DC32     0x731c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0090FFFF           DC32     0xffff9000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0094FFFF           DC32     0xffff9400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   8FFF0000           DC32     0xff8f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   FEFF0000           DC32     0xfffe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   008CFFFF           DC32     0xffff8c00
   1360          /******************* (C) COPYRIGHT 2006 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function              .cstack
     --------              -------
     Encoder_ModeConfig         8
     ICAP_ModuleConfig          8
     OCM_ModuleConfig          16
     TIM_ClearFlag              0
     TIM_ClearITPendingBit      0
     TIM_ClockSourceConfig      8
     TIM_Cmd                    8
     TIM_CounterModeConfig      0
     TIM_DMACmd                 8
     TIM_DMAConfig              8
     TIM_DeInit                 8
     TIM_DebugCmd               8
     TIM_ForcedOCConfig         8
     TIM_GetFlagStatus          0
     TIM_GetICAP1               0
     TIM_GetICAP2               0
     TIM_GetITStatus            8
     TIM_GetPWMIPeriod          0
     TIM_GetPWMIPulse           0
     TIM_ITConfig              16
     TIM_Init                  16
     TIM_PreloadConfig          8
     TIM_ResetCounter           0
     TIM_SetPeriod              0
     TIM_SetPrescaler           0
     TIM_SetPulse               8
     TIM_StructInit             0
     TIM_SynchroConfig         16


   Section sizes:

     Function/Label        Bytes
     --------------        -----
     TIM_DeInit              80
     TIM_Init               156
     TIM_StructInit          80
     TIM_Cmd                 40
     TIM_ITConfig            96
     TIM_PreloadConfig      128
     TIM_DMAConfig           88
     TIM_DMACmd              44
     TIM_ClockSourceConfig  204
     TIM_SetPrescaler         4
     TIM_SetPeriod            4
     TIM_SetPulse            44
     TIM_GetICAP1             6
     TIM_GetICAP2             6
     TIM_GetPWMIPulse         6
     TIM_GetPWMIPeriod        6
     TIM_DebugCmd            40
     TIM_CounterModeConfig   20
     TIM_ForcedOCConfig      88
     TIM_ResetCounter        10
     TIM_SynchroConfig      732
     TIM_GetFlagStatus       26
     TIM_ClearFlag            8
     TIM_GetITStatus         40
     TIM_ClearITPendingBit   18
     OCM_ModuleConfig       312
     ICAP_ModuleConfig      276
     Encoder_ModeConfig     156
     ??DataTable1             4
     ??DataTable2             4
     ??DataTable3             4
     ??DataTable5             4
     ??DataTable9             4

 
 2 738 bytes in section .text
 
 2 738 bytes of CODE memory

Errors: none
Warnings: none
