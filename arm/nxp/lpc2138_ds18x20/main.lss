
main.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002270  00000000  00000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  40000000  00002270  00010000  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000188  40000000  40000000  00010000  2**2
                  ALLOC
  3 .stack        00000400  40000200  40000200  00010078  2**0
                  ALLOC
  4 .stab         00002f40  00000000  00000000  00010078  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      00000c00  00000000  00000000  00012fb8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .comment      000000c6  00000000  00000000  00013bb8  2**0
                  CONTENTS, READONLY
  7 .debug_aranges 00000120  00000000  00000000  00013c80  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 0000001d  00000000  00000000  00013da0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   000004d2  00000000  00000000  00013dbd  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00000139  00000000  00000000  0001428f  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00000763  00000000  00000000  000143c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00000028  00000000  00000000  00014b2c  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    000000da  00000000  00000000  00014b54  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    000000fb  00000000  00000000  00014c2e  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <_boot>:

// Runtime Interrupt Vectors
// -------------------------
Vectors:
        b     _start                    // reset - _start
       0:	ea000012 	b	50 <_mainCRTStartup>
        ldr   pc,_undf                  // undefined - _undf
       4:	e59ff014 	ldr	pc, [pc, #20]	; 20 <_undf>
        ldr   pc,_swi                   // SWI - _swi
       8:	e59ff014 	ldr	pc, [pc, #20]	; 24 <_swi>
        ldr   pc,_pabt                  // program abort - _pabt
       c:	e59ff014 	ldr	pc, [pc, #20]	; 28 <_pabt>
        ldr   pc,_dabt                  // data abort - _dabt
      10:	e59ff014 	ldr	pc, [pc, #20]	; 2c <_dabt>
        nop                             // reserved
      14:	e1a00000 	nop			(mov r0,r0)
        ldr   pc,[pc,#-0xFF0]           // IRQ - read the VIC
      18:	e51ffff0 	ldr	pc, [pc, #-4080]	; fffff030 <_end+0xbfffea30>
        ldr   pc,_fiq                   // FIQ - _fiq
      1c:	e59ff010 	ldr	pc, [pc, #16]	; 34 <_fiq>

00000020 <_undf>:
      20:	00000038 	andeq	r0, r0, r8, lsr r0

00000024 <_swi>:
      24:	0000003c 	andeq	r0, r0, ip, lsr r0

00000028 <_pabt>:
      28:	00000040 	andeq	r0, r0, r0, asr #32

0000002c <_dabt>:
      2c:	00000044 	andeq	r0, r0, r4, asr #32

00000030 <_irq>:
      30:	00000048 	andeq	r0, r0, r8, asr #32

00000034 <_fiq>:
      34:	0000004c 	andeq	r0, r0, ip, asr #32

00000038 <__undf>:

#if 0
// Use this group for production
_undf:  .word _reset                    // undefined - _reset
_swi:   .word _reset                    // SWI - _reset
_pabt:  .word _reset                    // program abort - _reset
_dabt:  .word _reset                    // data abort - _reset
_irq:   .word _reset                    // IRQ - _reset
_fiq:   .word _reset                    // FIQ - _reset

#else
// Use this group for development
_undf:  .word __undf                    // undefined
_swi:   .word __swi                     // SWI
_pabt:  .word __pabt                    // program abort
_dabt:  .word __dabt                    // data abort
_irq:   .word __irq                     // IRQ
_fiq:   .word __fiq                     // FIQ

__undf: b     .                         // undefined
      38:	eafffffe 	b	38 <__undf>

0000003c <__swi>:
__swi:  b     .                         // SWI
      3c:	eafffffe 	b	3c <__swi>

00000040 <__pabt>:
__pabt: b     .                         // program abort
      40:	eafffffe 	b	40 <F_BIT>

00000044 <__dabt>:
__dabt: b     .                         // data abort
      44:	eafffffe 	b	44 <__dabt>

00000048 <__irq>:
__irq:  b     .                         // IRQ
      48:	eafffffe 	b	48 <__irq>

0000004c <__fiq>:
__fiq:  b     .                         // FIQ
      4c:	eafffffe 	b	4c <__fiq>

00000050 <_mainCRTStartup>:
#endif
        .size _boot, . - _boot
        .endfunc


// Setup the operating mode & stack.
// ---------------------------------
        .global _start, start, _mainCRTStartup
        .func   _start

_start:
start:
_mainCRTStartup:

// Initialize Interrupt System
// - Set stack location for each mode
// - Leave in System Mode with Interrupts Disabled
// -----------------------------------------------
        ldr   r0,=_stack
      50:	e59f0098 	ldr	r0, [pc, #152]	; f0 <.text+0xf0>
        msr   CPSR_c,#MODE_UND|I_BIT|F_BIT // Undefined Instruction Mode
      54:	e321f0db 	msr	CPSR_c, #219	; 0xdb
        mov   sp,r0
      58:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#UND_STACK_SIZE
      5c:	e2400004 	sub	r0, r0, #4	; 0x4
        msr   CPSR_c,#MODE_ABT|I_BIT|F_BIT // Abort Mode
      60:	e321f0d7 	msr	CPSR_c, #215	; 0xd7
        mov   sp,r0
      64:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#ABT_STACK_SIZE
      68:	e2400004 	sub	r0, r0, #4	; 0x4
        msr   CPSR_c,#MODE_FIQ|I_BIT|F_BIT // FIQ Mode
      6c:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
        mov   sp,r0
      70:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#FIQ_STACK_SIZE
      74:	e2400004 	sub	r0, r0, #4	; 0x4
        msr   CPSR_c,#MODE_IRQ|I_BIT|F_BIT // IRQ Mode
      78:	e321f0d2 	msr	CPSR_c, #210	; 0xd2
        mov   sp,r0
      7c:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#IRQ_STACK_SIZE
      80:	e2400080 	sub	r0, r0, #128	; 0x80
        msr   CPSR_c,#MODE_SVC|I_BIT|F_BIT // Supervisor Mode
      84:	e321f0d3 	msr	CPSR_c, #211	; 0xd3
        mov   sp,r0
      88:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#SVC_STACK_SIZE
      8c:	e2400004 	sub	r0, r0, #4	; 0x4
        msr   CPSR_c,#MODE_SYS|I_BIT|F_BIT // System Mode
      90:	e321f0df 	msr	CPSR_c, #223	; 0xdf
        mov   sp,r0
      94:	e1a0d000 	mov	sp, r0

// Copy initialized data to its execution address in RAM
// -----------------------------------------------------
#ifdef ROM_RUN
        ldr   r1,=_etext                // -> ROM data start
      98:	e59f1054 	ldr	r1, [pc, #84]	; f4 <.text+0xf4>
        ldr   r2,=_data                 // -> data start
      9c:	e59f2054 	ldr	r2, [pc, #84]	; f8 <.text+0xf8>
        ldr   r3,=_edata                // -> end of data
      a0:	e59f3054 	ldr	r3, [pc, #84]	; fc <.text+0xfc>
1:      cmp   r2,r3                     // check if data to move
      a4:	e1520003 	cmp	r2, r3
        ldrlo r0,[r1],#4                // copy it
      a8:	34910004 	ldrcc	r0, [r1], #4
        strlo r0,[r2],#4
      ac:	34820004 	strcc	r0, [r2], #4
        blo   1b                        // loop until done
      b0:	3afffffb 	bcc	a4 <IRQ_STACK_SIZE+0x24>
#endif
// Clear .bss
// ----------
        mov   r0,#0                     // get a zero
      b4:	e3a00000 	mov	r0, #0	; 0x0
        ldr   r1,=__bss_start           // -> bss start
      b8:	e59f1040 	ldr	r1, [pc, #64]	; 100 <.text+0x100>
        ldr   r2,=__bss_end__           // -> bss end
      bc:	e59f2040 	ldr	r2, [pc, #64]	; 104 <.text+0x104>
2:      cmp   r1,r2                     // check if data to clear
      c0:	e1510002 	cmp	r1, r2
        strlo r0,[r1],#4                // clear 4 bytes
      c4:	34810004 	strcc	r0, [r1], #4
        blo   2b                        // loop until done
      c8:	3afffffc 	bcc	c0 <IRQ_STACK_SIZE+0x40>

// Call main program: main(0)
// --------------------------
        mov   r0,#0                     // no arguments (argc = 0)
      cc:	e3a00000 	mov	r0, #0	; 0x0
        mov   r1,r0
      d0:	e1a01000 	mov	r1, r0
        mov   r2,r0
      d4:	e1a02000 	mov	r2, r0
        mov   fp,r0                     // null frame pointer
      d8:	e1a0b000 	mov	fp, r0
        mov   r7,r0                     // null frame pointer for thumb
      dc:	e1a07000 	mov	r7, r0
        ldr   r10,=main
      e0:	e59fa020 	ldr	sl, [pc, #32]	; 108 <.text+0x108>
        mov   lr,pc
      e4:	e1a0e00f 	mov	lr, pc
        bx    r10                       // enter main()
      e8:	e12fff1a 	bx	sl

000000ec <_reset>:
      ec:	eafffffe 	b	ec <_reset>
      f0:	40000600 	andmi	r0, r0, r0, lsl #12
      f4:	00002270 	andeq	r2, r0, r0, ror r2
      f8:	40000000 	andmi	r0, r0, r0
      fc:	40000000 	andmi	r0, r0, r0
     100:	40000000 	andmi	r0, r0, r0
     104:	40000188 	andmi	r0, r0, r8, lsl #3
     108:	0000010c 	andeq	r0, r0, ip, lsl #2

0000010c <main>:
static void lowInit(void)
{
  // set PLL multiplier & divisor.
  // values computed from config.h
  PLLCFG = PLLCFG_MSEL | PLLCFG_PSEL;
     10c:	e59f33f0 	ldr	r3, [pc, #1008]	; 504 <.text+0x504>
     110:	e3a02024 	mov	r2, #36	; 0x24

  // enable PLL
  PLLCON = PLLCON_PLLE;
  PLLFEED = 0xAA;                       // Make it happen.  These two updates
  PLLFEED = 0x55;                       // MUST occur in sequence.

  // setup the parallel port pin
  IOCLR1 = PIO_ZERO_BITS;                // clear the ZEROs output
  IOSET1 = PIO_ONE_BITS;                 // set the ONEs output
  IODIR1 = PIO_OUTPUT_BITS;              // set the output bit direction

  // wait for PLL lock
  while (!(PLLSTAT & PLLSTAT_LOCK))
    continue;

  // enable & connect PLL
  PLLCON = PLLCON_PLLE | PLLCON_PLLC;
  PLLFEED = 0xAA;                       // Make it happen.  These two updates
  PLLFEED = 0x55;                       // MUST occur in sequence.

  // setup & enable the MAM
  MAMTIM = MAMTIM_CYCLES;
  MAMCR = MAMCR_FULL;

  // set the peripheral bus speed
  // value computed from config.h
  VPBDIV = VPBDIV_VALUE;                // set the peripheral bus clock speed
}

/******************************************************************************
 *
 * Function Name: sysInit()
 *
 * Description:
 *    This function is responsible for initializing the program
 *    specific hardware
 *
 * Calling Sequence: 
 *    void
 *
 * Returns:
 *    void
 *
 *****************************************************************************/
static void sysInit(void)
{
  lowInit();                            // setup clocks and processor port pins

  // set the interrupt controller defaults
#if defined(RAM_RUN)
  MEMMAP = MEMMAP_SRAM;                 // map interrupt vectors space into SRAM
#elif defined(ROM_RUN)
  MEMMAP = MEMMAP_FLASH;                // map interrupt vectors space into FLASH
#else
#error RUN_MODE not defined!
#endif
  VICIntEnClr = 0xFFFFFFFF;           		// clear all interrupts
  VICIntSelect = 0x00000000;            	// clear all FIQ selections
  VICDefVectAddr = (uint32_t)reset;     	// point unvectored IRQs to reset()

//  wdtInit();                            	// initialize the watchdog timer
  initSysTime();                        	// initialize the system timer
  uart0Init( UART_BAUD(HOST_BAUD), UART_8N1, UART_FIFO_8 ); // setup the UART
}



#define MAXSENSORS 5

uint8_t gSensorIDs[MAXSENSORS][OW_ROMCODE_SIZE];

static uint8_t search_sensors(void)
{
	uint8_t i;
	uint8_t id[OW_ROMCODE_SIZE];
	uint8_t diff, nSensors;
	
	uart0Puts( "\r\nScanning Bus for DS18X20\r\n" );
	
	nSensors = 0;
	
	for( diff = OW_SEARCH_FIRST; 
		diff != OW_LAST_DEVICE && nSensors < MAXSENSORS ; )
	{
		DS18X20_find_sensor( &diff, &id[0] );
		
		if( diff == OW_PRESENCE_ERR ) {
			uart0Puts( "No Sensor found\r\n" );
			break;
		}
		
		if( diff == OW_DATA_ERR ) {
			uart0Puts( "Bus Error\r\n" );
			break;
		}
		
		for (i=0;i<OW_ROMCODE_SIZE;i++) {
			gSensorIDs[nSensors][i]=id[i];
		}
		
		if ( 237 == gSensorIDs[0][1] ) {
			uart0Puts( "247\r\n" );
		}
		
		if ( 36 == gSensorIDs[0][1] ) {
			uart0Puts( "36\r\n" );
		}
		
		nSensors++;
	}
	
	return nSensors;
}

static void uart_put_temp(const uint8_t subzero, uint8_t cel, 
	uint8_t cel_frac_bits)
{
	// uint8_t buffer[sizeof(int)*8+1];
	// uint8_t i, j;
	
	uint16_t decicelsius;
	
	uart0Putch((subzero)?'-':'+');
	uart0Puts(itoa(cel));
	/*uart0Puts(".");
	itoa((cel_frac_bits*DS18X20_FRACCONV),buffer,10);
	j=4-strlen(buffer);
	for (i=0;i<j;i++) uart0_puts("0");
	uart0Puts(buffer);
	*/
	uart0Puts("°C [");
	// "rounding"
	uart0Putch((subzero)?'-':'+');
	decicelsius = DS18X20_temp_to_decicel(subzero, cel, cel_frac_bits);
	uart0Puts( itoa(decicelsius/10) );
	uart0Puts(".");
	uart0Putch( (decicelsius%10) + '0');
	uart0Puts("°C]");
}



/******************************************************************************
 *
 * Function Name: main()
 *
 * Description:
 *    This function is the program entry point.  After initializing the
 *    system, it sends a greeting out UART0 then enters an endless loop
 *    echoing chracters on the UART and blinking an LED every half
 *    second.
 *
 * Calling Sequence: 
 *    void
 *
 * Returns:
 *    void
 *
 *****************************************************************************/
int main(void)
{
     114:	e92d45f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, lr}
     118:	e59f13e8 	ldr	r1, [pc, #1000]	; 508 <.text+0x508>
     11c:	e5c32000 	strb	r2, [r3]
     120:	e3a02001 	mov	r2, #1	; 0x1
     124:	e2433004 	sub	r3, r3, #4	; 0x4
     128:	e5c32000 	strb	r2, [r3]
     12c:	e3e03055 	mvn	r3, #85	; 0x55
     130:	e5c13000 	strb	r3, [r1]
     134:	e28330ab 	add	r3, r3, #171	; 0xab
     138:	e5c13000 	strb	r3, [r1]
     13c:	e59f23c8 	ldr	r2, [pc, #968]	; 50c <.text+0x50c>
     140:	e59f33c8 	ldr	r3, [pc, #968]	; 510 <.text+0x510>
     144:	e5832000 	str	r2, [r3]
     148:	e3a02080 	mov	r2, #128	; 0x80
     14c:	e2433008 	sub	r3, r3, #8	; 0x8
     150:	e5832000 	str	r2, [r3]
     154:	e59f23b8 	ldr	r2, [pc, #952]	; 514 <.text+0x514>
     158:	e2833004 	add	r3, r3, #4	; 0x4
     15c:	e5832000 	str	r2, [r3]
     160:	e24dd00c 	sub	sp, sp, #12	; 0xc
     164:	e59f33ac 	ldr	r3, [pc, #940]	; 518 <.text+0x518>
     168:	e1d330b0 	ldrh	r3, [r3]
     16c:	e3130b01 	tst	r3, #1024	; 0x400
     170:	0afffffb 	beq	164 <main+0x58>
     174:	e59f33a0 	ldr	r3, [pc, #928]	; 51c <.text+0x51c>
     178:	e59f2388 	ldr	r2, [pc, #904]	; 508 <.text+0x508>
     17c:	e3a04003 	mov	r4, #3	; 0x3
     180:	e5c34000 	strb	r4, [r3]
     184:	e3e03055 	mvn	r3, #85	; 0x55
     188:	e5c23000 	strb	r3, [r2]
     18c:	e28330ab 	add	r3, r3, #171	; 0xab
     190:	e5c23000 	strb	r3, [r2]
     194:	e59f3384 	ldr	r3, [pc, #900]	; 520 <.text+0x520>
     198:	e3a01002 	mov	r1, #2	; 0x2
     19c:	e4434004 	strb	r4, [r3], #-4
     1a0:	e4c31100 	strb	r1, [r3], #256
     1a4:	e5c31000 	strb	r1, [r3]
     1a8:	e3a02001 	mov	r2, #1	; 0x1
     1ac:	e24330c0 	sub	r3, r3, #192	; 0xc0
     1b0:	e5c32000 	strb	r2, [r3]
     1b4:	e59f3368 	ldr	r3, [pc, #872]	; 524 <.text+0x524>
     1b8:	e3e06000 	mvn	r6, #0	; 0x0
     1bc:	e5836000 	str	r6, [r3]
     1c0:	e59f2360 	ldr	r2, [pc, #864]	; 528 <.text+0x528>
     1c4:	e2433008 	sub	r3, r3, #8	; 0x8
     1c8:	e3a05000 	mov	r5, #0	; 0x0
     1cc:	e4835028 	str	r5, [r3], #40
     1d0:	e5832000 	str	r2, [r3]
     1d4:	eb0000f3 	bl	5a8 <initSysTime>
     1d8:	e1a01004 	mov	r1, r4
     1dc:	e3a02081 	mov	r2, #129	; 0x81
     1e0:	e3a00021 	mov	r0, #33	; 0x21
     1e4:	eb000132 	bl	6b4 <uart0Init>
	uint32_t startTime;
	
	uint8_t nSensors, i, timecnt;
	uint8_t subzero, cel, cel_frac_bits;
	
	sysInit();
	#if defined(UART0_TX_INT_MODE) || defined(UART0_RX_INT_MODE)
	enableIRQ();
     1e8:	eb000275 	bl	bc4 <enableIRQ>
	#endif
	startTime = getSysTICs();
     1ec:	eb0000fe 	bl	5ec <getSysTICs>
     1f0:	e1a07000 	mov	r7, r0
	timecnt = 0;
	
	uart0Puts("\r\nLPC2106 - DS18x20 Temp.-Sensor interface\r\n");
     1f4:	e59f0330 	ldr	r0, [pc, #816]	; 52c <.text+0x52c>
     1f8:	eb0001af 	bl	8bc <uart0Puts>
	uart0Puts("a WinARM Demo-Application by Martin Thomas\r\n\r\n");
     1fc:	e59f032c 	ldr	r0, [pc, #812]	; 530 <.text+0x530>
     200:	eb0001ad 	bl	8bc <uart0Puts>
     204:	e59f0328 	ldr	r0, [pc, #808]	; 534 <.text+0x534>
     208:	eb0001ab 	bl	8bc <uart0Puts>
     20c:	e5cd6008 	strb	r6, [sp, #8]
     210:	ea00001c 	b	288 <main+0x17c>
     214:	e28d0008 	add	r0, sp, #8	; 0x8
     218:	e1a0100d 	mov	r1, sp
     21c:	eb0003b4 	bl	10f4 <DS18X20_find_sensor>
     220:	e5dd3008 	ldrb	r3, [sp, #8]
     224:	e35300ff 	cmp	r3, #255	; 0xff
     228:	059f0308 	ldreq	r0, [pc, #776]	; 538 <.text+0x538>
     22c:	0a000002 	beq	23c <main+0x130>
     230:	e35300fe 	cmp	r3, #254	; 0xfe
     234:	1a000002 	bne	244 <main+0x138>
     238:	e59f02fc 	ldr	r0, [pc, #764]	; 53c <.text+0x53c>
     23c:	eb00019e 	bl	8bc <uart0Puts>
     240:	ea000018 	b	2a8 <main+0x19c>
     244:	e3a01000 	mov	r1, #0	; 0x0
     248:	e7d1200d 	ldrb	r2, [r1, sp]
     24c:	e0813186 	add	r3, r1, r6, lsl #3
     250:	e59f42e8 	ldr	r4, [pc, #744]	; 540 <.text+0x540>
     254:	e2811001 	add	r1, r1, #1	; 0x1
     258:	e3510008 	cmp	r1, #8	; 0x8
     25c:	e7c32004 	strb	r2, [r3, r4]
     260:	1afffff8 	bne	248 <main+0x13c>
     264:	e5d43001 	ldrb	r3, [r4, #1]
     268:	e35300ed 	cmp	r3, #237	; 0xed
     26c:	059f02d0 	ldreq	r0, [pc, #720]	; 544 <.text+0x544>
     270:	0b000191 	bleq	8bc <uart0Puts>
     274:	e5d43001 	ldrb	r3, [r4, #1]
     278:	e3530024 	cmp	r3, #36	; 0x24
     27c:	059f02c4 	ldreq	r0, [pc, #708]	; 548 <.text+0x548>
     280:	0b00018d 	bleq	8bc <uart0Puts>
     284:	e2855001 	add	r5, r5, #1	; 0x1
     288:	e5dd3008 	ldrb	r3, [sp, #8]
     28c:	e20560ff 	and	r6, r5, #255	; 0xff
     290:	e2533000 	subs	r3, r3, #0	; 0x0
     294:	13a03001 	movne	r3, #1	; 0x1
     298:	e3560004 	cmp	r6, #4	; 0x4
     29c:	83a03000 	movhi	r3, #0	; 0x0
     2a0:	e3530000 	cmp	r3, #0	; 0x0
     2a4:	1affffda 	bne	214 <main+0x108>
	
/*	
	while( 1 ) {
		if ( ( IOPIN0 & OW_BIT ) ) {
			uart0Puts("ON\r\n");
		}
		else {
			uart0Puts("OFF\r\n");
		}
	}
*/
	
	nSensors = search_sensors();
     2a8:	e206a0ff 	and	sl, r6, #255	; 0xff
	uart0Puts( itoa(nSensors) );
     2ac:	e1a0000a 	mov	r0, sl
     2b0:	eb000401 	bl	12bc <itoa>
     2b4:	eb000180 	bl	8bc <uart0Puts>
	uart0Puts( " DS18X20 Sensors available:\r\n" );
     2b8:	e59f028c 	ldr	r0, [pc, #652]	; 54c <.text+0x54c>
     2bc:	eb00017e 	bl	8bc <uart0Puts>
     2c0:	e3a05000 	mov	r5, #0	; 0x0
     2c4:	ea000017 	b	328 <main+0x21c>
	for (i=0; i<nSensors; i++) {
		uart0Puts("Sensor# ");
     2c8:	eb00017b 	bl	8bc <uart0Puts>
		uart0Puts(itoa(i+1));
     2cc:	e2840001 	add	r0, r4, #1	; 0x1
     2d0:	eb0003f9 	bl	12bc <itoa>
     2d4:	eb000178 	bl	8bc <uart0Puts>
		uart0Puts(" is a ");
     2d8:	e59f0270 	ldr	r0, [pc, #624]	; 550 <.text+0x550>
     2dc:	eb000176 	bl	8bc <uart0Puts>
		if ( gSensorIDs[i][0] == DS18S20_ID)
     2e0:	e59f3258 	ldr	r3, [pc, #600]	; 540 <.text+0x540>
     2e4:	e7d33184 	ldrb	r3, [r3, r4, lsl #3]
     2e8:	e3530010 	cmp	r3, #16	; 0x10
			uart0Puts("DS18S20/DS1820");
     2ec:	e59f0260 	ldr	r0, [pc, #608]	; 554 <.text+0x554>
		else 
			uart0Puts("DS18B20");
     2f0:	159f0260 	ldrne	r0, [pc, #608]	; 558 <.text+0x558>
     2f4:	eb000170 	bl	8bc <uart0Puts>
		uart0Puts(" which is ");
     2f8:	e59f025c 	ldr	r0, [pc, #604]	; 55c <.text+0x55c>
     2fc:	eb00016e 	bl	8bc <uart0Puts>
		if ( DS18X20_get_power_status( &gSensorIDs[i][0] ) ==
     300:	e59f0238 	ldr	r0, [pc, #568]	; 540 <.text+0x540>
     304:	e0800184 	add	r0, r0, r4, lsl #3
     308:	eb00038b 	bl	113c <DS18X20_get_power_status>
     30c:	e3500000 	cmp	r0, #0	; 0x0
			DS18X20_POWER_PARASITE ) 
			uart0Puts( "parasite" );
     310:	e59f0248 	ldr	r0, [pc, #584]	; 560 <.text+0x560>
		else uart0Puts( "externally" ); 
     314:	159f0248 	ldrne	r0, [pc, #584]	; 564 <.text+0x564>
     318:	eb000167 	bl	8bc <uart0Puts>
		uart0Puts( " powered\r" );
     31c:	e59f0244 	ldr	r0, [pc, #580]	; 568 <.text+0x568>
     320:	e2855001 	add	r5, r5, #1	; 0x1
     324:	eb000164 	bl	8bc <uart0Puts>
     328:	e20540ff 	and	r4, r5, #255	; 0xff
     32c:	e154000a 	cmp	r4, sl
     330:	e59f0234 	ldr	r0, [pc, #564]	; 56c <.text+0x56c>
     334:	3affffe3 	bcc	2c8 <main+0x1bc>
     338:	ea00006f 	b	4fc <STACK_SIZE+0xfc>
     33c:	e3a05006 	mov	r5, #6	; 0x6
	}

	for (;;) {
		do {
			int ch;
			
			if ((ch = uart0Getch()) >= 0) {
     340:	eb00019e 	bl	9c0 <uart0Getch>
     344:	e2504000 	subs	r4, r0, #0	; 0x0
     348:	ba000007 	blt	36c <main+0x260>
				uart0Puts("the <");
     34c:	e59f021c 	ldr	r0, [pc, #540]	; 570 <.text+0x570>
     350:	eb000159 	bl	8bc <uart0Puts>
				uart0Putch(ch);
     354:	e1a00004 	mov	r0, r4
     358:	eb00011a 	bl	7c8 <uart0Putch>
				uart0Puts("> key has been pressed\r\n");
     35c:	e59f0210 	ldr	r0, [pc, #528]	; 574 <.text+0x574>
     360:	eb000155 	bl	8bc <uart0Puts>
				if (ch=='p') ow_delay_debug();
     364:	e3540070 	cmp	r4, #112	; 0x70
     368:	0b00022a 	bleq	c18 <ow_delay_debug>
			}
		} while (getElapsedSysTICs(startTime) < HALF_SEC);
     36c:	e1a00007 	mov	r0, r7
     370:	eb0000ab 	bl	624 <getElapsedSysTICs>
     374:	e59f31fc 	ldr	r3, [pc, #508]	; 578 <.text+0x578>
     378:	e1500003 	cmp	r0, r3
     37c:	9affffef 	bls	340 <main+0x234>
	
		if (IOPIN1 & LED1_BIT) IOCLR1 = LED1_BIT;
     380:	e59f31f4 	ldr	r3, [pc, #500]	; 57c <.text+0x57c>
     384:	e5933000 	ldr	r3, [r3]
     388:	e3130080 	tst	r3, #128	; 0x80
     38c:	159f317c 	ldrne	r3, [pc, #380]	; 510 <.text+0x510>
		else IOSET1 = LED1_BIT; 	
     390:	059f31e8 	ldreq	r3, [pc, #488]	; 580 <.text+0x580>
     394:	13a02080 	movne	r2, #128	; 0x80
     398:	03a02080 	moveq	r2, #128	; 0x80
     39c:	e5832000 	str	r2, [r3]
	
		startTime += HALF_SEC;
		
		timecnt++;
     3a0:	e2853001 	add	r3, r5, #1	; 0x1
     3a4:	e2877713 	add	r7, r7, #4980736	; 0x4c0000
     3a8:	e20350ff 	and	r5, r3, #255	; 0xff
     3ac:	e2877c4b 	add	r7, r7, #19200	; 0x4b00
		if (timecnt==2) {
     3b0:	e3550002 	cmp	r5, #2	; 0x2
     3b4:	e2877040 	add	r7, r7, #64	; 0x40
     3b8:	1a00000c 	bne	3f0 <main+0x2e4>
			uart0Puts("Start conversion all sensors ");
     3bc:	e59f01c0 	ldr	r0, [pc, #448]	; 584 <.text+0x584>
     3c0:	eb00013d 	bl	8bc <uart0Puts>
			if ( DS18X20_start_meas( DS18X20_POWER_PARASITE, 0 ) 
     3c4:	e3a00000 	mov	r0, #0	; 0x0
     3c8:	e1a01000 	mov	r1, r0
     3cc:	eb000367 	bl	1170 <DS18X20_start_meas>
     3d0:	e3500000 	cmp	r0, #0	; 0x0
				== DS18X20_OK) 
				uart0Puts("OK ");
     3d4:	059f01ac 	ldreq	r0, [pc, #428]	; 588 <.text+0x588>
			else 
				uart0Puts("failed (short circuit?)");
     3d8:	159f01ac 	ldrne	r0, [pc, #428]	; 58c <.text+0x58c>
     3dc:	eb000136 	bl	8bc <uart0Puts>
			uart0Puts("\r\n");
     3e0:	e59f01a8 	ldr	r0, [pc, #424]	; 590 <.text+0x590>
     3e4:	eb000134 	bl	8bc <uart0Puts>
     3e8:	e3a05002 	mov	r5, #2	; 0x2
     3ec:	eaffffd3 	b	340 <main+0x234>
		}
		else if (timecnt==6) {
     3f0:	e3550006 	cmp	r5, #6	; 0x6
     3f4:	03a08000 	moveq	r8, #0	; 0x0
     3f8:	0a000038 	beq	4e0 <STACK_SIZE+0xe0>
     3fc:	ea00003c 	b	4f4 <STACK_SIZE+0xf4>
			for ( i=0; i<nSensors; i++ ) {
				uart0Puts("Sensor# ");
     400:	eb00012d 	bl	8bc <uart0Puts>
				uart0Puts(itoa(i+1));
     404:	e2840001 	add	r0, r4, #1	; 0x1
     408:	eb0003ab 	bl	12bc <itoa>
     40c:	eb00012a 	bl	8bc <uart0Puts>
				uart0Puts(" = ");
     410:	e59f017c 	ldr	r0, [pc, #380]	; 594 <.text+0x594>
     414:	eb000128 	bl	8bc <uart0Puts>
				if ( DS18X20_read_meas( &gSensorIDs[i][0], &subzero,
     418:	e59f0120 	ldr	r0, [pc, #288]	; 540 <.text+0x540>
     41c:	e28d3009 	add	r3, sp, #9	; 0x9
     420:	e0800184 	add	r0, r0, r4, lsl #3
     424:	e28d100b 	add	r1, sp, #11	; 0xb
     428:	e28d200a 	add	r2, sp, #10	; 0xa
     42c:	eb000360 	bl	11b4 <DS18X20_read_meas>
     430:	e3500000 	cmp	r0, #0	; 0x0
						&cel, &cel_frac_bits) == DS18X20_OK ) {
					uart_put_temp(subzero, cel, cel_frac_bits);
				}
				else uart0Puts("CRC Error (lost connection?)");
     434:	e59f015c 	ldr	r0, [pc, #348]	; 598 <.text+0x598>
     438:	1a000024 	bne	4d0 <STACK_SIZE+0xd0>
     43c:	e5dd400b 	ldrb	r4, [sp, #11]
     440:	e5dd500a 	ldrb	r5, [sp, #10]
     444:	e3540000 	cmp	r4, #0	; 0x0
     448:	03a0002b 	moveq	r0, #43	; 0x2b
     44c:	13a0002d 	movne	r0, #45	; 0x2d
     450:	e5dd6009 	ldrb	r6, [sp, #9]
     454:	eb0000db 	bl	7c8 <uart0Putch>
     458:	e1a00005 	mov	r0, r5
     45c:	eb000396 	bl	12bc <itoa>
     460:	eb000115 	bl	8bc <uart0Puts>
     464:	e59f0130 	ldr	r0, [pc, #304]	; 59c <.text+0x59c>
     468:	eb000113 	bl	8bc <uart0Puts>
     46c:	e3540000 	cmp	r4, #0	; 0x0
     470:	03a0002b 	moveq	r0, #43	; 0x2b
     474:	13a0002d 	movne	r0, #45	; 0x2d
     478:	eb0000d2 	bl	7c8 <uart0Putch>
     47c:	e1a02006 	mov	r2, r6
     480:	e1a00004 	mov	r0, r4
     484:	e1a01005 	mov	r1, r5
     488:	eb0002df 	bl	100c <DS18X20_temp_to_decicel>
     48c:	e3a0100a 	mov	r1, #10	; 0xa
     490:	e1a04000 	mov	r4, r0
     494:	eb0003d1 	bl	13e0 <__udivsi3>
     498:	e1a00800 	mov	r0, r0, lsl #16
     49c:	e1a00840 	mov	r0, r0, asr #16
     4a0:	eb000385 	bl	12bc <itoa>
     4a4:	eb000104 	bl	8bc <uart0Puts>
     4a8:	e59f00f0 	ldr	r0, [pc, #240]	; 5a0 <.text+0x5a0>
     4ac:	eb000102 	bl	8bc <uart0Puts>
     4b0:	e3a0100a 	mov	r1, #10	; 0xa
     4b4:	e1a00004 	mov	r0, r4
     4b8:	eb00045c 	bl	1630 <__umodsi3>
     4bc:	e1a00800 	mov	r0, r0, lsl #16
     4c0:	e1a00820 	mov	r0, r0, lsr #16
     4c4:	e2800030 	add	r0, r0, #48	; 0x30
     4c8:	eb0000be 	bl	7c8 <uart0Putch>
     4cc:	e59f00d0 	ldr	r0, [pc, #208]	; 5a4 <.text+0x5a4>
     4d0:	eb0000f9 	bl	8bc <uart0Puts>
				uart0Puts("\r\n");
     4d4:	e59f00b4 	ldr	r0, [pc, #180]	; 590 <.text+0x590>
     4d8:	e2888001 	add	r8, r8, #1	; 0x1
     4dc:	eb0000f6 	bl	8bc <uart0Puts>
     4e0:	e20840ff 	and	r4, r8, #255	; 0xff
     4e4:	e154000a 	cmp	r4, sl
     4e8:	e59f007c 	ldr	r0, [pc, #124]	; 56c <.text+0x56c>
     4ec:	3affffc3 	bcc	400 <STACK_SIZE>
     4f0:	eaffff91 	b	33c <main+0x230>
			}
		}
		else if (timecnt>10) timecnt=0;
     4f4:	e355000a 	cmp	r5, #10	; 0xa
     4f8:	9affff90 	bls	340 <main+0x234>
     4fc:	e3a05000 	mov	r5, #0	; 0x0
     500:	eaffff8e 	b	340 <main+0x234>
     504:	e01fc084 	ands	ip, pc, r4, lsl #1
     508:	e01fc08c 	ands	ip, pc, ip, lsl #1
     50c:	7fc1ff7c 	swivc	0x00c1ff7c
     510:	e002801c 	and	r8, r2, ip, lsl r0
     514:	7fc1fffc 	swivc	0x00c1fffc
     518:	e01fc088 	ands	ip, pc, r8, lsl #1
     51c:	e01fc080 	ands	ip, pc, r0, lsl #1
     520:	e01fc004 	ands	ip, pc, r4
     524:	fffff014 	swinv	0x00fff014
     528:	000000ec 	andeq	r0, r0, ip, ror #1
     52c:	000020b0 	streqh	r2, [r0], -r0
     530:	000020e0 	andeq	r2, r0, r0, ror #1
     534:	00002110 	andeq	r2, r0, r0, lsl r1
     538:	00002130 	andeq	r2, r0, r0, lsr r1
     53c:	00002144 	andeq	r2, r0, r4, asr #2
     540:	4000000f 	andmi	r0, r0, pc
     544:	00002150 	andeq	r2, r0, r0, asr r1
     548:	00002158 	andeq	r2, r0, r8, asr r1
     54c:	00002160 	andeq	r2, r0, r0, ror #2
     550:	0000218c 	andeq	r2, r0, ip, lsl #3
     554:	00002194 	muleq	r0, r4, r1
     558:	000021a4 	andeq	r2, r0, r4, lsr #3
     55c:	000021ac 	andeq	r2, r0, ip, lsr #3
     560:	000021b8 	streqh	r2, [r0], -r8
     564:	000021c4 	andeq	r2, r0, r4, asr #3
     568:	000021d0 	ldreqd	r2, [r0], -r0
     56c:	00002180 	andeq	r2, r0, r0, lsl #3
     570:	000021dc 	ldreqd	r2, [r0], -ip
     574:	000021e4 	andeq	r2, r0, r4, ror #3
     578:	004c4b3f 	subeq	r4, ip, pc, lsr fp
     57c:	e0028010 	and	r8, r2, r0, lsl r0
     580:	e0028014 	and	r8, r2, r4, lsl r0
     584:	00002200 	andeq	r2, r0, r0, lsl #4
     588:	00002220 	andeq	r2, r0, r0, lsr #4
     58c:	00002224 	andeq	r2, r0, r4, lsr #4
     590:	0000210c 	andeq	r2, r0, ip, lsl #2
     594:	0000223c 	andeq	r2, r0, ip, lsr r2
     598:	00002250 	andeq	r2, r0, r0, asr r2
     59c:	00002240 	andeq	r2, r0, r0, asr #4
     5a0:	00002248 	andeq	r2, r0, r8, asr #4
     5a4:	0000224c 	andeq	r2, r0, ip, asr #4

000005a8 <initSysTime>:
  T0MCR = 0;                            // disable match registers
  T0CCR = 0;                            // disable compare registers
  T0EMR = 0;                            // disable external match register
  T0TCR = TCR_ENABLE;                   // enable timer 0
  sysTICs = 0;
     5a8:	e59f3030 	ldr	r3, [pc, #48]	; 5e0 <.text+0x5e0>
     5ac:	e3a02000 	mov	r2, #0	; 0x0
     5b0:	e5832000 	str	r2, [r3]
     5b4:	e59f0028 	ldr	r0, [pc, #40]	; 5e4 <.text+0x5e4>
     5b8:	e59f3028 	ldr	r3, [pc, #40]	; 5e8 <.text+0x5e8>
     5bc:	e3a01002 	mov	r1, #2	; 0x2
     5c0:	e5801000 	str	r1, [r0]
     5c4:	e4831008 	str	r1, [r3], #8
     5c8:	e4832014 	str	r2, [r3], #20
     5cc:	e4832014 	str	r2, [r3], #20
     5d0:	e5832000 	str	r2, [r3]
     5d4:	e3a03001 	mov	r3, #1	; 0x1
     5d8:	e5803000 	str	r3, [r0]
}
     5dc:	e12fff1e 	bx	lr
     5e0:	40000004 	andmi	r0, r0, r4
     5e4:	e0004004 	and	r4, r0, r4
     5e8:	e000400c 	and	r4, r0, ip

000005ec <getSysTICs>:

/******************************************************************************
 *
 * Function Name: getSysTICs()
 *
 * Description:
 *    This function returns the current syetem time in TICs.
 *
 * Calling Sequence: 
 *    void
 *
 * Returns:
 *    The current time in TICs as represented by sysTICs
 *
 *****************************************************************************/
uint32_t getSysTICs(void)
{
  uint32_t now = T0TC;

  sysTICs += (uint32_t)(now - lastT0TC);
     5ec:	e59f1024 	ldr	r1, [pc, #36]	; 618 <.text+0x618>
     5f0:	e59f3024 	ldr	r3, [pc, #36]	; 61c <.text+0x61c>
     5f4:	e59fc024 	ldr	ip, [pc, #36]	; 620 <.text+0x620>
     5f8:	e5932000 	ldr	r2, [r3]
     5fc:	e5913000 	ldr	r3, [r1]
     600:	e59c0000 	ldr	r0, [ip]
     604:	e0633002 	rsb	r3, r3, r2
     608:	e0800003 	add	r0, r0, r3
  lastT0TC = now;
     60c:	e5812000 	str	r2, [r1]
     610:	e58c0000 	str	r0, [ip]
  return sysTICs;
}
     614:	e12fff1e 	bx	lr
     618:	40000000 	andmi	r0, r0, r0
     61c:	e0004008 	and	r4, r0, r8
     620:	40000004 	andmi	r0, r0, r4

00000624 <getElapsedSysTICs>:


/******************************************************************************
 *
 * Function Name: getElapsedSysTICs()
 *
 * Description:
 *    This function then returns the difference in TICs between the
 *    given starting time and the current system time.
 *
 * Calling Sequence: 
 *    The starting time.
 *
 * Returns:
 *    The time difference.
 *
 *****************************************************************************/
uint32_t getElapsedSysTICs(uint32_t startTime)
{
     624:	e52de004 	str	lr, [sp, #-4]!
     628:	e59fc028 	ldr	ip, [pc, #40]	; 658 <.text+0x658>
     62c:	e59f3028 	ldr	r3, [pc, #40]	; 65c <.text+0x65c>
     630:	e59fe028 	ldr	lr, [pc, #40]	; 660 <.text+0x660>
     634:	e5931000 	ldr	r1, [r3]
     638:	e59c3000 	ldr	r3, [ip]
     63c:	e59e2000 	ldr	r2, [lr]
     640:	e0633001 	rsb	r3, r3, r1
     644:	e0822003 	add	r2, r2, r3
  return getSysTICs() - startTime;
}
     648:	e0600002 	rsb	r0, r0, r2
     64c:	e58c1000 	str	r1, [ip]
     650:	e58e2000 	str	r2, [lr]
     654:	e49df004 	ldr	pc, [sp], #4
     658:	40000000 	andmi	r0, r0, r0
     65c:	e0004008 	and	r4, r0, r8
     660:	40000004 	andmi	r0, r0, r4

00000664 <pause>:


/******************************************************************************
 *
 * Function Name: pause()
 *
 * Description:
 *    This function does not return until the specified 'duration' in
 *    TICs has elapsed.
 *
 * Calling Sequence: 
 *    duration - length of time in TICs to wait before returning
 *
 * Returns:
 *    void
 *
 *****************************************************************************/
void pause(uint32_t duration)
{
     664:	e92d4030 	stmdb	sp!, {r4, r5, lr}
     668:	e59fc038 	ldr	ip, [pc, #56]	; 6a8 <.text+0x6a8>
     66c:	e59f3038 	ldr	r3, [pc, #56]	; 6ac <.text+0x6ac>
     670:	e59fe038 	ldr	lr, [pc, #56]	; 6b0 <.text+0x6b0>
     674:	e5931000 	ldr	r1, [r3]
     678:	e59c3000 	ldr	r3, [ip]
     67c:	e59e2000 	ldr	r2, [lr]
     680:	e0633001 	rsb	r3, r3, r1
     684:	e0825003 	add	r5, r2, r3
     688:	e58c1000 	str	r1, [ip]
     68c:	e58e5000 	str	r5, [lr]
     690:	e1a04000 	mov	r4, r0
  uint32_t startTime = getSysTICs();

  while (getElapsedSysTICs(startTime) < duration)
     694:	e1a00005 	mov	r0, r5
     698:	ebffffe1 	bl	624 <getElapsedSysTICs>
     69c:	e1500004 	cmp	r0, r4
     6a0:	3afffffb 	bcc	694 <pause+0x30>
    WDOG();
}
     6a4:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
     6a8:	40000000 	andmi	r0, r0, r0
     6ac:	e0004008 	and	r4, r0, r8
     6b0:	40000004 	andmi	r0, r0, r4

000006b4 <uart0Init>:
 * NOTE: uart0Init(UART_BAUD(9600), UART_8N1, UART_FIFO_8);
 *
 *****************************************************************************/
void uart0Init(uint16_t baud, uint8_t mode, uint8_t fmode)
{
     6b4:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
  // set port pins for UART0
  PINSEL0 = (PINSEL0 & ~U0_PINMASK) | U0_PINSEL;
     6b8:	e59fc0cc 	ldr	ip, [pc, #204]	; 78c <.text+0x78c>
     6bc:	e59c3000 	ldr	r3, [ip]

  U0IER = 0x00;                         // disable all interrupts
     6c0:	e59f60c8 	ldr	r6, [pc, #200]	; 790 <.text+0x790>
     6c4:	e3c3300f 	bic	r3, r3, #15	; 0xf
     6c8:	e3a0e000 	mov	lr, #0	; 0x0
     6cc:	e3833005 	orr	r3, r3, #5	; 0x5
     6d0:	e58c3000 	str	r3, [ip]
  U0IIR;                                // clear interrupt ID
     6d4:	e59f70b8 	ldr	r7, [pc, #184]	; 794 <.text+0x794>
     6d8:	e5c6e000 	strb	lr, [r6]
  U0RBR;                                // clear receive register
     6dc:	e59f40b4 	ldr	r4, [pc, #180]	; 798 <.text+0x798>
     6e0:	e5d73000 	ldrb	r3, [r7]
     6e4:	e1a00800 	mov	r0, r0, lsl #16
     6e8:	e5d43000 	ldrb	r3, [r4]
  U0LSR;                                // clear line status register
     6ec:	e59f30a8 	ldr	r3, [pc, #168]	; 79c <.text+0x79c>

  // set the baudrate
  U0LCR = ULCR_DLAB_ENABLE;             // select divisor latches 
     6f0:	e59f50a8 	ldr	r5, [pc, #168]	; 7a0 <.text+0x7a0>
     6f4:	e1a0c820 	mov	ip, r0, lsr #16
     6f8:	e5d33000 	ldrb	r3, [r3]
     6fc:	e20220ff 	and	r2, r2, #255	; 0xff
     700:	e3e0307f 	mvn	r3, #127	; 0x7f
  U0DLL = (uint8_t)baud;                // set for baud low byte
     704:	e20cc0ff 	and	ip, ip, #255	; 0xff
  U0DLM = (uint8_t)(baud >> 8);         // set for baud high byte
     708:	e1a00c20 	mov	r0, r0, lsr #24

  // set the number of characters and other
  // user specified operating parameters
  U0LCR = (mode & ~ULCR_DLAB_ENABLE);
     70c:	e201107f 	and	r1, r1, #127	; 0x7f
     710:	e5c53000 	strb	r3, [r5]
     714:	e5c4c000 	strb	ip, [r4]
     718:	e5c60000 	strb	r0, [r6]
     71c:	e5c51000 	strb	r1, [r5]
  U0FCR = fmode;
     720:	e5c72000 	strb	r2, [r7]

#if defined(UART0_TX_INT_MODE) || defined(UART0_RX_INT_MODE)
  // initialize the interrupt vector
  VICIntSelect &= ~VIC_BIT(VIC_UART0);  // UART0 selected as IRQ
     724:	e59f2078 	ldr	r2, [pc, #120]	; 7a4 <.text+0x7a4>
     728:	e5923000 	ldr	r3, [r2]
     72c:	e3c33040 	bic	r3, r3, #64	; 0x40
     730:	e5823000 	str	r3, [r2]
  VICIntEnable = VIC_BIT(VIC_UART0);    // UART0 interrupt enabled
  VICVectCntl0 = VIC_ENABLE | VIC_UART0;
  VICVectAddr0 = (uint32_t)uart0ISR;    // address of the ISR

#ifdef UART0_TX_INT_MODE
  // initialize the transmit data queue
  uart0_tx_extract_idx = uart0_tx_insert_idx = 0;
  uart0_tx_running = 0;
#endif

#ifdef UART0_RX_INT_MODE
  // initialize the receive data queue
  uart0_rx_extract_idx = uart0_rx_insert_idx = 0;
     734:	e59f306c 	ldr	r3, [pc, #108]	; 7a8 <.text+0x7a8>
     738:	e1c3e0b0 	strh	lr, [r3]
     73c:	e59f3068 	ldr	r3, [pc, #104]	; 7ac <.text+0x7ac>
     740:	e3a02040 	mov	r2, #64	; 0x40
     744:	e5832000 	str	r2, [r3]
     748:	e3a02026 	mov	r2, #38	; 0x26
     74c:	e2833e1f 	add	r3, r3, #496	; 0x1f0
     750:	e5832000 	str	r2, [r3]
     754:	e59f3054 	ldr	r3, [pc, #84]	; 7b0 <.text+0x7b0>
     758:	e59f2054 	ldr	r2, [pc, #84]	; 7b4 <.text+0x7b4>
     75c:	e5832000 	str	r2, [r3]

  // enable receiver interrupts
  U0IER = UIER_ERBFI;
     760:	e3a03001 	mov	r3, #1	; 0x1
     764:	e5c63000 	strb	r3, [r6]
     768:	e59f3048 	ldr	r3, [pc, #72]	; 7b8 <.text+0x7b8>
     76c:	e1c3e0b0 	strh	lr, [r3]
     770:	e59f3044 	ldr	r3, [pc, #68]	; 7bc <.text+0x7bc>
     774:	e1c3e0b0 	strh	lr, [r3]
     778:	e59f3040 	ldr	r3, [pc, #64]	; 7c0 <.text+0x7c0>
     77c:	e583e000 	str	lr, [r3]
     780:	e59f303c 	ldr	r3, [pc, #60]	; 7c4 <.text+0x7c4>
     784:	e1c3e0b0 	strh	lr, [r3]
#endif
#endif
}
     788:	e8bd80f0 	ldmia	sp!, {r4, r5, r6, r7, pc}
     78c:	e002c000 	and	ip, r2, r0
     790:	e000c004 	and	ip, r0, r4
     794:	e000c008 	and	ip, r0, r8
     798:	e000c000 	and	ip, r0, r0
     79c:	e000c014 	and	ip, r0, r4, lsl r0
     7a0:	e000c00c 	and	ip, r0, ip
     7a4:	fffff00c 	swinv	0x00fff00c
     7a8:	40000184 	andmi	r0, r0, r4, lsl #3
     7ac:	fffff010 	swinv	0x00fff010
     7b0:	fffff100 	swinv	0x00fff100
     7b4:	00000a00 	andeq	r0, r0, r0, lsl #20
     7b8:	40000138 	andmi	r0, r0, r8, lsr r1
     7bc:	4000013c 	andmi	r0, r0, ip, lsr r1
     7c0:	40000140 	andmi	r0, r0, r0, asr #2
     7c4:	4000013a 	andmi	r0, r0, sl, lsr r1

000007c8 <uart0Putch>:

/******************************************************************************
 *
 * Function Name: uart0Putch()
 *
 * Description:  
 *    This function puts a character into the UART output queue for
 *    transmission.
 *
 * Calling Sequence: 
 *    character to be transmitted
 *
 * Returns:
 *    ch on success, -1 on error (queue full)
 *
 *****************************************************************************/
int uart0Putch(int ch)
{
     7c8:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
#ifdef UART0_TX_INT_MODE
  uint16_t temp;
  unsigned cpsr;

  temp = (uart0_tx_insert_idx + 1) % UART0_TX_BUFFER_SIZE;
     7cc:	e59f6098 	ldr	r6, [pc, #152]	; 86c <.text+0x86c>
     7d0:	e1d630b0 	ldrh	r3, [r6]
     7d4:	e59f2094 	ldr	r2, [pc, #148]	; 870 <.text+0x870>
     7d8:	e2833001 	add	r3, r3, #1	; 0x1
     7dc:	e0032002 	and	r2, r3, r2

  if (temp == uart0_tx_extract_idx)
     7e0:	e59f308c 	ldr	r3, [pc, #140]	; 874 <.text+0x874>
     7e4:	e1a02802 	mov	r2, r2, lsl #16
     7e8:	e1d330b0 	ldrh	r3, [r3]
     7ec:	e1a05822 	mov	r5, r2, lsr #16
     7f0:	e1530005 	cmp	r3, r5
     7f4:	e1a04000 	mov	r4, r0
     7f8:	e3e03000 	mvn	r3, #0	; 0x0
     7fc:	0a000018 	beq	864 <uart0Putch+0x9c>
    return -1;                          // no room

  cpsr = disableIRQ();                  // disable global interrupts
     800:	eb0000e4 	bl	b98 <disableIRQ>
  U0IER &= ~UIER_ETBEI;                 // disable TX interrupts
     804:	e59f306c 	ldr	r3, [pc, #108]	; 878 <.text+0x878>
     808:	e5d32000 	ldrb	r2, [r3]
     80c:	e20220fd 	and	r2, r2, #253	; 0xfd
     810:	e5c32000 	strb	r2, [r3]
  restoreIRQ(cpsr);                     // restore global interrupts
     814:	eb0000e3 	bl	ba8 <restoreIRQ>

  // check if in process of sending data
  if (uart0_tx_running)
     818:	e59f105c 	ldr	r1, [pc, #92]	; 87c <.text+0x87c>
     81c:	e5913000 	ldr	r3, [r1]
     820:	e3530000 	cmp	r3, #0	; 0x0
    {
    // add to queue
    uart0_tx_buffer[uart0_tx_insert_idx] = (uint8_t)ch;
    uart0_tx_insert_idx = temp;
    }
  else
    {
    // set running flag and write to output register
    uart0_tx_running = 1;
     824:	03a03001 	moveq	r3, #1	; 0x1
    U0THR = (uint8_t)ch;
     828:	e20420ff 	and	r2, r4, #255	; 0xff
     82c:	05813000 	streq	r3, [r1]
     830:	11d620b0 	ldrneh	r2, [r6]
     834:	159f3044 	ldrne	r3, [pc, #68]	; 880 <.text+0x880>
     838:	059f3044 	ldreq	r3, [pc, #68]	; 884 <.text+0x884>
     83c:	17c34002 	strneb	r4, [r3, r2]
     840:	05c32000 	streqb	r2, [r3]
     844:	11c650b0 	strneh	r5, [r6]
    }

  cpsr = disableIRQ();                  // disable global interrupts
     848:	eb0000d2 	bl	b98 <disableIRQ>
  U0IER |= UIER_ETBEI;                  // enable TX interrupts
     84c:	e59f2024 	ldr	r2, [pc, #36]	; 878 <.text+0x878>
     850:	e5d23000 	ldrb	r3, [r2]
     854:	e3833002 	orr	r3, r3, #2	; 0x2
     858:	e5c23000 	strb	r3, [r2]
  restoreIRQ(cpsr);                     // restore global interrupts
     85c:	eb0000d1 	bl	ba8 <restoreIRQ>
#else
  while (!(U0LSR & ULSR_THRE))          // wait for TX buffer to empty
    continue;                           // also either WDOG() or swap()

  U0THR = (uint8_t)ch;
#endif
  return (uint8_t)ch;
     860:	e20430ff 	and	r3, r4, #255	; 0xff
}
     864:	e1a00003 	mov	r0, r3
     868:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
     86c:	40000138 	andmi	r0, r0, r8, lsr r1
     870:	800000ff 	strhid	r0, [r0], -pc
     874:	4000013c 	andmi	r0, r0, ip, lsr r1
     878:	e000c004 	and	ip, r0, r4
     87c:	40000140 	andmi	r0, r0, r0, asr #2
     880:	40000038 	andmi	r0, r0, r8, lsr r0
     884:	e000c000 	and	ip, r0, r0

00000888 <uart0Space>:

/******************************************************************************
 *
 * Function Name: uart0Space()
 *
 * Description:  
 *    This function gets the available space in the transmit queue
 *
 * Calling Sequence: 
 *    void
 *
 * Returns:
 *    available space in the transmit queue
 *
 *****************************************************************************/
uint16_t uart0Space(void)
{
#ifdef UART0_TX_INT_MODE
  int space;

  if ((space = (uart0_tx_extract_idx - uart0_tx_insert_idx)) <= 0)
     888:	e59f3024 	ldr	r3, [pc, #36]	; 8b4 <.text+0x8b4>
     88c:	e1d320b0 	ldrh	r2, [r3]
     890:	e59f3020 	ldr	r3, [pc, #32]	; 8b8 <.text+0x8b8>
     894:	e1d330b0 	ldrh	r3, [r3]
     898:	e0630002 	rsb	r0, r3, r2
     89c:	e3500000 	cmp	r0, #0	; 0x0
    space += UART0_TX_BUFFER_SIZE;
     8a0:	d2800c01 	addle	r0, r0, #256	; 0x100
     8a4:	e2400001 	sub	r0, r0, #1	; 0x1
     8a8:	e1a00800 	mov	r0, r0, lsl #16

  return (uint16_t)(space - 1);
#else
  return USHRT_MAX;
#endif
}
     8ac:	e1a00820 	mov	r0, r0, lsr #16
     8b0:	e12fff1e 	bx	lr
     8b4:	4000013c 	andmi	r0, r0, ip, lsr r1
     8b8:	40000138 	andmi	r0, r0, r8, lsr r1

000008bc <uart0Puts>:

/******************************************************************************
 *
 * Function Name: uart0Puts()
 *
 * Description:  
 *    This function writes a NULL terminated 'string' to the UART output
 *    queue, returning a pointer to the next character to be written.
 *
 * Calling Sequence: 
 *    address of the string
 *
 * Returns:
 *    a pointer to the next character to be written
 *    (\0 if full string is written)
 *
 *****************************************************************************/
const char *uart0Puts(const char *string)
{
     8bc:	e92d4010 	stmdb	sp!, {r4, lr}
     8c0:	e1a04000 	mov	r4, r0
     8c4:	ea000000 	b	8cc <uart0Puts+0x10>
  register char ch;

  while ((ch = *string) && (uart0Putch(ch) >= 0))
    string++;
     8c8:	e2844001 	add	r4, r4, #1	; 0x1
     8cc:	e5d43000 	ldrb	r3, [r4]
     8d0:	e2530000 	subs	r0, r3, #0	; 0x0
     8d4:	0a000002 	beq	8e4 <uart0Puts+0x28>
     8d8:	ebffffba 	bl	7c8 <uart0Putch>
     8dc:	e3500000 	cmp	r0, #0	; 0x0
     8e0:	aafffff8 	bge	8c8 <uart0Puts+0xc>

  return string;
}
     8e4:	e1a00004 	mov	r0, r4
     8e8:	e8bd8010 	ldmia	sp!, {r4, pc}

000008ec <uart0Write>:

/******************************************************************************
 *
 * Function Name: uart0Write()
 *
 * Description:  
 *    This function writes 'count' characters from 'buffer' to the UART
 *    output queue.
 *
 * Calling Sequence: 
 *    
 *
 * Returns:
 *    0 on success, -1 if insufficient room, -2 on error
 *    NOTE: if insufficient room, no characters are written.
 *
 *****************************************************************************/
int uart0Write(const char *buffer, uint16_t count)
{
     8ec:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
     8f0:	e1a01801 	mov	r1, r1, lsl #16
     8f4:	e1a06821 	mov	r6, r1, lsr #16
     8f8:	e1a05000 	mov	r5, r0
#ifdef UART0_TX_INT_MODE
  if (count > uart0Space())
     8fc:	ebffffe1 	bl	888 <uart0Space>
     900:	e1560000 	cmp	r6, r0
     904:	83e00000 	mvnhi	r0, #0	; 0x0
     908:	88bd8070 	ldmhiia	sp!, {r4, r5, r6, pc}
     90c:	ea000001 	b	918 <uart0Write+0x2c>
    return -1;
#endif
  while (count && (uart0Putch(*buffer++) >= 0))
     910:	e3a00000 	mov	r0, #0	; 0x0
     914:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
     918:	e1a04006 	mov	r4, r6
     91c:	ea000002 	b	92c <uart0Write+0x40>
    count--;
     920:	e2443001 	sub	r3, r4, #1	; 0x1
     924:	e1a03803 	mov	r3, r3, lsl #16
     928:	e1a04823 	mov	r4, r3, lsr #16
     92c:	e3540000 	cmp	r4, #0	; 0x0
     930:	0afffff6 	beq	910 <uart0Write+0x24>
     934:	e4d50001 	ldrb	r0, [r5], #1
     938:	ebffffa2 	bl	7c8 <uart0Putch>
     93c:	e3500000 	cmp	r0, #0	; 0x0
     940:	aafffff6 	bge	920 <uart0Write+0x34>
     944:	e3e00001 	mvn	r0, #1	; 0x1

  return (count ? -2 : 0);
}
     948:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}

0000094c <uart0TxEmpty>:

/******************************************************************************
 *
 * Function Name: uart0TxEmpty()
 *
 * Description:
 *    This function returns the status of the UART transmit data
 *    registers.
 *
 * Calling Sequence: 
 *    void
 *
 * Returns:
 *    FALSE - either the tx holding or shift register is not empty
 *   !FALSE - if both the tx holding & shift registers are empty
 *
 *****************************************************************************/
int uart0TxEmpty(void)
{
  return (U0LSR & (ULSR_THRE | ULSR_TEMT)) == (ULSR_THRE | ULSR_TEMT);
     94c:	e59f3014 	ldr	r3, [pc, #20]	; 968 <.text+0x968>
     950:	e5d30000 	ldrb	r0, [r3]
     954:	e2000060 	and	r0, r0, #96	; 0x60
}
     958:	e3500060 	cmp	r0, #96	; 0x60
     95c:	13a00000 	movne	r0, #0	; 0x0
     960:	03a00001 	moveq	r0, #1	; 0x1
     964:	e12fff1e 	bx	lr
     968:	e000c014 	and	ip, r0, r4, lsl r0

0000096c <uart0TxFlush>:

/******************************************************************************
 *
 * Function Name: uart0TxFlush()
 *
 * Description:  
 *    This function removes all characters from the UART transmit queue
 *    (without transmitting them).
 *
 * Calling Sequence: 
 *    void
 *
 * Returns:
 *    void
 *
 *****************************************************************************/
void uart0TxFlush(void)
{
     96c:	e52de004 	str	lr, [sp, #-4]!
#ifdef UART0_TX_INT_MODE
  unsigned cpsr;

  U0FCR |= UFCR_TX_FIFO_RESET;          // clear the TX fifo
     970:	e59f2038 	ldr	r2, [pc, #56]	; 9b0 <.text+0x9b0>
     974:	e5d23000 	ldrb	r3, [r2]
     978:	e3833004 	orr	r3, r3, #4	; 0x4
     97c:	e5c23000 	strb	r3, [r2]

  // "Empty" the transmit buffer.
  cpsr = disableIRQ();                  // disable global interrupts
     980:	eb000084 	bl	b98 <disableIRQ>
  U0IER &= ~UIER_ETBEI;                 // disable TX interrupts
     984:	e59f2028 	ldr	r2, [pc, #40]	; 9b4 <.text+0x9b4>
     988:	e5d23000 	ldrb	r3, [r2]
     98c:	e20330fd 	and	r3, r3, #253	; 0xfd
     990:	e5c23000 	strb	r3, [r2]
  restoreIRQ(cpsr);                     // restore global interrupts
     994:	eb000083 	bl	ba8 <restoreIRQ>
  uart0_tx_insert_idx = uart0_tx_extract_idx = 0;
     998:	e59f3018 	ldr	r3, [pc, #24]	; 9b8 <.text+0x9b8>
     99c:	e3a02000 	mov	r2, #0	; 0x0
     9a0:	e1c320b0 	strh	r2, [r3]
     9a4:	e59f3010 	ldr	r3, [pc, #16]	; 9bc <.text+0x9bc>
     9a8:	e1c320b0 	strh	r2, [r3]
#else
  U0FCR |= UFCR_TX_FIFO_RESET;          // clear the TX fifo
#endif
}
     9ac:	e49df004 	ldr	pc, [sp], #4
     9b0:	e000c008 	and	ip, r0, r8
     9b4:	e000c004 	and	ip, r0, r4
     9b8:	40000138 	andmi	r0, r0, r8, lsr r1
     9bc:	4000013c 	andmi	r0, r0, ip, lsr r1

000009c0 <uart0Getch>:

/******************************************************************************
 *
 * Function Name: uart0Getch()
 *
 * Description:  
 *    This function gets a character from the UART receive queue
 *
 * Calling Sequence: 
 *    void
 *
 * Returns:
 *    character on success, -1 if no character is available
 *
 *****************************************************************************/
int uart0Getch(void)
{
#ifdef UART0_RX_INT_MODE
  uint8_t ch;

  if (uart0_rx_insert_idx == uart0_rx_extract_idx) // check if character is available
     9c0:	e59fc02c 	ldr	ip, [pc, #44]	; 9f4 <.text+0x9f4>
     9c4:	e59f302c 	ldr	r3, [pc, #44]	; 9f8 <.text+0x9f8>
     9c8:	e1dc10b0 	ldrh	r1, [ip]
     9cc:	e1d320b0 	ldrh	r2, [r3]
    return -1;

  ch = uart0_rx_buffer[uart0_rx_extract_idx++]; // get character, bump pointer
     9d0:	e2813001 	add	r3, r1, #1	; 0x1
  uart0_rx_extract_idx %= UART0_RX_BUFFER_SIZE; // limit the pointer
     9d4:	e203303f 	and	r3, r3, #63	; 0x3f
     9d8:	e1520001 	cmp	r2, r1
     9dc:	11cc30b0 	strneh	r3, [ip]
     9e0:	159f3014 	ldrne	r3, [pc, #20]	; 9fc <.text+0x9fc>
     9e4:	17d33001 	ldrneb	r3, [r3, r1]
     9e8:	e3e00000 	mvn	r0, #0	; 0x0
  return ch;
     9ec:	11a00003 	movne	r0, r3
#else
  if (U0LSR & ULSR_RDR)                 // check if character is available
    return U0RBR;                       // return character

  return -1;
#endif
}
     9f0:	e12fff1e 	bx	lr
     9f4:	40000184 	andmi	r0, r0, r4, lsl #3
     9f8:	4000013a 	andmi	r0, r0, sl, lsr r1
     9fc:	40000144 	andmi	r0, r0, r4, asr #2

00000a00 <uart0ISR>:
{
  uint8_t iid;

  // perform proper ISR entry so thumb-interwork works properly
  ISR_ENTRY();
     a00:	e24ee004 	sub	lr, lr, #4	; 0x4
     a04:	e92d5fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
     a08:	e14f1000 	mrs	r1, SPSR
     a0c:	e92d0002 	stmdb	sp!, {r1}

  // loop until not more interrupt sources
  while (((iid = U0IIR) & UIIR_NO_INT) == 0)
    {
    // identify & process the highest priority interrupt
    switch (iid & UIIR_ID_MASK)
      {
      case UIIR_RLS_INT:                // Receive Line Status
        U0LSR;                          // read LSR to clear
        break;

#ifdef UART0_RX_INT_MODE
      case UIIR_CTI_INT:                // Character Timeout Indicator
      case UIIR_RDA_INT:                // Receive Data Available
        do
          {
          uint16_t temp;

          // calc next insert index & store character
          temp = (uart0_rx_insert_idx + 1) % UART0_RX_BUFFER_SIZE;
          uart0_rx_buffer[uart0_rx_insert_idx] = U0RBR;

          // check for more room in queue
          if (temp != uart0_rx_extract_idx)
     a10:	e59f3144 	ldr	r3, [pc, #324]	; b5c <.text+0xb5c>
     a14:	e1d350b0 	ldrh	r5, [r3]
            uart0_rx_insert_idx = temp; // update insert index
          }
        while (U0LSR & ULSR_RDR);

        break;
#endif

#ifdef UART0_TX_INT_MODE
      case UIIR_THRE_INT:               // Transmit Holding Register Empty
        while (U0LSR & ULSR_THRE)
          {
          // check if more data to send
          if (uart0_tx_insert_idx != uart0_tx_extract_idx)
     a18:	e59f3140 	ldr	r3, [pc, #320]	; b60 <.text+0xb60>
     a1c:	e1d340b0 	ldrh	r4, [r3]
     a20:	e59f313c 	ldr	r3, [pc, #316]	; b64 <.text+0xb64>
     a24:	e593e000 	ldr	lr, [r3]
     a28:	e59f3138 	ldr	r3, [pc, #312]	; b68 <.text+0xb68>
     a2c:	e1d300b0 	ldrh	r0, [r3]
     a30:	e59f3134 	ldr	r3, [pc, #308]	; b6c <.text+0xb6c>
     a34:	e1d3c0b0 	ldrh	ip, [r3]
     a38:	ea000037 	b	b1c <.text+0xb1c>
     a3c:	e202300e 	and	r3, r2, #14	; 0xe
     a40:	e2433002 	sub	r3, r3, #2	; 0x2
     a44:	e353000a 	cmp	r3, #10	; 0xa
     a48:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
     a4c:	ea00002e 	b	b0c <.text+0xb0c>
     a50:	00000aec 	andeq	r0, r0, ip, ror #21
     a54:	00000b0c 	andeq	r0, r0, ip, lsl #22
     a58:	00000a84 	andeq	r0, r0, r4, lsl #21
     a5c:	00000b0c 	andeq	r0, r0, ip, lsl #22
     a60:	00000a7c 	andeq	r0, r0, ip, ror sl
     a64:	00000b0c 	andeq	r0, r0, ip, lsl #22
     a68:	00000b0c 	andeq	r0, r0, ip, lsl #22
     a6c:	00000b0c 	andeq	r0, r0, ip, lsl #22
     a70:	00000b0c 	andeq	r0, r0, ip, lsl #22
     a74:	00000b0c 	andeq	r0, r0, ip, lsl #22
     a78:	00000a84 	andeq	r0, r0, r4, lsl #21
     a7c:	e59f30ec 	ldr	r3, [pc, #236]	; b70 <.text+0xb70>
     a80:	ea000024 	b	b18 <.text+0xb18>
     a84:	e28c3001 	add	r3, ip, #1	; 0x1
     a88:	e21311fe 	ands	r1, r3, #-2147483585	; 0x8000003f
     a8c:	e59f30e0 	ldr	r3, [pc, #224]	; b74 <.text+0xb74>
     a90:	42411001 	submi	r1, r1, #1	; 0x1
     a94:	41e01d01 	mvnmi	r1, r1, lsl #26
     a98:	e5d32000 	ldrb	r2, [r3]
     a9c:	e59f30d4 	ldr	r3, [pc, #212]	; b78 <.text+0xb78>
     aa0:	41e01d21 	mvnmi	r1, r1, lsr #26
     aa4:	e7c3200c 	strb	r2, [r3, ip]
     aa8:	42811001 	addmi	r1, r1, #1	; 0x1
     aac:	e59f20bc 	ldr	r2, [pc, #188]	; b70 <.text+0xb70>
     ab0:	e1a03801 	mov	r3, r1, lsl #16
     ab4:	e1a03823 	mov	r3, r3, lsr #16
     ab8:	e5d22000 	ldrb	r2, [r2]
     abc:	e1530005 	cmp	r3, r5
     ac0:	11a0c003 	movne	ip, r3
     ac4:	e3120001 	tst	r2, #1	; 0x1
     ac8:	0a000013 	beq	b1c <.text+0xb1c>
     acc:	eaffffec 	b	a84 <.text+0xa84>
     ad0:	e1540000 	cmp	r4, r0
     ad4:	0a00000a 	beq	b04 <.text+0xb04>
            {
            U0THR = uart0_tx_buffer[uart0_tx_extract_idx++];
     ad8:	e59f309c 	ldr	r3, [pc, #156]	; b7c <.text+0xb7c>
     adc:	e7d32000 	ldrb	r2, [r3, r0]
     ae0:	e59f308c 	ldr	r3, [pc, #140]	; b74 <.text+0xb74>
     ae4:	e5c32000 	strb	r2, [r3]
            uart0_tx_extract_idx %= UART0_TX_BUFFER_SIZE;
     ae8:	e20100ff 	and	r0, r1, #255	; 0xff
     aec:	e59f307c 	ldr	r3, [pc, #124]	; b70 <.text+0xb70>
     af0:	e5d33000 	ldrb	r3, [r3]
     af4:	e3130020 	tst	r3, #32	; 0x20
     af8:	e2801001 	add	r1, r0, #1	; 0x1
     afc:	1afffff3 	bne	ad0 <.text+0xad0>
     b00:	ea000005 	b	b1c <.text+0xb1c>
     b04:	e3a0e000 	mov	lr, #0	; 0x0
     b08:	ea000003 	b	b1c <.text+0xb1c>
            }
          else
            {
            // no
            uart0_tx_running = 0;       // clear running flag
            break;
            }
          }

        break;
#endif // UART0_TX_INT_MODE

      default:                          // Unknown
        U0LSR;
     b0c:	e59f305c 	ldr	r3, [pc, #92]	; b70 <.text+0xb70>
     b10:	e5d33000 	ldrb	r3, [r3]
        U0RBR;
     b14:	e59f3058 	ldr	r3, [pc, #88]	; b74 <.text+0xb74>
     b18:	e5d33000 	ldrb	r3, [r3]
     b1c:	e59f305c 	ldr	r3, [pc, #92]	; b80 <.text+0xb80>
     b20:	e5d32000 	ldrb	r2, [r3]
     b24:	e2223001 	eor	r3, r2, #1	; 0x1
     b28:	e2131001 	ands	r1, r3, #1	; 0x1
     b2c:	1affffc2 	bne	a3c <uart0ISR+0x3c>
     b30:	e59f302c 	ldr	r3, [pc, #44]	; b64 <.text+0xb64>
     b34:	e583e000 	str	lr, [r3]
     b38:	e59f3028 	ldr	r3, [pc, #40]	; b68 <.text+0xb68>
     b3c:	e1c300b0 	strh	r0, [r3]
     b40:	e59f3024 	ldr	r3, [pc, #36]	; b6c <.text+0xb6c>
     b44:	e1c3c0b0 	strh	ip, [r3]
        break;
      }
    }

  VICVectAddr = 0x00000000;             // clear this interrupt from the VIC
     b48:	e59f3034 	ldr	r3, [pc, #52]	; b84 <.text+0xb84>
     b4c:	e5831000 	str	r1, [r3]
  ISR_EXIT();                           // recover registers and return
     b50:	e8bd0002 	ldmia	sp!, {r1}
     b54:	e161f001 	msr	SPSR_c, r1
     b58:	e8fd9fff 	ldmia	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, pc}^
}
     b5c:	40000184 	andmi	r0, r0, r4, lsl #3
     b60:	40000138 	andmi	r0, r0, r8, lsr r1
     b64:	40000140 	andmi	r0, r0, r0, asr #2
     b68:	4000013c 	andmi	r0, r0, ip, lsr r1
     b6c:	4000013a 	andmi	r0, r0, sl, lsr r1
     b70:	e000c014 	and	ip, r0, r4, lsl r0
     b74:	e000c000 	and	ip, r0, r0
     b78:	40000144 	andmi	r0, r0, r4, asr #2
     b7c:	40000038 	andmi	r0, r0, r8, lsr r0
     b80:	e000c008 	and	ip, r0, r8
     b84:	fffff030 	swinv	0x00fff030

00000b88 <enableFIQ>:

static inline unsigned __get_cpsr(void)
{
  unsigned long retval;
  asm volatile (" mrs  %0, cpsr" : "=r" (retval) : /* no inputs */  );
     b88:	e10f0000 	mrs	r0, CPSR
  return retval;
}

static inline void __set_cpsr(unsigned val)
{
  asm volatile (" msr  cpsr, %0" : /* no outputs */ : "r" (val)  );
     b8c:	e3c03040 	bic	r3, r0, #64	; 0x40
     b90:	e129f003 	msr	CPSR_fc, r3
}

unsigned disableIRQ(void)
{
  unsigned _cpsr;

  _cpsr = __get_cpsr();
  __set_cpsr(_cpsr | IRQ_MASK);
  return _cpsr;
}

unsigned restoreIRQ(unsigned oldCPSR)
{
  unsigned _cpsr;

  _cpsr = __get_cpsr();
  __set_cpsr((_cpsr & ~IRQ_MASK) | (oldCPSR & IRQ_MASK));
  return _cpsr;
}

unsigned enableIRQ(void)
{
  unsigned _cpsr;

  _cpsr = __get_cpsr();
  __set_cpsr(_cpsr & ~IRQ_MASK);
  return _cpsr;
}

unsigned disableFIQ(void)
{
  unsigned _cpsr;

  _cpsr = __get_cpsr();
  __set_cpsr(_cpsr | FIQ_MASK);
  return _cpsr;
}

unsigned restoreFIQ(unsigned oldCPSR)
{
  unsigned _cpsr;

  _cpsr = __get_cpsr();
  __set_cpsr((_cpsr & ~FIQ_MASK) | (oldCPSR & FIQ_MASK));
  return _cpsr;
}

unsigned enableFIQ(void)
{
  unsigned _cpsr;

  _cpsr = __get_cpsr();
  __set_cpsr(_cpsr & ~FIQ_MASK);
  return _cpsr;
}
     b94:	e12fff1e 	bx	lr

00000b98 <disableIRQ>:
     b98:	e10f0000 	mrs	r0, CPSR
     b9c:	e3803080 	orr	r3, r0, #128	; 0x80
     ba0:	e129f003 	msr	CPSR_fc, r3
     ba4:	e12fff1e 	bx	lr

00000ba8 <restoreIRQ>:
     ba8:	e10f2000 	mrs	r2, CPSR
     bac:	e2000080 	and	r0, r0, #128	; 0x80
     bb0:	e3c23080 	bic	r3, r2, #128	; 0x80
     bb4:	e1833000 	orr	r3, r3, r0
     bb8:	e129f003 	msr	CPSR_fc, r3
     bbc:	e1a00002 	mov	r0, r2
     bc0:	e12fff1e 	bx	lr

00000bc4 <enableIRQ>:
     bc4:	e10f0000 	mrs	r0, CPSR
     bc8:	e3c03080 	bic	r3, r0, #128	; 0x80
     bcc:	e129f003 	msr	CPSR_fc, r3
     bd0:	e12fff1e 	bx	lr

00000bd4 <disableFIQ>:
     bd4:	e10f0000 	mrs	r0, CPSR
     bd8:	e3803040 	orr	r3, r0, #64	; 0x40
     bdc:	e129f003 	msr	CPSR_fc, r3
     be0:	e12fff1e 	bx	lr

00000be4 <restoreFIQ>:
     be4:	e10f2000 	mrs	r2, CPSR
     be8:	e2000040 	and	r0, r0, #64	; 0x40
     bec:	e3c23040 	bic	r3, r2, #64	; 0x40
     bf0:	e1833000 	orr	r3, r3, r0
     bf4:	e129f003 	msr	CPSR_fc, r3
     bf8:	e1a00002 	mov	r0, r2
     bfc:	e12fff1e 	bx	lr

00000c00 <ow_input_pin_state>:
#define OW_DIR_OUT()  ( IODIR0 |= OW_BIT )

uint8_t ow_input_pin_state()
{
	return OW_GET_IN();
     c00:	e59f3008 	ldr	r3, [pc, #8]	; c10 <.text+0xc10>
     c04:	e5933000 	ldr	r3, [r3]
}
     c08:	e3a00000 	mov	r0, #0	; 0x0
     c0c:	e12fff1e 	bx	lr
     c10:	e0028000 	and	r8, r2, r0

00000c14 <ow_parasite_enable>:

void ow_parasite_enable(void)
{
	
}
     c14:	e12fff1e 	bx	lr

00000c18 <ow_delay_debug>:

void ow_delay_debug(void)
{
     c18:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
	OW_OUT_LOW(); // disable internal pull-up (maybe on from parasite)
     c1c:	e59f704c 	ldr	r7, [pc, #76]	; c70 <.text+0xc70>
     c20:	e3a05802 	mov	r5, #131072	; 0x20000
	OW_DIR_OUT(); // pull OW-Pin low for 480us
     c24:	e59f4048 	ldr	r4, [pc, #72]	; c74 <.text+0xc74>
     c28:	e5875000 	str	r5, [r7]
     c2c:	e5943000 	ldr	r3, [r4]
	delay_us(100);
     c30:	e59f6040 	ldr	r6, [pc, #64]	; c78 <.text+0xc78>
     c34:	e1833005 	orr	r3, r3, r5
     c38:	e1a00006 	mov	r0, r6
     c3c:	e5843000 	str	r3, [r4]
     c40:	eb00017a 	bl	1230 <delay_us_>
	OW_OUT_HIGH();
     c44:	e59f3030 	ldr	r3, [pc, #48]	; c7c <.text+0xc7c>
	delay_us(500);
     c48:	e59f0030 	ldr	r0, [pc, #48]	; c80 <.text+0xc80>
     c4c:	e5835000 	str	r5, [r3]
     c50:	eb000176 	bl	1230 <delay_us_>
	OW_OUT_LOW();
	delay_us(100);
     c54:	e1a00006 	mov	r0, r6
     c58:	e5875000 	str	r5, [r7]
     c5c:	eb000173 	bl	1230 <delay_us_>
	OW_DIR_IN(); // pull OW-Pin low for 480us
     c60:	e5943000 	ldr	r3, [r4]
     c64:	e3c33802 	bic	r3, r3, #131072	; 0x20000
     c68:	e5843000 	str	r3, [r4]
}
     c6c:	e8bd80f0 	ldmia	sp!, {r4, r5, r6, r7, pc}
     c70:	e002800c 	and	r8, r2, ip
     c74:	e0028008 	and	r8, r2, r8
     c78:	000005a2 	andeq	r0, r0, r2, lsr #11
     c7c:	e0028004 	and	r8, r2, r4
     c80:	00001c2b 	andeq	r1, r0, fp, lsr #24

00000c84 <ow_reset>:

uint8_t ow_reset(void)
{
     c84:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
	uint8_t err;
	unsigned mycpsr;
	
	OW_OUT_LOW(); // disable internal pull-up (maybe on from parasite)
     c88:	e59f3064 	ldr	r3, [pc, #100]	; cf4 <.text+0xcf4>
     c8c:	e3a02802 	mov	r2, #131072	; 0x20000
     c90:	e5832000 	str	r2, [r3]
	OW_DIR_OUT(); // pull OW-Pin low for 480us
     c94:	e59f405c 	ldr	r4, [pc, #92]	; cf8 <.text+0xcf8>
     c98:	e5943000 	ldr	r3, [r4]
     c9c:	e1833002 	orr	r3, r3, r2
     ca0:	e5843000 	str	r3, [r4]
	
	delay_us(480);
     ca4:	e59f0050 	ldr	r0, [pc, #80]	; cfc <.text+0xcfc>
     ca8:	eb000160 	bl	1230 <delay_us_>
	
	mycpsr = disableIRQ();
     cac:	ebffffb9 	bl	b98 <disableIRQ>
	
	// set Pin as input - wait for clients to pull low
	OW_DIR_IN(); // input
     cb0:	e5943000 	ldr	r3, [r4]
     cb4:	e3c33802 	bic	r3, r3, #131072	; 0x20000
     cb8:	e1a06000 	mov	r6, r0
	
	delay_us(66);
	err = OW_GET_IN();		// no presence detect
     cbc:	e59f503c 	ldr	r5, [pc, #60]	; d00 <.text+0xd00>
     cc0:	e5843000 	str	r3, [r4]
     cc4:	e59f0038 	ldr	r0, [pc, #56]	; d04 <.text+0xd04>
     cc8:	eb000158 	bl	1230 <delay_us_>
	// nobody pulled to low, still high
	
	restoreIRQ(mycpsr);
     ccc:	e1a00006 	mov	r0, r6
     cd0:	e5953000 	ldr	r3, [r5]
     cd4:	ebffffb3 	bl	ba8 <restoreIRQ>
	
	// after a delay the clients should release the line
	// and input-pin gets back to high due to pull-up-resistor
	delay_us(480-66);
     cd8:	e59f0028 	ldr	r0, [pc, #40]	; d08 <.text+0xd08>
     cdc:	eb000153 	bl	1230 <delay_us_>
	if( OW_GET_IN() == 0 )		// short circuit
     ce0:	e5950000 	ldr	r0, [r5]
     ce4:	e1a008a0 	mov	r0, r0, lsr #17
     ce8:	e2200001 	eor	r0, r0, #1	; 0x1
		err = 1;
	
	return err;
}
     cec:	e2000001 	and	r0, r0, #1	; 0x1
     cf0:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
     cf4:	e002800c 	and	r8, r2, ip
     cf8:	e0028008 	and	r8, r2, r8
     cfc:	00001b0c 	andeq	r1, r0, ip, lsl #22
     d00:	e0028000 	and	r8, r2, r0
     d04:	000003b7 	streqh	r0, [r0], -r7
     d08:	00001bee 	andeq	r1, r0, lr, ror #23

00000d0c <ow_bit_io>:

/* Timing issue when using runtime-bus-selection (!OW_ONE_BUS):
   The master should sample at the end of the 15-slot after initiating
   the read-time-slot. The variable bus-settings need more
   cycles than the constant ones so the delays had to be shortened 
   to achive a 15uS overall delay 
   Setting/clearing a bit in I/O Register needs 1 cyle in OW_ONE_BUS
   but around 14 cyles in configureable bus (us-Delay is 4 cyles per uS) */
uint8_t ow_bit_io( uint8_t b )
{
     d0c:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
     d10:	e20040ff 	and	r4, r0, #255	; 0xff
	unsigned mycpsr;
	
	mycpsr = disableIRQ();
     d14:	ebffff9f 	bl	b98 <disableIRQ>
	
	OW_DIR_OUT(); // drive bus low
     d18:	e59f5060 	ldr	r5, [pc, #96]	; d80 <.text+0xd80>
     d1c:	e5953000 	ldr	r3, [r5]
     d20:	e3833802 	orr	r3, r3, #131072	; 0x20000
     d24:	e5853000 	str	r3, [r5]
     d28:	e1a06000 	mov	r6, r0
	
	delay_us(1); // Recovery-Time wuffwuff was 1
     d2c:	e3a0000e 	mov	r0, #14	; 0xe
     d30:	eb00013e 	bl	1230 <delay_us_>
	if ( b ) OW_DIR_IN(); // if bit is 1 set bus high (by ext. pull-up)
     d34:	e3540000 	cmp	r4, #0	; 0x0
     d38:	15953000 	ldrne	r3, [r5]
     d3c:	13c33802 	bicne	r3, r3, #131072	; 0x20000
     d40:	15853000 	strne	r3, [r5]
		
	// wuffwuff delay was 15uS-1 see comment above
	delay_us(15-1-OW_CONF_DELAYOFFSET);
     d44:	e3a000d8 	mov	r0, #216	; 0xd8
     d48:	eb000138 	bl	1230 <delay_us_>
		
	if( OW_GET_IN() == 0 ) b = 0;  // sample at end of read-timeslot
     d4c:	e59f3030 	ldr	r3, [pc, #48]	; d84 <.text+0xd84>
     d50:	e5933000 	ldr	r3, [r3]
	
	delay_us(60-15);
     d54:	e59f002c 	ldr	r0, [pc, #44]	; d88 <.text+0xd88>
     d58:	e2133802 	ands	r3, r3, #131072	; 0x20000
     d5c:	01a04003 	moveq	r4, r3
     d60:	eb000132 	bl	1230 <delay_us_>
	OW_DIR_IN();
     d64:	e5953000 	ldr	r3, [r5]
     d68:	e3c33802 	bic	r3, r3, #131072	; 0x20000
	
	restoreIRQ(mycpsr);
     d6c:	e1a00006 	mov	r0, r6
     d70:	e5853000 	str	r3, [r5]
     d74:	ebffff8b 	bl	ba8 <restoreIRQ>
	
	return b;
}
     d78:	e1a00004 	mov	r0, r4
     d7c:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
     d80:	e0028008 	and	r8, r2, r8
     d84:	e0028000 	and	r8, r2, r0
     d88:	00000361 	andeq	r0, r0, r1, ror #6

00000d8c <ow_byte_wr>:


uint8_t ow_byte_wr( uint8_t b )
{
     d8c:	e92d4030 	stmdb	sp!, {r4, r5, lr}
     d90:	e20040ff 	and	r4, r0, #255	; 0xff
     d94:	e3a05008 	mov	r5, #8	; 0x8
	uint8_t i = 8, j;
	
	do {
		j = ow_bit_io( b & 1 );
     d98:	e2040001 	and	r0, r4, #1	; 0x1
     d9c:	ebffffda 	bl	d0c <ow_bit_io>
		b >>= 1;
     da0:	e1a040a4 	mov	r4, r4, lsr #1
		if( j ) b |= 0x80;
     da4:	e1e03c84 	mvn	r3, r4, lsl #25
     da8:	e3500000 	cmp	r0, #0	; 0x0
	} while( --i );
     dac:	e2452001 	sub	r2, r5, #1	; 0x1
     db0:	e1e03ca3 	mvn	r3, r3, lsr #25
     db4:	120340ff 	andne	r4, r3, #255	; 0xff
     db8:	e21250ff 	ands	r5, r2, #255	; 0xff
     dbc:	1afffff5 	bne	d98 <ow_byte_wr+0xc>
	
	return b;
}
     dc0:	e1a00004 	mov	r0, r4
     dc4:	e8bd8030 	ldmia	sp!, {r4, r5, pc}

00000dc8 <ow_byte_rd>:


uint8_t ow_byte_rd( void )
{
     dc8:	e52de004 	str	lr, [sp, #-4]!
  // read by sending 0xff (a dontcare?)
  return ow_byte_wr( 0xFF ); 
     dcc:	e3a000ff 	mov	r0, #255	; 0xff
     dd0:	ebffffed 	bl	d8c <ow_byte_wr>
}
     dd4:	e49df004 	ldr	pc, [sp], #4

00000dd8 <ow_rom_search>:


uint8_t ow_rom_search( uint8_t diff, uint8_t *id )
{
     dd8:	e92d45f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, lr}
     ddc:	e1a05001 	mov	r5, r1
     de0:	e20080ff 	and	r8, r0, #255	; 0xff
	uint8_t i, j, next_diff;
	uint8_t b;
	
	if( ow_reset() ) return OW_PRESENCE_ERR;	// error, no device found
     de4:	ebffffa6 	bl	c84 <ow_reset>
     de8:	e2504000 	subs	r4, r0, #0	; 0x0
     dec:	13a000ff 	movne	r0, #255	; 0xff
     df0:	18bd85f0 	ldmneia	sp!, {r4, r5, r6, r7, r8, sl, pc}
	
	ow_byte_wr( OW_SEARCH_ROM );			// ROM search command
     df4:	e3a000f0 	mov	r0, #240	; 0xf0
     df8:	ebffffe3 	bl	d8c <ow_byte_wr>
     dfc:	e2855001 	add	r5, r5, #1	; 0x1
     e00:	e1a0a004 	mov	sl, r4
     e04:	e3a06040 	mov	r6, #64	; 0x40
     e08:	e3a07008 	mov	r7, #8	; 0x8
	next_diff = OW_LAST_DEVICE;			// unchanged on last device
	
	i = OW_ROMCODE_SIZE * 8;					// 8 bytes
	
	do {
		j = 8;					// 8 bits
		do {
			b = ow_bit_io( 1 );			// read bit
     e0c:	e3a00001 	mov	r0, #1	; 0x1
     e10:	ebffffbd 	bl	d0c <ow_bit_io>
     e14:	e1a04000 	mov	r4, r0
			if( ow_bit_io( 1 ) ) {			// read complement bit
     e18:	e3a00001 	mov	r0, #1	; 0x1
     e1c:	ebffffba 	bl	d0c <ow_bit_io>
     e20:	e3500000 	cmp	r0, #0	; 0x0
     e24:	0a000003 	beq	e38 <ow_rom_search+0x60>
				if( b )					// 11
     e28:	e3540000 	cmp	r4, #0	; 0x0
     e2c:	0a00000c 	beq	e64 <ow_rom_search+0x8c>
     e30:	e3a000fe 	mov	r0, #254	; 0xfe
     e34:	e8bd85f0 	ldmia	sp!, {r4, r5, r6, r7, r8, sl, pc}
				return OW_DATA_ERR;			// data error
			}
			else {
				if( !b ) {				// 00 = 2 devices
     e38:	e3540000 	cmp	r4, #0	; 0x0
     e3c:	1a000008 	bne	e64 <ow_rom_search+0x8c>
					if( diff > i || ((*id & 1) && diff != i) ) {
     e40:	e1580006 	cmp	r8, r6
     e44:	8a000004 	bhi	e5c <ow_rom_search+0x84>
     e48:	e5553001 	ldrb	r3, [r5, #-1]
     e4c:	03a03000 	moveq	r3, #0	; 0x0
     e50:	12033001 	andne	r3, r3, #1	; 0x1
     e54:	e3530000 	cmp	r3, #0	; 0x0
     e58:	0a000001 	beq	e64 <ow_rom_search+0x8c>
     e5c:	e3a04001 	mov	r4, #1	; 0x1
     e60:	e1a0a006 	mov	sl, r6
					b = 1;				// now 1
					next_diff = i;			// next pass 0
					}
				}
			}
			ow_bit_io( b );     			// write bit
     e64:	e1a00004 	mov	r0, r4
     e68:	ebffffa7 	bl	d0c <ow_bit_io>
			*id >>= 1;
			if( b ) *id |= 0x80;			// store bit
			
			i--;
     e6c:	e2463001 	sub	r3, r6, #1	; 0x1
     e70:	e20360ff 	and	r6, r3, #255	; 0xff
     e74:	e5553001 	ldrb	r3, [r5, #-1]
     e78:	e1a030a3 	mov	r3, r3, lsr #1
     e7c:	e1e02c83 	mvn	r2, r3, lsl #25
     e80:	e3540000 	cmp	r4, #0	; 0x0
			
		} while( --j );
     e84:	e2471001 	sub	r1, r7, #1	; 0x1
     e88:	e1e02ca2 	mvn	r2, r2, lsr #25
     e8c:	e5453001 	strb	r3, [r5, #-1]
     e90:	15452001 	strneb	r2, [r5, #-1]
     e94:	e21170ff 	ands	r7, r1, #255	; 0xff
     e98:	1affffdb 	bne	e0c <ow_rom_search+0x34>
		
		id++;					// next byte
	
	} while( i );
     e9c:	e3560000 	cmp	r6, #0	; 0x0
     ea0:	e2855001 	add	r5, r5, #1	; 0x1
     ea4:	1affffd7 	bne	e08 <ow_rom_search+0x30>
	
	return next_diff;				// to continue search
     ea8:	e1a0000a 	mov	r0, sl
}
     eac:	e8bd85f0 	ldmia	sp!, {r4, r5, r6, r7, r8, sl, pc}

00000eb0 <ow_command>:


void ow_command( uint8_t command, uint8_t *id )
{
     eb0:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
     eb4:	e1a04001 	mov	r4, r1
     eb8:	e20060ff 	and	r6, r0, #255	; 0xff
	uint8_t i;

	ow_reset();
     ebc:	ebffff70 	bl	c84 <ow_reset>

	if( id ) {
     ec0:	e3540000 	cmp	r4, #0	; 0x0
     ec4:	0a000008 	beq	eec <ow_command+0x3c>
		ow_byte_wr( OW_MATCH_ROM );			// to a single device
     ec8:	e3a00055 	mov	r0, #85	; 0x55
     ecc:	ebffffae 	bl	d8c <ow_byte_wr>
     ed0:	e3a05008 	mov	r5, #8	; 0x8
		i = OW_ROMCODE_SIZE;
		do {
			ow_byte_wr( *id );
     ed4:	e4d40001 	ldrb	r0, [r4], #1
     ed8:	ebffffab 	bl	d8c <ow_byte_wr>
			id++;
		} while( --i );
     edc:	e2453001 	sub	r3, r5, #1	; 0x1
     ee0:	e21350ff 	ands	r5, r3, #255	; 0xff
     ee4:	0a000002 	beq	ef4 <ow_command+0x44>
     ee8:	eafffff9 	b	ed4 <ow_command+0x24>
	} 
	else {
		ow_byte_wr( OW_SKIP_ROM );			// to all devices
     eec:	e3a000cc 	mov	r0, #204	; 0xcc
     ef0:	ebffffa5 	bl	d8c <ow_byte_wr>
	}
	
	ow_byte_wr( command );
     ef4:	e1a00006 	mov	r0, r6
}
     ef8:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
     efc:	eaffffa2 	b	d8c <ow_byte_wr>

00000f00 <crc8>:
#define CRC8INIT	0x00
#define CRC8POLY	0x18              //0X18 = X^8+X^5+X^4+X^0

uint8_t	crc8 ( uint8_t *data_in, uint16_t number_of_bytes_to_read )
{
     f00:	e92d4010 	stmdb	sp!, {r4, lr}
     f04:	e1a01801 	mov	r1, r1, lsl #16
     f08:	e3a02000 	mov	r2, #0	; 0x0
     f0c:	e1a04000 	mov	r4, r0
     f10:	e1a00821 	mov	r0, r1, lsr #16
     f14:	e1a01002 	mov	r1, r2
     f18:	ea000010 	b	f60 <crc8+0x60>
	uint8_t	 crc;
	uint16_t loop_count;
	uint8_t  bit_counter;
	uint8_t  data;
	uint8_t  feedback_bit;
	
	crc = CRC8INIT;

	for (loop_count = 0; loop_count != number_of_bytes_to_read; loop_count++)
	{
		data = data_in[loop_count];
     f1c:	e7d4c001 	ldrb	ip, [r4, r1]
     f20:	e3a03008 	mov	r3, #8	; 0x8
		
		bit_counter = 8;
		do {
			feedback_bit = (crc ^ data) & 0x01;
	
			if ( feedback_bit == 0x01 ) {
				crc = crc ^ CRC8POLY;
			}
			crc = (crc >> 1) & 0x7F;
			if ( feedback_bit == 0x01 ) {
				crc = crc | 0x80;
			}
		
			data = data >> 1;
     f24:	e243e001 	sub	lr, r3, #1	; 0x1
     f28:	e022300c 	eor	r3, r2, ip
     f2c:	e2033001 	and	r3, r3, #1	; 0x1
     f30:	e3530001 	cmp	r3, #1	; 0x1
     f34:	02222018 	eoreq	r2, r2, #24	; 0x18
     f38:	e1a020a2 	mov	r2, r2, lsr #1
     f3c:	01e03c82 	mvneq	r3, r2, lsl #25
     f40:	01e03ca3 	mvneq	r3, r3, lsr #25
     f44:	020320ff 	andeq	r2, r3, #255	; 0xff
			bit_counter--;
		
		} while (bit_counter > 0);
     f48:	e21e30ff 	ands	r3, lr, #255	; 0xff
     f4c:	e1a0c0ac 	mov	ip, ip, lsr #1
     f50:	1afffff3 	bne	f24 <crc8+0x24>
     f54:	e2813001 	add	r3, r1, #1	; 0x1
     f58:	e1a03803 	mov	r3, r3, lsl #16
     f5c:	e1a01823 	mov	r1, r3, lsr #16
     f60:	e1510000 	cmp	r1, r0
     f64:	1affffec 	bne	f1c <crc8+0x1c>
	}
	
	return crc;
}
     f68:	e1a00002 	mov	r0, r2
     f6c:	e8bd8010 	ldmia	sp!, {r4, pc}

00000f70 <DS18X20_meas_to_cel>:
   TODO invalid-values detection (but should be covered by CRC)
*/
uint8_t DS18X20_meas_to_cel( uint8_t fc, uint8_t *sp, 
	uint8_t* subzero, uint8_t* cel, uint8_t* cel_frac_bits)
{
     f70:	e92d4010 	stmdb	sp!, {r4, lr}
     f74:	e1a0c001 	mov	ip, r1
     f78:	e200e0ff 	and	lr, r0, #255	; 0xff
	uint16_t meas;
	uint8_t  i;
	
	meas = sp[0];  // LSB
	meas |= ((uint16_t)sp[1])<<8; // MSB
     f7c:	e5d10000 	ldrb	r0, [r1]
     f80:	e5d11001 	ldrb	r1, [r1, #1]
	//meas = 0xff5e; meas = 0xfe6f;
	
	//  only work on 12bit-base
	//  TODO: DS18S20 "additional values"
	if( fc == DS18S20_ID ) { // 9 -> 12 bit if 18S20
     f84:	e35e0010 	cmp	lr, #16	; 0x10
     f88:	e1800401 	orr	r0, r0, r1, lsl #8
     f8c:	e1a04003 	mov	r4, r3
		meas <<= 3;
     f90:	01a03980 	moveq	r3, r0, lsl #19
     f94:	01a00823 	moveq	r0, r3, lsr #16
	}
	
	// check for negative 
	if ( meas & 0x8000 )  {
     f98:	e3100902 	tst	r0, #32768	; 0x8000
		*subzero=1;      // mark negative
		meas ^= 0xffff;  // convert to positive => (twos complement)++
     f9c:	11e03000 	mvnne	r3, r0
     fa0:	11a03803 	movne	r3, r3, lsl #16
		meas++;
     fa4:	12833801 	addne	r3, r3, #65536	; 0x10000
     fa8:	11a00823 	movne	r0, r3, lsr #16
	}
	else *subzero=0;
     fac:	03a03000 	moveq	r3, #0	; 0x0
     fb0:	13a03001 	movne	r3, #1	; 0x1
	
	// clear undefined bits for B != 12bit
	if ( fc == DS18B20_ID ) { // check resolution 18B20
     fb4:	e35e0028 	cmp	lr, #40	; 0x28
     fb8:	e5c23000 	strb	r3, [r2]
     fbc:	1a00000b 	bne	ff0 <DS18X20_meas_to_cel+0x80>
		i = sp[DS18B20_CONF_REG];
     fc0:	e5dc1004 	ldrb	r1, [ip, #4]
		if ( (i & DS18B20_12_BIT) == DS18B20_12_BIT ) ;
     fc4:	e2013060 	and	r3, r1, #96	; 0x60
     fc8:	e3530060 	cmp	r3, #96	; 0x60
     fcc:	0a000007 	beq	ff0 <DS18X20_meas_to_cel+0x80>
		else if ( (i & DS18B20_11_BIT) == DS18B20_11_BIT ) 
     fd0:	e3110040 	tst	r1, #64	; 0x40
			meas &= ~(DS18B20_11_BIT_UNDF);
     fd4:	13c00001 	bicne	r0, r0, #1	; 0x1
     fd8:	1a000002 	bne	fe8 <DS18X20_meas_to_cel+0x78>
		else if ( (i & DS18B20_10_BIT) == DS18B20_10_BIT ) 
     fdc:	e3110020 	tst	r1, #32	; 0x20
			meas &= ~(DS18B20_10_BIT_UNDF);
     fe0:	13c00003 	bicne	r0, r0, #3	; 0x3
		else { // if ( (i & DS18B20_9_BIT) == DS18B20_9_BIT ) { 
			meas &= ~(DS18B20_9_BIT_UNDF);
     fe4:	03c00007 	biceq	r0, r0, #7	; 0x7
     fe8:	e1a00800 	mov	r0, r0, lsl #16
     fec:	e1a00820 	mov	r0, r0, lsr #16
		}
	}			
	
	*cel  = (uint8_t)(meas >> 4); 
     ff0:	e1a02220 	mov	r2, r0, lsr #4
     ff4:	e5c42000 	strb	r2, [r4]
	*cel_frac_bits = (uint8_t)(meas & 0x000F);
     ff8:	e59d2008 	ldr	r2, [sp, #8]
     ffc:	e200300f 	and	r3, r0, #15	; 0xf
	
	return DS18X20_OK;
}
    1000:	e3a00000 	mov	r0, #0	; 0x0
    1004:	e5c23000 	strb	r3, [r2]
    1008:	e8bd8010 	ldmia	sp!, {r4, pc}

0000100c <DS18X20_temp_to_decicel>:

/* converts to decicelsius
   input is ouput from meas_to_cel
   returns absolute value of temperatur in decicelsius
	i.e.: sz=0, c=28, frac=15 returns 289 (=28.9°C)
0	0	0	
1	625	625	1
2	1250	250	
3	1875	875	3
4	2500	500	4
5	3125	125	
6	3750	750	6
7	4375	375	
8	5000	0	
9	5625	625	9
10	6250	250	
11	6875	875	11
12	7500	500	12
13	8125	125	
14	8750	750	14
15	9375	375	*/
uint16_t DS18X20_temp_to_decicel(uint8_t subzero, uint8_t cel, 
	uint8_t cel_frac_bits)
{
    100c:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
    1010:	e24dd008 	sub	sp, sp, #8	; 0x8
    1014:	e1a03000 	mov	r3, r0
    1018:	e1a0c002 	mov	ip, r2
    101c:	e1a04001 	mov	r4, r1
	uint16_t h;
	uint8_t  i;
	uint8_t need_rounding[] = { 1, 3, 4, 6, 9, 11, 12, 14 };
    1020:	e3a02008 	mov	r2, #8	; 0x8
    1024:	e59f1068 	ldr	r1, [pc, #104]	; 1094 <.text+0x1094>
    1028:	e1a0000d 	mov	r0, sp
    102c:	e20350ff 	and	r5, r3, #255	; 0xff
    1030:	e20c60ff 	and	r6, ip, #255	; 0xff
    1034:	eb0000be 	bl	1334 <memcpy>
	
	h = cel_frac_bits*DS18X20_FRACCONV/1000;
	h += cel*10;
    1038:	e59f3058 	ldr	r3, [pc, #88]	; 1098 <.text+0x1098>
    103c:	e3a01ffa 	mov	r1, #1000	; 0x3e8
    1040:	e0000396 	mul	r0, r6, r3
    1044:	eb000129 	bl	14f0 <__divsi3>
    1048:	e20440ff 	and	r4, r4, #255	; 0xff
    104c:	e3a0300a 	mov	r3, #10	; 0xa
    1050:	e0230394 	mla	r3, r4, r3, r0
	if (!subzero) {
    1054:	e3550000 	cmp	r5, #0	; 0x0
    1058:	e1a03803 	mov	r3, r3, lsl #16
    105c:	e1a00823 	mov	r0, r3, lsr #16
    1060:	1a000009 	bne	108c <DS18X20_temp_to_decicel+0x80>
    1064:	e1a02005 	mov	r2, r5
		for (i=0; i<sizeof(need_rounding); i++) {
			if ( cel_frac_bits == need_rounding[i] ) {
    1068:	e7d2300d 	ldrb	r3, [r2, sp]
    106c:	e1530006 	cmp	r3, r6
				h++;
				break;
    1070:	e2822001 	add	r2, r2, #1	; 0x1
    1074:	02803001 	addeq	r3, r0, #1	; 0x1
    1078:	01a03803 	moveq	r3, r3, lsl #16
    107c:	01a00823 	moveq	r0, r3, lsr #16
    1080:	0a000001 	beq	108c <DS18X20_temp_to_decicel+0x80>
    1084:	e3520008 	cmp	r2, #8	; 0x8
    1088:	1afffff6 	bne	1068 <DS18X20_temp_to_decicel+0x5c>
			}
		}
	}
	return h;
}
    108c:	e28dd008 	add	sp, sp, #8	; 0x8
    1090:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
    1094:	000020a8 	andeq	r2, r0, r8, lsr #1
    1098:	00000271 	andeq	r0, r0, r1, ror r2

0000109c <DS18X20_temp_cmp>:

/* compare temperature values (full celsius only)
   returns -1 if param-pair1 < param-pair2 
            0 if == 
			1 if >    */
int8_t DS18X20_temp_cmp(uint8_t subzero1, uint16_t cel1, 
	uint8_t subzero2, uint16_t cel2)
{
    109c:	e1a01801 	mov	r1, r1, lsl #16
    10a0:	e1a03803 	mov	r3, r3, lsl #16
	int16_t t1 = (subzero1) ? (cel1*(-1)) : (cel1);
    10a4:	e31000ff 	tst	r0, #255	; 0xff
    10a8:	e1a01821 	mov	r1, r1, lsr #16
    10ac:	e20200ff 	and	r0, r2, #255	; 0xff
    10b0:	e1a02823 	mov	r2, r3, lsr #16
    10b4:	12613000 	rsbne	r3, r1, #0	; 0x0
    10b8:	11a03803 	movne	r3, r3, lsl #16
    10bc:	11a01823 	movne	r1, r3, lsr #16
	int16_t t2 = (subzero2) ? (cel2*(-1)) : (cel2);
    10c0:	e3500000 	cmp	r0, #0	; 0x0
    10c4:	12623000 	rsbne	r3, r2, #0	; 0x0
    10c8:	11a03803 	movne	r3, r3, lsl #16
    10cc:	11a02823 	movne	r2, r3, lsr #16
	
	if (t1<t2) return -1;
    10d0:	e1a03801 	mov	r3, r1, lsl #16
    10d4:	e1a03843 	mov	r3, r3, asr #16
    10d8:	e1a02802 	mov	r2, r2, lsl #16
    10dc:	e1530842 	cmp	r3, r2, asr #16
    10e0:	b3e00000 	mvnlt	r0, #0	; 0x0
    10e4:	b12fff1e 	bxlt	lr
	if (t1>t2) return 1;
    10e8:	c3a00001 	movgt	r0, #1	; 0x1
    10ec:	d3a00000 	movle	r0, #0	; 0x0
	return 0;
}
    10f0:	e12fff1e 	bx	lr

000010f4 <DS18X20_find_sensor>:

/* find DS18X20 Sensors on 1-Wire-Bus
   input/ouput: diff is the result of the last rom-search
   output: id is the rom-code of the sensor found */
void DS18X20_find_sensor(uint8_t *diff, uint8_t id[])
{
    10f4:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    10f8:	e1a05000 	mov	r5, r0
    10fc:	e1a04001 	mov	r4, r1
	for (;;) {
		*diff = ow_rom_search( *diff, &id[0] );
    1100:	e5d50000 	ldrb	r0, [r5]
    1104:	e1a01004 	mov	r1, r4
    1108:	ebffff32 	bl	dd8 <ow_rom_search>
		
		if ( *diff==OW_PRESENCE_ERR ) return;
    110c:	e35000ff 	cmp	r0, #255	; 0xff
    1110:	e5c50000 	strb	r0, [r5]
    1114:	08bd8030 	ldmeqia	sp!, {r4, r5, pc}
		if ( *diff==OW_DATA_ERR ) return;
    1118:	e35000fe 	cmp	r0, #254	; 0xfe
    111c:	08bd8030 	ldmeqia	sp!, {r4, r5, pc}
		if ( *diff == OW_LAST_DEVICE ) return;
    1120:	e3500000 	cmp	r0, #0	; 0x0
    1124:	08bd8030 	ldmeqia	sp!, {r4, r5, pc}
		
		if ( id[0] == DS18B20_ID || id[0] == DS18S20_ID ) return;
    1128:	e5d43000 	ldrb	r3, [r4]
    112c:	e3530010 	cmp	r3, #16	; 0x10
    1130:	13530028 	cmpne	r3, #40	; 0x28
    1134:	1afffff1 	bne	1100 <DS18X20_find_sensor+0xc>
    1138:	e8bd8030 	ldmia	sp!, {r4, r5, pc}

0000113c <DS18X20_get_power_status>:
	}
}

/* get power status of DS18x20 
   input  : id = rom_code 
   returns: DS18X20_POWER_EXTERN or DS18X20_POWER_PARASITE */
uint8_t	DS18X20_get_power_status(uint8_t id[])
{
    113c:	e92d4010 	stmdb	sp!, {r4, lr}
    1140:	e1a04000 	mov	r4, r0
	uint8_t pstat;
    ow_reset();
    1144:	ebfffece 	bl	c84 <ow_reset>
    ow_command(DS18X20_READ_POWER_SUPPLY, id);
    1148:	e1a01004 	mov	r1, r4
    114c:	e3a000b4 	mov	r0, #180	; 0xb4
    1150:	ebffff56 	bl	eb0 <ow_command>
    pstat=ow_bit_io(1); // pstat 0=is parasite/ !=0 ext. powered
    1154:	e3a00001 	mov	r0, #1	; 0x1
    1158:	ebfffeeb 	bl	d0c <ow_bit_io>
    115c:	e1a04000 	mov	r4, r0
    ow_reset();
    1160:	ebfffec7 	bl	c84 <ow_reset>
	return (pstat) ? DS18X20_POWER_EXTERN:DS18X20_POWER_PARASITE;
}
    1164:	e2540000 	subs	r0, r4, #0	; 0x0
    1168:	13a00001 	movne	r0, #1	; 0x1
    116c:	e8bd8010 	ldmia	sp!, {r4, pc}

00001170 <DS18X20_start_meas>:

/* start measurement (CONVERT_T) for all sensors if input id==NULL 
   or for single sensor. then id is the rom-code */
uint8_t DS18X20_start_meas( uint8_t with_power_extern, uint8_t id[])
{
    1170:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    1174:	e1a04001 	mov	r4, r1
    1178:	e20050ff 	and	r5, r0, #255	; 0xff
	if( ow_input_pin_state() ) { // only send if bus is "idle" = high
    117c:	ebfffe9f 	bl	c00 <ow_input_pin_state>
    1180:	e3500000 	cmp	r0, #0	; 0x0
		ow_command( DS18X20_CONVERT_T, id );
    1184:	e1a01004 	mov	r1, r4
    1188:	e3a00044 	mov	r0, #68	; 0x44
    118c:	e3a03002 	mov	r3, #2	; 0x2
    1190:	0a000005 	beq	11ac <DS18X20_start_meas+0x3c>
    1194:	ebffff45 	bl	eb0 <ow_command>
		if (with_power_extern != DS18X20_POWER_EXTERN)
    1198:	e3550001 	cmp	r5, #1	; 0x1
    119c:	e3a03000 	mov	r3, #0	; 0x0
    11a0:	0a000001 	beq	11ac <DS18X20_start_meas+0x3c>
			ow_parasite_enable();
    11a4:	ebfffe9a 	bl	c14 <ow_parasite_enable>
    11a8:	e3a03000 	mov	r3, #0	; 0x0
		return DS18X20_OK;
	} 
	else { 
		#ifdef DS18X20_VERBOSE
		uart_puts_P( "DS18X20_start_meas: Short Circuit !\r" );
		#endif
		return DS18X20_START_FAIL;
	}
}
    11ac:	e1a00003 	mov	r0, r3
    11b0:	e8bd8030 	ldmia	sp!, {r4, r5, pc}

000011b4 <DS18X20_read_meas>:

/* reads temperature (scratchpad) of sensor with rom-code id
   output: subzero==1 if temp.<0, cel: full celsius, mcel: frac 
   in millicelsius*0.1
   i.e.: subzero=1, cel=18, millicel=5000 = -18,5000°C */
uint8_t DS18X20_read_meas(uint8_t id[], uint8_t *subzero, 
	uint8_t *cel, uint8_t *cel_frac_bits)
{
    11b4:	e92d45f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, lr}
    11b8:	e1a06000 	mov	r6, r0
    11bc:	e24dd010 	sub	sp, sp, #16	; 0x10
    11c0:	e1a0a001 	mov	sl, r1
	uint8_t i;
	uint8_t sp[DS18X20_SP_SIZE];
	
	ow_command(DS18X20_READ, id);
    11c4:	e3a000be 	mov	r0, #190	; 0xbe
    11c8:	e1a01006 	mov	r1, r6
    11cc:	e1a07002 	mov	r7, r2
    11d0:	e1a08003 	mov	r8, r3
    11d4:	ebffff35 	bl	eb0 <ow_command>
    11d8:	e3a04000 	mov	r4, #0	; 0x0
	for ( i=0 ; i< DS18X20_SP_SIZE; i++ ) sp[i]=ow_byte_rd();
    11dc:	ebfffef9 	bl	dc8 <ow_byte_rd>
    11e0:	e28d5007 	add	r5, sp, #7	; 0x7
    11e4:	e7c40005 	strb	r0, [r4, r5]
    11e8:	e2844001 	add	r4, r4, #1	; 0x1
    11ec:	e3540009 	cmp	r4, #9	; 0x9
    11f0:	1afffff9 	bne	11dc <DS18X20_read_meas+0x28>
	if ( crc8( &sp[0], DS18X20_SP_SIZE ) ) 
    11f4:	e1a01004 	mov	r1, r4
    11f8:	e1a00005 	mov	r0, r5
    11fc:	ebffff3f 	bl	f00 <crc8>
    1200:	e2504000 	subs	r4, r0, #0	; 0x0
    1204:	13a00003 	movne	r0, #3	; 0x3
    1208:	1a000006 	bne	1228 <DS18X20_read_meas+0x74>
		return DS18X20_ERROR_CRC;
	DS18X20_meas_to_cel(id[0], sp, subzero, cel, cel_frac_bits);
    120c:	e5d60000 	ldrb	r0, [r6]
    1210:	e1a01005 	mov	r1, r5
    1214:	e1a0200a 	mov	r2, sl
    1218:	e1a03007 	mov	r3, r7
    121c:	e58d8000 	str	r8, [sp]
    1220:	ebffff52 	bl	f70 <DS18X20_meas_to_cel>
    1224:	e1a00004 	mov	r0, r4
	return DS18X20_OK;
}
    1228:	e28dd010 	add	sp, sp, #16	; 0x10
    122c:	e8bd85f0 	ldmia	sp!, {r4, r5, r6, r7, r8, sl, pc}

00001230 <delay_us_>:
#include "config.h"

void delay_us_(uint32_t delayval)
{
	asm volatile (
    1230:	e2500001 	subs	r0, r0, #1	; 0x1
    1234:	1afffffd 	bne	1230 <delay_us_>
		"L_LOOPUS_%=: 		\n\t" \
		"subs	%0, %0, #1 	\n\t" \
		"bne	L_LOOPUS_%=	\n\t" \
		:  /* no outputs */ : "r" (delayval)
	);
	
#if 0
	asm volatile (
		"ldr	r1,=%0 		\n\t" \
		".L_LOOPUS_%=: 		\n\t" \
		"subs	r1, r1, #1 	\n\t" \
		"bne	L_LOOPUS_%=	\n\t" \
		: "=w" (delayval)
		: "0" (delayval)
	);
#endif
}
    1238:	e12fff1e 	bx	lr

0000123c <delay_ms>:

void delay_ms(uint32_t delayval)
{
    123c:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
    1240:	e1a04000 	mov	r4, r0
	uint32_t d = (delayval * 1e-3 * sysTICSperSEC) + .5;
	pause(d);
    1244:	eb00022b 	bl	1af8 <__aeabi_i2d>
    1248:	e3540000 	cmp	r4, #0	; 0x0
    124c:	e1a06001 	mov	r6, r1
    1250:	e1a05000 	mov	r5, r0
    1254:	e3a0261f 	mov	r2, #32505856	; 0x1f00000
    1258:	e3822101 	orr	r2, r2, #1073741824	; 0x40000000
    125c:	e3a03000 	mov	r3, #0	; 0x0
    1260:	aa000002 	bge	1270 <delay_ms+0x34>
    1264:	eb000161 	bl	17f0 <__adddf3>
    1268:	e1a06001 	mov	r6, r1
    126c:	e1a05000 	mov	r5, r0
    1270:	e1a01006 	mov	r1, r6
    1274:	e1a00005 	mov	r0, r5
    1278:	e28f202c 	add	r2, pc, #44	; 0x2c
    127c:	e892000c 	ldmia	r2, {r2, r3}
    1280:	eb000257 	bl	1be4 <__aeabi_dmul>
    1284:	e28f2028 	add	r2, pc, #40	; 0x28
    1288:	e892000c 	ldmia	r2, {r2, r3}
    128c:	eb000254 	bl	1be4 <__aeabi_dmul>
    1290:	e3a026fe 	mov	r2, #266338304	; 0xfe00000
    1294:	e3822203 	orr	r2, r2, #805306368	; 0x30000000
    1298:	e3a03000 	mov	r3, #0	; 0x0
    129c:	eb000153 	bl	17f0 <__adddf3>
    12a0:	eb00036b 	bl	2054 <__aeabi_d2uiz>
}
    12a4:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
    12a8:	eafffced 	b	664 <pause>
    12ac:	3f50624d 	swicc	0x0050624d
    12b0:	d2f1a9fc 	rscles	sl, r1, #4128768	; 0x3f0000
    12b4:	416312d0 	ldrmid	r1, [r3, #-32]!
    12b8:	00000000 	andeq	r0, r0, r0

000012bc <itoa>:

#define __MAX_INT_CHARS 7

char* itoa(int16_t i)
{
    12bc:	e1a00800 	mov	r0, r0, lsl #16
    12c0:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
	static char a[__MAX_INT_CHARS];
	
	char *b = a + sizeof(a) - 1;
	uint8_t   sign = (i < 0);

	if (sign) i = -i;
    12c4:	e1b06fa0 	movs	r6, r0, lsr #31
    12c8:	e1a00820 	mov	r0, r0, lsr #16
    12cc:	12603000 	rsbne	r3, r0, #0	; 0x0
    12d0:	11a03803 	movne	r3, r3, lsl #16
    12d4:	11a00823 	movne	r0, r3, lsr #16
	*b = 0;
    12d8:	e59f3050 	ldr	r3, [pc, #80]	; 1330 <.text+0x1330>
    12dc:	e3a02000 	mov	r2, #0	; 0x0
    12e0:	e5e32006 	strb	r2, [r3, #6]!
    12e4:	e1a05003 	mov	r5, r3
	do {
		*--b = '0' + (i % 10);
    12e8:	e1a04800 	mov	r4, r0, lsl #16
    12ec:	e1a04844 	mov	r4, r4, asr #16
    12f0:	e3a0100a 	mov	r1, #10	; 0xa
    12f4:	e1a00004 	mov	r0, r4
    12f8:	eb0000ff 	bl	16fc <__modsi3>
    12fc:	e2803030 	add	r3, r0, #48	; 0x30
		i /= 10;
    1300:	e3a0100a 	mov	r1, #10	; 0xa
    1304:	e1a00004 	mov	r0, r4
    1308:	e5653001 	strb	r3, [r5, #-1]!
    130c:	eb000077 	bl	14f0 <__divsi3>
    1310:	e1a00800 	mov	r0, r0, lsl #16
	} while (i);
    1314:	e1b00820 	movs	r0, r0, lsr #16
    1318:	1afffff2 	bne	12e8 <itoa+0x2c>
	if (sign) *--b = '-';
    131c:	e3560000 	cmp	r6, #0	; 0x0
    1320:	e1a00005 	mov	r0, r5
    1324:	13a0302d 	movne	r3, #45	; 0x2d
    1328:	15603001 	strneb	r3, [r0, #-1]!
	return b;
}
    132c:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
    1330:	40000008 	andmi	r0, r0, r8

00001334 <memcpy>:
    1334:	e352000f 	cmp	r2, #15	; 0xf
    1338:	e92d4010 	stmdb	sp!, {r4, lr}
    133c:	e1a0c000 	mov	ip, r0
    1340:	e1a04000 	mov	r4, r0
    1344:	e1a0e002 	mov	lr, r2
    1348:	e1a00002 	mov	r0, r2
    134c:	9a000002 	bls	135c <memcpy+0x28>
    1350:	e1813004 	orr	r3, r1, r4
    1354:	e3130003 	tst	r3, #3	; 0x3
    1358:	0a000009 	beq	1384 <memcpy+0x50>
    135c:	e3500000 	cmp	r0, #0	; 0x0
    1360:	0a000005 	beq	137c <memcpy+0x48>
    1364:	e3a02000 	mov	r2, #0	; 0x0
    1368:	e4d13001 	ldrb	r3, [r1], #1
    136c:	e7c2300c 	strb	r3, [r2, ip]
    1370:	e2822001 	add	r2, r2, #1	; 0x1
    1374:	e1500002 	cmp	r0, r2
    1378:	1afffffa 	bne	1368 <memcpy+0x34>
    137c:	e1a00004 	mov	r0, r4
    1380:	e8bd8010 	ldmia	sp!, {r4, pc}
    1384:	e5913000 	ldr	r3, [r1]
    1388:	e58c3000 	str	r3, [ip]
    138c:	e5912004 	ldr	r2, [r1, #4]
    1390:	e58c2004 	str	r2, [ip, #4]
    1394:	e5913008 	ldr	r3, [r1, #8]
    1398:	e58c3008 	str	r3, [ip, #8]
    139c:	e24ee010 	sub	lr, lr, #16	; 0x10
    13a0:	e591300c 	ldr	r3, [r1, #12]
    13a4:	e35e000f 	cmp	lr, #15	; 0xf
    13a8:	e58c300c 	str	r3, [ip, #12]
    13ac:	e2811010 	add	r1, r1, #16	; 0x10
    13b0:	e28cc010 	add	ip, ip, #16	; 0x10
    13b4:	8afffff2 	bhi	1384 <memcpy+0x50>
    13b8:	e35e0003 	cmp	lr, #3	; 0x3
    13bc:	e1a0000e 	mov	r0, lr
    13c0:	9affffe5 	bls	135c <memcpy+0x28>
    13c4:	e24ee004 	sub	lr, lr, #4	; 0x4
    13c8:	e4913004 	ldr	r3, [r1], #4
    13cc:	e35e0003 	cmp	lr, #3	; 0x3
    13d0:	e48c3004 	str	r3, [ip], #4
    13d4:	8afffffa 	bhi	13c4 <memcpy+0x90>
    13d8:	e1a0000e 	mov	r0, lr
    13dc:	eaffffde 	b	135c <memcpy+0x28>

000013e0 <__udivsi3>:
    13e0:	e2512001 	subs	r2, r1, #1	; 0x1
    13e4:	012fff1e 	bxeq	lr
    13e8:	3a000036 	bcc	14c8 <__udivsi3+0xe8>
    13ec:	e1500001 	cmp	r0, r1
    13f0:	9a000022 	bls	1480 <__udivsi3+0xa0>
    13f4:	e1110002 	tst	r1, r2
    13f8:	0a000023 	beq	148c <__udivsi3+0xac>
    13fc:	e311020e 	tst	r1, #-536870912	; 0xe0000000
    1400:	01a01181 	moveq	r1, r1, lsl #3
    1404:	03a03008 	moveq	r3, #8	; 0x8
    1408:	13a03001 	movne	r3, #1	; 0x1
    140c:	e3510201 	cmp	r1, #268435456	; 0x10000000
    1410:	31510000 	cmpcc	r1, r0
    1414:	31a01201 	movcc	r1, r1, lsl #4
    1418:	31a03203 	movcc	r3, r3, lsl #4
    141c:	3afffffa 	bcc	140c <__udivsi3+0x2c>
    1420:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
    1424:	31510000 	cmpcc	r1, r0
    1428:	31a01081 	movcc	r1, r1, lsl #1
    142c:	31a03083 	movcc	r3, r3, lsl #1
    1430:	3afffffa 	bcc	1420 <__udivsi3+0x40>
    1434:	e3a02000 	mov	r2, #0	; 0x0
    1438:	e1500001 	cmp	r0, r1
    143c:	20400001 	subcs	r0, r0, r1
    1440:	21822003 	orrcs	r2, r2, r3
    1444:	e15000a1 	cmp	r0, r1, lsr #1
    1448:	204000a1 	subcs	r0, r0, r1, lsr #1
    144c:	218220a3 	orrcs	r2, r2, r3, lsr #1
    1450:	e1500121 	cmp	r0, r1, lsr #2
    1454:	20400121 	subcs	r0, r0, r1, lsr #2
    1458:	21822123 	orrcs	r2, r2, r3, lsr #2
    145c:	e15001a1 	cmp	r0, r1, lsr #3
    1460:	204001a1 	subcs	r0, r0, r1, lsr #3
    1464:	218221a3 	orrcs	r2, r2, r3, lsr #3
    1468:	e3500000 	cmp	r0, #0	; 0x0
    146c:	11b03223 	movnes	r3, r3, lsr #4
    1470:	11a01221 	movne	r1, r1, lsr #4
    1474:	1affffef 	bne	1438 <__udivsi3+0x58>
    1478:	e1a00002 	mov	r0, r2
    147c:	e12fff1e 	bx	lr
    1480:	03a00001 	moveq	r0, #1	; 0x1
    1484:	13a00000 	movne	r0, #0	; 0x0
    1488:	e12fff1e 	bx	lr
    148c:	e3510801 	cmp	r1, #65536	; 0x10000
    1490:	21a01821 	movcs	r1, r1, lsr #16
    1494:	23a02010 	movcs	r2, #16	; 0x10
    1498:	33a02000 	movcc	r2, #0	; 0x0
    149c:	e3510c01 	cmp	r1, #256	; 0x100
    14a0:	21a01421 	movcs	r1, r1, lsr #8
    14a4:	22822008 	addcs	r2, r2, #8	; 0x8
    14a8:	e3510010 	cmp	r1, #16	; 0x10
    14ac:	21a01221 	movcs	r1, r1, lsr #4
    14b0:	22822004 	addcs	r2, r2, #4	; 0x4
    14b4:	e3510004 	cmp	r1, #4	; 0x4
    14b8:	82822003 	addhi	r2, r2, #3	; 0x3
    14bc:	908220a1 	addls	r2, r2, r1, lsr #1
    14c0:	e1a00230 	mov	r0, r0, lsr r2
    14c4:	e12fff1e 	bx	lr
    14c8:	e52de004 	str	lr, [sp, #-4]!
    14cc:	eb0000c3 	bl	17e0 <__aeabi_idiv0>
    14d0:	e3a00000 	mov	r0, #0	; 0x0
    14d4:	e49df004 	ldr	pc, [sp], #4

000014d8 <__aeabi_uidivmod>:
    14d8:	e92d4003 	stmdb	sp!, {r0, r1, lr}
    14dc:	ebffffbf 	bl	13e0 <__udivsi3>
    14e0:	e8bd4006 	ldmia	sp!, {r1, r2, lr}
    14e4:	e0030092 	mul	r3, r2, r0
    14e8:	e0411003 	sub	r1, r1, r3
    14ec:	e12fff1e 	bx	lr

000014f0 <__divsi3>:
    14f0:	e3510000 	cmp	r1, #0	; 0x0
    14f4:	e020c001 	eor	ip, r0, r1
    14f8:	0a000042 	beq	1608 <__divsi3+0x118>
    14fc:	42611000 	rsbmi	r1, r1, #0	; 0x0
    1500:	e2512001 	subs	r2, r1, #1	; 0x1
    1504:	0a000027 	beq	15a8 <__divsi3+0xb8>
    1508:	e1b03000 	movs	r3, r0
    150c:	42603000 	rsbmi	r3, r0, #0	; 0x0
    1510:	e1530001 	cmp	r3, r1
    1514:	9a000026 	bls	15b4 <__divsi3+0xc4>
    1518:	e1110002 	tst	r1, r2
    151c:	0a000028 	beq	15c4 <__divsi3+0xd4>
    1520:	e311020e 	tst	r1, #-536870912	; 0xe0000000
    1524:	01a01181 	moveq	r1, r1, lsl #3
    1528:	03a02008 	moveq	r2, #8	; 0x8
    152c:	13a02001 	movne	r2, #1	; 0x1
    1530:	e3510201 	cmp	r1, #268435456	; 0x10000000
    1534:	31510003 	cmpcc	r1, r3
    1538:	31a01201 	movcc	r1, r1, lsl #4
    153c:	31a02202 	movcc	r2, r2, lsl #4
    1540:	3afffffa 	bcc	1530 <__divsi3+0x40>
    1544:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
    1548:	31510003 	cmpcc	r1, r3
    154c:	31a01081 	movcc	r1, r1, lsl #1
    1550:	31a02082 	movcc	r2, r2, lsl #1
    1554:	3afffffa 	bcc	1544 <__divsi3+0x54>
    1558:	e3a00000 	mov	r0, #0	; 0x0
    155c:	e1530001 	cmp	r3, r1
    1560:	20433001 	subcs	r3, r3, r1
    1564:	21800002 	orrcs	r0, r0, r2
    1568:	e15300a1 	cmp	r3, r1, lsr #1
    156c:	204330a1 	subcs	r3, r3, r1, lsr #1
    1570:	218000a2 	orrcs	r0, r0, r2, lsr #1
    1574:	e1530121 	cmp	r3, r1, lsr #2
    1578:	20433121 	subcs	r3, r3, r1, lsr #2
    157c:	21800122 	orrcs	r0, r0, r2, lsr #2
    1580:	e15301a1 	cmp	r3, r1, lsr #3
    1584:	204331a1 	subcs	r3, r3, r1, lsr #3
    1588:	218001a2 	orrcs	r0, r0, r2, lsr #3
    158c:	e3530000 	cmp	r3, #0	; 0x0
    1590:	11b02222 	movnes	r2, r2, lsr #4
    1594:	11a01221 	movne	r1, r1, lsr #4
    1598:	1affffef 	bne	155c <__divsi3+0x6c>
    159c:	e35c0000 	cmp	ip, #0	; 0x0
    15a0:	42600000 	rsbmi	r0, r0, #0	; 0x0
    15a4:	e12fff1e 	bx	lr
    15a8:	e13c0000 	teq	ip, r0
    15ac:	42600000 	rsbmi	r0, r0, #0	; 0x0
    15b0:	e12fff1e 	bx	lr
    15b4:	33a00000 	movcc	r0, #0	; 0x0
    15b8:	01a00fcc 	moveq	r0, ip, asr #31
    15bc:	03800001 	orreq	r0, r0, #1	; 0x1
    15c0:	e12fff1e 	bx	lr
    15c4:	e3510801 	cmp	r1, #65536	; 0x10000
    15c8:	21a01821 	movcs	r1, r1, lsr #16
    15cc:	23a02010 	movcs	r2, #16	; 0x10
    15d0:	33a02000 	movcc	r2, #0	; 0x0
    15d4:	e3510c01 	cmp	r1, #256	; 0x100
    15d8:	21a01421 	movcs	r1, r1, lsr #8
    15dc:	22822008 	addcs	r2, r2, #8	; 0x8
    15e0:	e3510010 	cmp	r1, #16	; 0x10
    15e4:	21a01221 	movcs	r1, r1, lsr #4
    15e8:	22822004 	addcs	r2, r2, #4	; 0x4
    15ec:	e3510004 	cmp	r1, #4	; 0x4
    15f0:	82822003 	addhi	r2, r2, #3	; 0x3
    15f4:	908220a1 	addls	r2, r2, r1, lsr #1
    15f8:	e35c0000 	cmp	ip, #0	; 0x0
    15fc:	e1a00233 	mov	r0, r3, lsr r2
    1600:	42600000 	rsbmi	r0, r0, #0	; 0x0
    1604:	e12fff1e 	bx	lr
    1608:	e52de004 	str	lr, [sp, #-4]!
    160c:	eb000073 	bl	17e0 <__aeabi_idiv0>
    1610:	e3a00000 	mov	r0, #0	; 0x0
    1614:	e49df004 	ldr	pc, [sp], #4

00001618 <__aeabi_idivmod>:
    1618:	e92d4003 	stmdb	sp!, {r0, r1, lr}
    161c:	ebffffb3 	bl	14f0 <__divsi3>
    1620:	e8bd4006 	ldmia	sp!, {r1, r2, lr}
    1624:	e0030092 	mul	r3, r2, r0
    1628:	e0411003 	sub	r1, r1, r3
    162c:	e12fff1e 	bx	lr

00001630 <__umodsi3>:
    1630:	e2512001 	subs	r2, r1, #1	; 0x1
    1634:	3a00002c 	bcc	16ec <__umodsi3+0xbc>
    1638:	11500001 	cmpne	r0, r1
    163c:	03a00000 	moveq	r0, #0	; 0x0
    1640:	81110002 	tsthi	r1, r2
    1644:	00000002 	andeq	r0, r0, r2
    1648:	912fff1e 	bxls	lr
    164c:	e3a02000 	mov	r2, #0	; 0x0
    1650:	e3510201 	cmp	r1, #268435456	; 0x10000000
    1654:	31510000 	cmpcc	r1, r0
    1658:	31a01201 	movcc	r1, r1, lsl #4
    165c:	32822004 	addcc	r2, r2, #4	; 0x4
    1660:	3afffffa 	bcc	1650 <__umodsi3+0x20>
    1664:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
    1668:	31510000 	cmpcc	r1, r0
    166c:	31a01081 	movcc	r1, r1, lsl #1
    1670:	32822001 	addcc	r2, r2, #1	; 0x1
    1674:	3afffffa 	bcc	1664 <__umodsi3+0x34>
    1678:	e2522003 	subs	r2, r2, #3	; 0x3
    167c:	ba00000e 	blt	16bc <__umodsi3+0x8c>
    1680:	e1500001 	cmp	r0, r1
    1684:	20400001 	subcs	r0, r0, r1
    1688:	e15000a1 	cmp	r0, r1, lsr #1
    168c:	204000a1 	subcs	r0, r0, r1, lsr #1
    1690:	e1500121 	cmp	r0, r1, lsr #2
    1694:	20400121 	subcs	r0, r0, r1, lsr #2
    1698:	e15001a1 	cmp	r0, r1, lsr #3
    169c:	204001a1 	subcs	r0, r0, r1, lsr #3
    16a0:	e3500001 	cmp	r0, #1	; 0x1
    16a4:	e1a01221 	mov	r1, r1, lsr #4
    16a8:	a2522004 	subges	r2, r2, #4	; 0x4
    16ac:	aafffff3 	bge	1680 <__umodsi3+0x50>
    16b0:	e3120003 	tst	r2, #3	; 0x3
    16b4:	13300000 	teqne	r0, #0	; 0x0
    16b8:	0a00000a 	beq	16e8 <__umodsi3+0xb8>
    16bc:	e3720002 	cmn	r2, #2	; 0x2
    16c0:	ba000006 	blt	16e0 <__umodsi3+0xb0>
    16c4:	0a000002 	beq	16d4 <__umodsi3+0xa4>
    16c8:	e1500001 	cmp	r0, r1
    16cc:	20400001 	subcs	r0, r0, r1
    16d0:	e1a010a1 	mov	r1, r1, lsr #1
    16d4:	e1500001 	cmp	r0, r1
    16d8:	20400001 	subcs	r0, r0, r1
    16dc:	e1a010a1 	mov	r1, r1, lsr #1
    16e0:	e1500001 	cmp	r0, r1
    16e4:	20400001 	subcs	r0, r0, r1
    16e8:	e12fff1e 	bx	lr
    16ec:	e52de004 	str	lr, [sp, #-4]!
    16f0:	eb00003a 	bl	17e0 <__aeabi_idiv0>
    16f4:	e3a00000 	mov	r0, #0	; 0x0
    16f8:	e49df004 	ldr	pc, [sp], #4

000016fc <__modsi3>:
    16fc:	e3510000 	cmp	r1, #0	; 0x0
    1700:	0a000032 	beq	17d0 <__modsi3+0xd4>
    1704:	42611000 	rsbmi	r1, r1, #0	; 0x0
    1708:	e1b0c000 	movs	ip, r0
    170c:	42600000 	rsbmi	r0, r0, #0	; 0x0
    1710:	e2512001 	subs	r2, r1, #1	; 0x1
    1714:	11500001 	cmpne	r0, r1
    1718:	03a00000 	moveq	r0, #0	; 0x0
    171c:	81110002 	tsthi	r1, r2
    1720:	00000002 	andeq	r0, r0, r2
    1724:	9a000026 	bls	17c4 <__modsi3+0xc8>
    1728:	e3a02000 	mov	r2, #0	; 0x0
    172c:	e3510201 	cmp	r1, #268435456	; 0x10000000
    1730:	31510000 	cmpcc	r1, r0
    1734:	31a01201 	movcc	r1, r1, lsl #4
    1738:	32822004 	addcc	r2, r2, #4	; 0x4
    173c:	3afffffa 	bcc	172c <__modsi3+0x30>
    1740:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
    1744:	31510000 	cmpcc	r1, r0
    1748:	31a01081 	movcc	r1, r1, lsl #1
    174c:	32822001 	addcc	r2, r2, #1	; 0x1
    1750:	3afffffa 	bcc	1740 <__modsi3+0x44>
    1754:	e2522003 	subs	r2, r2, #3	; 0x3
    1758:	ba00000e 	blt	1798 <__modsi3+0x9c>
    175c:	e1500001 	cmp	r0, r1
    1760:	20400001 	subcs	r0, r0, r1
    1764:	e15000a1 	cmp	r0, r1, lsr #1
    1768:	204000a1 	subcs	r0, r0, r1, lsr #1
    176c:	e1500121 	cmp	r0, r1, lsr #2
    1770:	20400121 	subcs	r0, r0, r1, lsr #2
    1774:	e15001a1 	cmp	r0, r1, lsr #3
    1778:	204001a1 	subcs	r0, r0, r1, lsr #3
    177c:	e3500001 	cmp	r0, #1	; 0x1
    1780:	e1a01221 	mov	r1, r1, lsr #4
    1784:	a2522004 	subges	r2, r2, #4	; 0x4
    1788:	aafffff3 	bge	175c <__modsi3+0x60>
    178c:	e3120003 	tst	r2, #3	; 0x3
    1790:	13300000 	teqne	r0, #0	; 0x0
    1794:	0a00000a 	beq	17c4 <__modsi3+0xc8>
    1798:	e3720002 	cmn	r2, #2	; 0x2
    179c:	ba000006 	blt	17bc <__modsi3+0xc0>
    17a0:	0a000002 	beq	17b0 <__modsi3+0xb4>
    17a4:	e1500001 	cmp	r0, r1
    17a8:	20400001 	subcs	r0, r0, r1
    17ac:	e1a010a1 	mov	r1, r1, lsr #1
    17b0:	e1500001 	cmp	r0, r1
    17b4:	20400001 	subcs	r0, r0, r1
    17b8:	e1a010a1 	mov	r1, r1, lsr #1
    17bc:	e1500001 	cmp	r0, r1
    17c0:	20400001 	subcs	r0, r0, r1
    17c4:	e35c0000 	cmp	ip, #0	; 0x0
    17c8:	42600000 	rsbmi	r0, r0, #0	; 0x0
    17cc:	e12fff1e 	bx	lr
    17d0:	e52de004 	str	lr, [sp, #-4]!
    17d4:	eb000001 	bl	17e0 <__aeabi_idiv0>
    17d8:	e3a00000 	mov	r0, #0	; 0x0
    17dc:	e49df004 	ldr	pc, [sp], #4

000017e0 <__aeabi_idiv0>:
    17e0:	e12fff1e 	bx	lr

000017e4 <__aeabi_drsub>:
    17e4:	e2200102 	eor	r0, r0, #-2147483648	; 0x80000000
    17e8:	ea000000 	b	17f0 <__adddf3>

000017ec <__aeabi_dsub>:
    17ec:	e2222102 	eor	r2, r2, #-2147483648	; 0x80000000

000017f0 <__adddf3>:
    17f0:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    17f4:	e1a04080 	mov	r4, r0, lsl #1
    17f8:	e1a05082 	mov	r5, r2, lsl #1
    17fc:	e1340005 	teq	r4, r5
    1800:	01310003 	teqeq	r1, r3
    1804:	1194c001 	orrnes	ip, r4, r1
    1808:	1195c003 	orrnes	ip, r5, r3
    180c:	11f0cac4 	mvnnes	ip, r4, asr #21
    1810:	11f0cac5 	mvnnes	ip, r5, asr #21
    1814:	0a000086 	beq	1a34 <__adddf3+0x244>
    1818:	e1a04aa4 	mov	r4, r4, lsr #21
    181c:	e0745aa5 	rsbs	r5, r4, r5, lsr #21
    1820:	b2655000 	rsblt	r5, r5, #0	; 0x0
    1824:	da000006 	ble	1844 <__adddf3+0x54>
    1828:	e0844005 	add	r4, r4, r5
    182c:	e0213003 	eor	r3, r1, r3
    1830:	e0202002 	eor	r2, r0, r2
    1834:	e0231001 	eor	r1, r3, r1
    1838:	e0220000 	eor	r0, r2, r0
    183c:	e0213003 	eor	r3, r1, r3
    1840:	e0202002 	eor	r2, r0, r2
    1844:	e3550036 	cmp	r5, #54	; 0x36
    1848:	88bd8030 	ldmhiia	sp!, {r4, r5, pc}
    184c:	e3100102 	tst	r0, #-2147483648	; 0x80000000
    1850:	e1a00600 	mov	r0, r0, lsl #12
    1854:	e3a0c601 	mov	ip, #1048576	; 0x100000
    1858:	e18c0620 	orr	r0, ip, r0, lsr #12
    185c:	0a000001 	beq	1868 <__adddf3+0x78>
    1860:	e2711000 	rsbs	r1, r1, #0	; 0x0
    1864:	e2e00000 	rsc	r0, r0, #0	; 0x0
    1868:	e3120102 	tst	r2, #-2147483648	; 0x80000000
    186c:	e1a02602 	mov	r2, r2, lsl #12
    1870:	e18c2622 	orr	r2, ip, r2, lsr #12
    1874:	0a000001 	beq	1880 <__adddf3+0x90>
    1878:	e2733000 	rsbs	r3, r3, #0	; 0x0
    187c:	e2e22000 	rsc	r2, r2, #0	; 0x0
    1880:	e1340005 	teq	r4, r5
    1884:	0a000064 	beq	1a1c <__adddf3+0x22c>
    1888:	e2444001 	sub	r4, r4, #1	; 0x1
    188c:	e275e020 	rsbs	lr, r5, #32	; 0x20
    1890:	ba000005 	blt	18ac <__adddf3+0xbc>
    1894:	e1a0ce13 	mov	ip, r3, lsl lr
    1898:	e0911533 	adds	r1, r1, r3, lsr r5
    189c:	e2a00000 	adc	r0, r0, #0	; 0x0
    18a0:	e0911e12 	adds	r1, r1, r2, lsl lr
    18a4:	e0b00552 	adcs	r0, r0, r2, asr r5
    18a8:	ea000006 	b	18c8 <__adddf3+0xd8>
    18ac:	e2455020 	sub	r5, r5, #32	; 0x20
    18b0:	e28ee020 	add	lr, lr, #32	; 0x20
    18b4:	e3530001 	cmp	r3, #1	; 0x1
    18b8:	e1a0ce12 	mov	ip, r2, lsl lr
    18bc:	238cc002 	orrcs	ip, ip, #2	; 0x2
    18c0:	e0911552 	adds	r1, r1, r2, asr r5
    18c4:	e0b00fc2 	adcs	r0, r0, r2, asr #31
    18c8:	e2005102 	and	r5, r0, #-2147483648	; 0x80000000
    18cc:	5a000002 	bpl	18dc <__adddf3+0xec>
    18d0:	e27cc000 	rsbs	ip, ip, #0	; 0x0
    18d4:	e2f11000 	rscs	r1, r1, #0	; 0x0
    18d8:	e2e00000 	rsc	r0, r0, #0	; 0x0
    18dc:	e3500601 	cmp	r0, #1048576	; 0x100000
    18e0:	3a00000e 	bcc	1920 <__adddf3+0x130>
    18e4:	e3500602 	cmp	r0, #2097152	; 0x200000
    18e8:	3a000006 	bcc	1908 <__adddf3+0x118>
    18ec:	e1b000a0 	movs	r0, r0, lsr #1
    18f0:	e1b01061 	movs	r1, r1, rrx
    18f4:	e1a0c06c 	mov	ip, ip, rrx
    18f8:	e2844001 	add	r4, r4, #1	; 0x1
    18fc:	e1a02a84 	mov	r2, r4, lsl #21
    1900:	e3720501 	cmn	r2, #4194304	; 0x400000
    1904:	2a000062 	bcs	1a94 <__adddf3+0x2a4>
    1908:	e35c0102 	cmp	ip, #-2147483648	; 0x80000000
    190c:	01b0c0a1 	moveqs	ip, r1, lsr #1
    1910:	e2b11000 	adcs	r1, r1, #0	; 0x0
    1914:	e0a00a04 	adc	r0, r0, r4, lsl #20
    1918:	e1800005 	orr	r0, r0, r5
    191c:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
    1920:	e1b0c08c 	movs	ip, ip, lsl #1
    1924:	e0b11001 	adcs	r1, r1, r1
    1928:	e0a00000 	adc	r0, r0, r0
    192c:	e3100601 	tst	r0, #1048576	; 0x100000
    1930:	e2444001 	sub	r4, r4, #1	; 0x1
    1934:	1afffff3 	bne	1908 <__adddf3+0x118>
    1938:	e3300000 	teq	r0, #0	; 0x0
    193c:	13a03014 	movne	r3, #20	; 0x14
    1940:	03a03034 	moveq	r3, #52	; 0x34
    1944:	01a00001 	moveq	r0, r1
    1948:	03a01000 	moveq	r1, #0	; 0x0
    194c:	e1a02000 	mov	r2, r0
    1950:	e3520801 	cmp	r2, #65536	; 0x10000
    1954:	21a02822 	movcs	r2, r2, lsr #16
    1958:	22433010 	subcs	r3, r3, #16	; 0x10
    195c:	e3520c01 	cmp	r2, #256	; 0x100
    1960:	21a02422 	movcs	r2, r2, lsr #8
    1964:	22433008 	subcs	r3, r3, #8	; 0x8
    1968:	e3520010 	cmp	r2, #16	; 0x10
    196c:	21a02222 	movcs	r2, r2, lsr #4
    1970:	22433004 	subcs	r3, r3, #4	; 0x4
    1974:	e3520004 	cmp	r2, #4	; 0x4
    1978:	22433002 	subcs	r3, r3, #2	; 0x2
    197c:	304330a2 	subcc	r3, r3, r2, lsr #1
    1980:	e04331a2 	sub	r3, r3, r2, lsr #3
    1984:	e2532020 	subs	r2, r3, #32	; 0x20
    1988:	aa000007 	bge	19ac <__adddf3+0x1bc>
    198c:	e292200c 	adds	r2, r2, #12	; 0xc
    1990:	da000004 	ble	19a8 <__adddf3+0x1b8>
    1994:	e282c014 	add	ip, r2, #20	; 0x14
    1998:	e262200c 	rsb	r2, r2, #12	; 0xc
    199c:	e1a01c10 	mov	r1, r0, lsl ip
    19a0:	e1a00230 	mov	r0, r0, lsr r2
    19a4:	ea000004 	b	19bc <__adddf3+0x1cc>
    19a8:	e2822014 	add	r2, r2, #20	; 0x14
    19ac:	d262c020 	rsble	ip, r2, #32	; 0x20
    19b0:	e1a00210 	mov	r0, r0, lsl r2
    19b4:	d1800c31 	orrle	r0, r0, r1, lsr ip
    19b8:	d1a01211 	movle	r1, r1, lsl r2
    19bc:	e0544003 	subs	r4, r4, r3
    19c0:	a0800a04 	addge	r0, r0, r4, lsl #20
    19c4:	a1800005 	orrge	r0, r0, r5
    19c8:	a8bd8030 	ldmgeia	sp!, {r4, r5, pc}
    19cc:	e1e04004 	mvn	r4, r4
    19d0:	e254401f 	subs	r4, r4, #31	; 0x1f
    19d4:	aa00000d 	bge	1a10 <__adddf3+0x220>
    19d8:	e294400c 	adds	r4, r4, #12	; 0xc
    19dc:	ca000005 	bgt	19f8 <__adddf3+0x208>
    19e0:	e2844014 	add	r4, r4, #20	; 0x14
    19e4:	e2642020 	rsb	r2, r4, #32	; 0x20
    19e8:	e1a01431 	mov	r1, r1, lsr r4
    19ec:	e1811210 	orr	r1, r1, r0, lsl r2
    19f0:	e1850430 	orr	r0, r5, r0, lsr r4
    19f4:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
    19f8:	e264400c 	rsb	r4, r4, #12	; 0xc
    19fc:	e2642020 	rsb	r2, r4, #32	; 0x20
    1a00:	e1a01231 	mov	r1, r1, lsr r2
    1a04:	e1811410 	orr	r1, r1, r0, lsl r4
    1a08:	e1a00005 	mov	r0, r5
    1a0c:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
    1a10:	e1a01430 	mov	r1, r0, lsr r4
    1a14:	e1a00005 	mov	r0, r5
    1a18:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
    1a1c:	e3340000 	teq	r4, #0	; 0x0
    1a20:	e2222601 	eor	r2, r2, #1048576	; 0x100000
    1a24:	02200601 	eoreq	r0, r0, #1048576	; 0x100000
    1a28:	02844001 	addeq	r4, r4, #1	; 0x1
    1a2c:	12455001 	subne	r5, r5, #1	; 0x1
    1a30:	eaffff94 	b	1888 <__adddf3+0x98>
    1a34:	e1f0cac4 	mvns	ip, r4, asr #21
    1a38:	11f0cac5 	mvnnes	ip, r5, asr #21
    1a3c:	0a000018 	beq	1aa4 <__adddf3+0x2b4>
    1a40:	e1340005 	teq	r4, r5
    1a44:	01310003 	teqeq	r1, r3
    1a48:	0a000003 	beq	1a5c <__adddf3+0x26c>
    1a4c:	e3340000 	teq	r4, #0	; 0x0
    1a50:	01a00002 	moveq	r0, r2
    1a54:	01a01003 	moveq	r1, r3
    1a58:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
    1a5c:	e1300002 	teq	r0, r2
    1a60:	13a00000 	movne	r0, #0	; 0x0
    1a64:	13a01000 	movne	r1, #0	; 0x0
    1a68:	18bd8030 	ldmneia	sp!, {r4, r5, pc}
    1a6c:	e1b0caa4 	movs	ip, r4, lsr #21
    1a70:	1a000003 	bne	1a84 <__adddf3+0x294>
    1a74:	e1b01081 	movs	r1, r1, lsl #1
    1a78:	e0b00000 	adcs	r0, r0, r0
    1a7c:	23800102 	orrcs	r0, r0, #-2147483648	; 0x80000000
    1a80:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
    1a84:	e2944501 	adds	r4, r4, #4194304	; 0x400000
    1a88:	32800601 	addcc	r0, r0, #1048576	; 0x100000
    1a8c:	38bd8030 	ldmccia	sp!, {r4, r5, pc}
    1a90:	e2005102 	and	r5, r0, #-2147483648	; 0x80000000
    1a94:	e385047f 	orr	r0, r5, #2130706432	; 0x7f000000
    1a98:	e380060f 	orr	r0, r0, #15728640	; 0xf00000
    1a9c:	e3a01000 	mov	r1, #0	; 0x0
    1aa0:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
    1aa4:	e1f0cac4 	mvns	ip, r4, asr #21
    1aa8:	11a00002 	movne	r0, r2
    1aac:	11a01003 	movne	r1, r3
    1ab0:	01f0cac5 	mvneqs	ip, r5, asr #21
    1ab4:	11a02000 	movne	r2, r0
    1ab8:	11a03001 	movne	r3, r1
    1abc:	e1914600 	orrs	r4, r1, r0, lsl #12
    1ac0:	01935602 	orreqs	r5, r3, r2, lsl #12
    1ac4:	01300002 	teqeq	r0, r2
    1ac8:	13800702 	orrne	r0, r0, #524288	; 0x80000
    1acc:	e8bd8030 	ldmia	sp!, {r4, r5, pc}

00001ad0 <__aeabi_ui2d>:
    1ad0:	e3300000 	teq	r0, #0	; 0x0
    1ad4:	03a01000 	moveq	r1, #0	; 0x0
    1ad8:	012fff1e 	bxeq	lr
    1adc:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    1ae0:	e3a04b01 	mov	r4, #1024	; 0x400
    1ae4:	e2844032 	add	r4, r4, #50	; 0x32
    1ae8:	e3a05000 	mov	r5, #0	; 0x0
    1aec:	e1a01000 	mov	r1, r0
    1af0:	e3a00000 	mov	r0, #0	; 0x0
    1af4:	eaffff8f 	b	1938 <__adddf3+0x148>

00001af8 <__aeabi_i2d>:
    1af8:	e3300000 	teq	r0, #0	; 0x0
    1afc:	03a01000 	moveq	r1, #0	; 0x0
    1b00:	012fff1e 	bxeq	lr
    1b04:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    1b08:	e3a04b01 	mov	r4, #1024	; 0x400
    1b0c:	e2844032 	add	r4, r4, #50	; 0x32
    1b10:	e2105102 	ands	r5, r0, #-2147483648	; 0x80000000
    1b14:	42600000 	rsbmi	r0, r0, #0	; 0x0
    1b18:	e1a01000 	mov	r1, r0
    1b1c:	e3a00000 	mov	r0, #0	; 0x0
    1b20:	eaffff84 	b	1938 <__adddf3+0x148>

00001b24 <__aeabi_f2d>:
    1b24:	e1b02080 	movs	r2, r0, lsl #1
    1b28:	e1a001c2 	mov	r0, r2, asr #3
    1b2c:	e1a00060 	mov	r0, r0, rrx
    1b30:	e1a01e02 	mov	r1, r2, lsl #28
    1b34:	121234ff 	andnes	r3, r2, #-16777216	; 0xff000000
    1b38:	133304ff 	teqne	r3, #-16777216	; 0xff000000
    1b3c:	1220030e 	eorne	r0, r0, #939524096	; 0x38000000
    1b40:	112fff1e 	bxne	lr
    1b44:	e3320000 	teq	r2, #0	; 0x0
    1b48:	133304ff 	teqne	r3, #-16777216	; 0xff000000
    1b4c:	012fff1e 	bxeq	lr
    1b50:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    1b54:	e3a04d0e 	mov	r4, #896	; 0x380
    1b58:	e2005102 	and	r5, r0, #-2147483648	; 0x80000000
    1b5c:	e3c00102 	bic	r0, r0, #-2147483648	; 0x80000000
    1b60:	eaffff74 	b	1938 <__adddf3+0x148>

00001b64 <__aeabi_ul2d>:
    1b64:	e1902001 	orrs	r2, r0, r1
    1b68:	012fff1e 	bxeq	lr
    1b6c:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    1b70:	e3a05000 	mov	r5, #0	; 0x0
    1b74:	ea000006 	b	1b94 <__aeabi_l2d+0x1c>

00001b78 <__aeabi_l2d>:
    1b78:	e1902001 	orrs	r2, r0, r1
    1b7c:	012fff1e 	bxeq	lr
    1b80:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    1b84:	e2115102 	ands	r5, r1, #-2147483648	; 0x80000000
    1b88:	5a000001 	bpl	1b94 <__aeabi_l2d+0x1c>
    1b8c:	e2700000 	rsbs	r0, r0, #0	; 0x0
    1b90:	e2e11000 	rsc	r1, r1, #0	; 0x0
    1b94:	e3a04b01 	mov	r4, #1024	; 0x400
    1b98:	e2844032 	add	r4, r4, #50	; 0x32
    1b9c:	e1a0c000 	mov	ip, r0
    1ba0:	e1a00001 	mov	r0, r1
    1ba4:	e1a0100c 	mov	r1, ip
    1ba8:	e1b0cb20 	movs	ip, r0, lsr #22
    1bac:	0affff4a 	beq	18dc <__adddf3+0xec>
    1bb0:	e3a02003 	mov	r2, #3	; 0x3
    1bb4:	e1b0c1ac 	movs	ip, ip, lsr #3
    1bb8:	12822003 	addne	r2, r2, #3	; 0x3
    1bbc:	e1b0c1ac 	movs	ip, ip, lsr #3
    1bc0:	12822003 	addne	r2, r2, #3	; 0x3
    1bc4:	e08221ac 	add	r2, r2, ip, lsr #3
    1bc8:	e2623020 	rsb	r3, r2, #32	; 0x20
    1bcc:	e1a0c311 	mov	ip, r1, lsl r3
    1bd0:	e1a01231 	mov	r1, r1, lsr r2
    1bd4:	e1811310 	orr	r1, r1, r0, lsl r3
    1bd8:	e1a00230 	mov	r0, r0, lsr r2
    1bdc:	e0844002 	add	r4, r4, r2
    1be0:	eaffff3d 	b	18dc <__adddf3+0xec>

00001be4 <__aeabi_dmul>:
    1be4:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
    1be8:	e3a0c0ff 	mov	ip, #255	; 0xff
    1bec:	e38ccc07 	orr	ip, ip, #1792	; 0x700
    1bf0:	e01c4a20 	ands	r4, ip, r0, lsr #20
    1bf4:	101c5a22 	andnes	r5, ip, r2, lsr #20
    1bf8:	1134000c 	teqne	r4, ip
    1bfc:	1135000c 	teqne	r5, ip
    1c00:	0b00006f 	bleq	1dc4 <__aeabi_dmul+0x1e0>
    1c04:	e0844005 	add	r4, r4, r5
    1c08:	e0206002 	eor	r6, r0, r2
    1c0c:	e1c00a8c 	bic	r0, r0, ip, lsl #21
    1c10:	e1c22a8c 	bic	r2, r2, ip, lsl #21
    1c14:	e1915600 	orrs	r5, r1, r0, lsl #12
    1c18:	11935602 	orrnes	r5, r3, r2, lsl #12
    1c1c:	e3800601 	orr	r0, r0, #1048576	; 0x100000
    1c20:	e3822601 	orr	r2, r2, #1048576	; 0x100000
    1c24:	0a00001c 	beq	1c9c <__aeabi_dmul+0xb8>
    1c28:	e08ec391 	umull	ip, lr, r1, r3
    1c2c:	e3a05000 	mov	r5, #0	; 0x0
    1c30:	e0a5e390 	umlal	lr, r5, r0, r3
    1c34:	e2063102 	and	r3, r6, #-2147483648	; 0x80000000
    1c38:	e0a5e291 	umlal	lr, r5, r1, r2
    1c3c:	e3a06000 	mov	r6, #0	; 0x0
    1c40:	e0a65290 	umlal	r5, r6, r0, r2
    1c44:	e33c0000 	teq	ip, #0	; 0x0
    1c48:	138ee001 	orrne	lr, lr, #1	; 0x1
    1c4c:	e24440ff 	sub	r4, r4, #255	; 0xff
    1c50:	e3560c02 	cmp	r6, #512	; 0x200
    1c54:	e2c44c03 	sbc	r4, r4, #768	; 0x300
    1c58:	2a000002 	bcs	1c68 <__aeabi_dmul+0x84>
    1c5c:	e1b0e08e 	movs	lr, lr, lsl #1
    1c60:	e0b55005 	adcs	r5, r5, r5
    1c64:	e0a66006 	adc	r6, r6, r6
    1c68:	e1830586 	orr	r0, r3, r6, lsl #11
    1c6c:	e1800aa5 	orr	r0, r0, r5, lsr #21
    1c70:	e1a01585 	mov	r1, r5, lsl #11
    1c74:	e1811aae 	orr	r1, r1, lr, lsr #21
    1c78:	e1a0e58e 	mov	lr, lr, lsl #11
    1c7c:	e254c0fd 	subs	ip, r4, #253	; 0xfd
    1c80:	835c0c07 	cmphi	ip, #1792	; 0x700
    1c84:	8a00000f 	bhi	1cc8 <__aeabi_dmul+0xe4>
    1c88:	e35e0102 	cmp	lr, #-2147483648	; 0x80000000
    1c8c:	01b0e0a1 	moveqs	lr, r1, lsr #1
    1c90:	e2b11000 	adcs	r1, r1, #0	; 0x0
    1c94:	e0a00a04 	adc	r0, r0, r4, lsl #20
    1c98:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
    1c9c:	e2066102 	and	r6, r6, #-2147483648	; 0x80000000
    1ca0:	e1860000 	orr	r0, r6, r0
    1ca4:	e1811003 	orr	r1, r1, r3
    1ca8:	e0200002 	eor	r0, r0, r2
    1cac:	e05440ac 	subs	r4, r4, ip, lsr #1
    1cb0:	c074500c 	rsbgts	r5, r4, ip
    1cb4:	c1800a04 	orrgt	r0, r0, r4, lsl #20
    1cb8:	c8bd8070 	ldmgtia	sp!, {r4, r5, r6, pc}
    1cbc:	e3800601 	orr	r0, r0, #1048576	; 0x100000
    1cc0:	e3a0e000 	mov	lr, #0	; 0x0
    1cc4:	e2544001 	subs	r4, r4, #1	; 0x1
    1cc8:	ca000058 	bgt	1e30 <__aeabi_dmul+0x24c>
    1ccc:	e3740036 	cmn	r4, #54	; 0x36
    1cd0:	d3a01000 	movle	r1, #0	; 0x0
    1cd4:	d2000102 	andle	r0, r0, #-2147483648	; 0x80000000
    1cd8:	d8bd8070 	ldmleia	sp!, {r4, r5, r6, pc}
    1cdc:	e2644000 	rsb	r4, r4, #0	; 0x0
    1ce0:	e2544020 	subs	r4, r4, #32	; 0x20
    1ce4:	aa000018 	bge	1d4c <__aeabi_dmul+0x168>
    1ce8:	e294400c 	adds	r4, r4, #12	; 0xc
    1cec:	ca00000b 	bgt	1d20 <__aeabi_dmul+0x13c>
    1cf0:	e2844014 	add	r4, r4, #20	; 0x14
    1cf4:	e2645020 	rsb	r5, r4, #32	; 0x20
    1cf8:	e1a03511 	mov	r3, r1, lsl r5
    1cfc:	e1a01431 	mov	r1, r1, lsr r4
    1d00:	e1811510 	orr	r1, r1, r0, lsl r5
    1d04:	e2002102 	and	r2, r0, #-2147483648	; 0x80000000
    1d08:	e3c00102 	bic	r0, r0, #-2147483648	; 0x80000000
    1d0c:	e0911fa3 	adds	r1, r1, r3, lsr #31
    1d10:	e0a20430 	adc	r0, r2, r0, lsr r4
    1d14:	e19ee083 	orrs	lr, lr, r3, lsl #1
    1d18:	01c11fa3 	biceq	r1, r1, r3, lsr #31
    1d1c:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
    1d20:	e264400c 	rsb	r4, r4, #12	; 0xc
    1d24:	e2645020 	rsb	r5, r4, #32	; 0x20
    1d28:	e1a03411 	mov	r3, r1, lsl r4
    1d2c:	e1a01531 	mov	r1, r1, lsr r5
    1d30:	e1811410 	orr	r1, r1, r0, lsl r4
    1d34:	e2000102 	and	r0, r0, #-2147483648	; 0x80000000
    1d38:	e0911fa3 	adds	r1, r1, r3, lsr #31
    1d3c:	e2a00000 	adc	r0, r0, #0	; 0x0
    1d40:	e19ee083 	orrs	lr, lr, r3, lsl #1
    1d44:	01c11fa3 	biceq	r1, r1, r3, lsr #31
    1d48:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
    1d4c:	e2645020 	rsb	r5, r4, #32	; 0x20
    1d50:	e18ee511 	orr	lr, lr, r1, lsl r5
    1d54:	e1a03431 	mov	r3, r1, lsr r4
    1d58:	e1833510 	orr	r3, r3, r0, lsl r5
    1d5c:	e1a01430 	mov	r1, r0, lsr r4
    1d60:	e2000102 	and	r0, r0, #-2147483648	; 0x80000000
    1d64:	e1c11430 	bic	r1, r1, r0, lsr r4
    1d68:	e0811fa3 	add	r1, r1, r3, lsr #31
    1d6c:	e19ee083 	orrs	lr, lr, r3, lsl #1
    1d70:	01c11fa3 	biceq	r1, r1, r3, lsr #31
    1d74:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
    1d78:	e3340000 	teq	r4, #0	; 0x0
    1d7c:	1a000008 	bne	1da4 <__aeabi_dmul+0x1c0>
    1d80:	e2006102 	and	r6, r0, #-2147483648	; 0x80000000
    1d84:	e1b01081 	movs	r1, r1, lsl #1
    1d88:	e0a00000 	adc	r0, r0, r0
    1d8c:	e3100601 	tst	r0, #1048576	; 0x100000
    1d90:	02444001 	subeq	r4, r4, #1	; 0x1
    1d94:	0afffffa 	beq	1d84 <__aeabi_dmul+0x1a0>
    1d98:	e1800006 	orr	r0, r0, r6
    1d9c:	e3350000 	teq	r5, #0	; 0x0
    1da0:	11a0f00e 	movne	pc, lr
    1da4:	e2026102 	and	r6, r2, #-2147483648	; 0x80000000
    1da8:	e1b03083 	movs	r3, r3, lsl #1
    1dac:	e0a22002 	adc	r2, r2, r2
    1db0:	e3120601 	tst	r2, #1048576	; 0x100000
    1db4:	02455001 	subeq	r5, r5, #1	; 0x1
    1db8:	0afffffa 	beq	1da8 <__aeabi_dmul+0x1c4>
    1dbc:	e1822006 	orr	r2, r2, r6
    1dc0:	e1a0f00e 	mov	pc, lr
    1dc4:	e134000c 	teq	r4, ip
    1dc8:	e00c5a22 	and	r5, ip, r2, lsr #20
    1dcc:	1135000c 	teqne	r5, ip
    1dd0:	0a000006 	beq	1df0 <__aeabi_dmul+0x20c>
    1dd4:	e1916080 	orrs	r6, r1, r0, lsl #1
    1dd8:	11936082 	orrnes	r6, r3, r2, lsl #1
    1ddc:	1affffe5 	bne	1d78 <__aeabi_dmul+0x194>
    1de0:	e0200002 	eor	r0, r0, r2
    1de4:	e2000102 	and	r0, r0, #-2147483648	; 0x80000000
    1de8:	e3a01000 	mov	r1, #0	; 0x0
    1dec:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
    1df0:	e1916080 	orrs	r6, r1, r0, lsl #1
    1df4:	01a01003 	moveq	r1, r3
    1df8:	01a00002 	moveq	r0, r2
    1dfc:	11936082 	orrnes	r6, r3, r2, lsl #1
    1e00:	0a00000f 	beq	1e44 <__aeabi_dmul+0x260>
    1e04:	e134000c 	teq	r4, ip
    1e08:	1a000001 	bne	1e14 <__aeabi_dmul+0x230>
    1e0c:	e1916600 	orrs	r6, r1, r0, lsl #12
    1e10:	1a00000b 	bne	1e44 <__aeabi_dmul+0x260>
    1e14:	e135000c 	teq	r5, ip
    1e18:	1a000003 	bne	1e2c <__aeabi_dmul+0x248>
    1e1c:	e1936602 	orrs	r6, r3, r2, lsl #12
    1e20:	11a01003 	movne	r1, r3
    1e24:	11a00002 	movne	r0, r2
    1e28:	1a000005 	bne	1e44 <__aeabi_dmul+0x260>
    1e2c:	e0200002 	eor	r0, r0, r2
    1e30:	e2000102 	and	r0, r0, #-2147483648	; 0x80000000
    1e34:	e380047f 	orr	r0, r0, #2130706432	; 0x7f000000
    1e38:	e380060f 	orr	r0, r0, #15728640	; 0xf00000
    1e3c:	e3a01000 	mov	r1, #0	; 0x0
    1e40:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
    1e44:	e380047f 	orr	r0, r0, #2130706432	; 0x7f000000
    1e48:	e380073e 	orr	r0, r0, #16252928	; 0xf80000
    1e4c:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}

00001e50 <__aeabi_ddiv>:
    1e50:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
    1e54:	e3a0c0ff 	mov	ip, #255	; 0xff
    1e58:	e38ccc07 	orr	ip, ip, #1792	; 0x700
    1e5c:	e01c4a20 	ands	r4, ip, r0, lsr #20
    1e60:	101c5a22 	andnes	r5, ip, r2, lsr #20
    1e64:	1134000c 	teqne	r4, ip
    1e68:	1135000c 	teqne	r5, ip
    1e6c:	0b00005c 	bleq	1fe4 <__aeabi_ddiv+0x194>
    1e70:	e0444005 	sub	r4, r4, r5
    1e74:	e020e002 	eor	lr, r0, r2
    1e78:	e1935602 	orrs	r5, r3, r2, lsl #12
    1e7c:	e1a00600 	mov	r0, r0, lsl #12
    1e80:	0a00004b 	beq	1fb4 <__aeabi_ddiv+0x164>
    1e84:	e1a02602 	mov	r2, r2, lsl #12
    1e88:	e3a05201 	mov	r5, #268435456	; 0x10000000
    1e8c:	e1852222 	orr	r2, r5, r2, lsr #4
    1e90:	e1822c23 	orr	r2, r2, r3, lsr #24
    1e94:	e1a03403 	mov	r3, r3, lsl #8
    1e98:	e1855220 	orr	r5, r5, r0, lsr #4
    1e9c:	e1855c21 	orr	r5, r5, r1, lsr #24
    1ea0:	e1a06401 	mov	r6, r1, lsl #8
    1ea4:	e20e0102 	and	r0, lr, #-2147483648	; 0x80000000
    1ea8:	e1550002 	cmp	r5, r2
    1eac:	01560003 	cmpeq	r6, r3
    1eb0:	e2a440fd 	adc	r4, r4, #253	; 0xfd
    1eb4:	e2844c03 	add	r4, r4, #768	; 0x300
    1eb8:	2a000001 	bcs	1ec4 <__aeabi_ddiv+0x74>
    1ebc:	e1b020a2 	movs	r2, r2, lsr #1
    1ec0:	e1a03063 	mov	r3, r3, rrx
    1ec4:	e0566003 	subs	r6, r6, r3
    1ec8:	e0c55002 	sbc	r5, r5, r2
    1ecc:	e1b020a2 	movs	r2, r2, lsr #1
    1ed0:	e1a03063 	mov	r3, r3, rrx
    1ed4:	e3a01601 	mov	r1, #1048576	; 0x100000
    1ed8:	e3a0c702 	mov	ip, #524288	; 0x80000
    1edc:	e056e003 	subs	lr, r6, r3
    1ee0:	e0d5e002 	sbcs	lr, r5, r2
    1ee4:	20466003 	subcs	r6, r6, r3
    1ee8:	21a0500e 	movcs	r5, lr
    1eec:	2181100c 	orrcs	r1, r1, ip
    1ef0:	e1b020a2 	movs	r2, r2, lsr #1
    1ef4:	e1a03063 	mov	r3, r3, rrx
    1ef8:	e056e003 	subs	lr, r6, r3
    1efc:	e0d5e002 	sbcs	lr, r5, r2
    1f00:	20466003 	subcs	r6, r6, r3
    1f04:	21a0500e 	movcs	r5, lr
    1f08:	218110ac 	orrcs	r1, r1, ip, lsr #1
    1f0c:	e1b020a2 	movs	r2, r2, lsr #1
    1f10:	e1a03063 	mov	r3, r3, rrx
    1f14:	e056e003 	subs	lr, r6, r3
    1f18:	e0d5e002 	sbcs	lr, r5, r2
    1f1c:	20466003 	subcs	r6, r6, r3
    1f20:	21a0500e 	movcs	r5, lr
    1f24:	2181112c 	orrcs	r1, r1, ip, lsr #2
    1f28:	e1b020a2 	movs	r2, r2, lsr #1
    1f2c:	e1a03063 	mov	r3, r3, rrx
    1f30:	e056e003 	subs	lr, r6, r3
    1f34:	e0d5e002 	sbcs	lr, r5, r2
    1f38:	20466003 	subcs	r6, r6, r3
    1f3c:	21a0500e 	movcs	r5, lr
    1f40:	218111ac 	orrcs	r1, r1, ip, lsr #3
    1f44:	e195e006 	orrs	lr, r5, r6
    1f48:	0a00000d 	beq	1f84 <__aeabi_ddiv+0x134>
    1f4c:	e1a05205 	mov	r5, r5, lsl #4
    1f50:	e1855e26 	orr	r5, r5, r6, lsr #28
    1f54:	e1a06206 	mov	r6, r6, lsl #4
    1f58:	e1a02182 	mov	r2, r2, lsl #3
    1f5c:	e1822ea3 	orr	r2, r2, r3, lsr #29
    1f60:	e1a03183 	mov	r3, r3, lsl #3
    1f64:	e1b0c22c 	movs	ip, ip, lsr #4
    1f68:	1affffdb 	bne	1edc <__aeabi_ddiv+0x8c>
    1f6c:	e3100601 	tst	r0, #1048576	; 0x100000
    1f70:	1a000006 	bne	1f90 <__aeabi_ddiv+0x140>
    1f74:	e1800001 	orr	r0, r0, r1
    1f78:	e3a01000 	mov	r1, #0	; 0x0
    1f7c:	e3a0c102 	mov	ip, #-2147483648	; 0x80000000
    1f80:	eaffffd5 	b	1edc <__aeabi_ddiv+0x8c>
    1f84:	e3100601 	tst	r0, #1048576	; 0x100000
    1f88:	01800001 	orreq	r0, r0, r1
    1f8c:	03a01000 	moveq	r1, #0	; 0x0
    1f90:	e254c0fd 	subs	ip, r4, #253	; 0xfd
    1f94:	835c0c07 	cmphi	ip, #1792	; 0x700
    1f98:	8affff4a 	bhi	1cc8 <__aeabi_dmul+0xe4>
    1f9c:	e055c002 	subs	ip, r5, r2
    1fa0:	0056c003 	subeqs	ip, r6, r3
    1fa4:	01b0c0a1 	moveqs	ip, r1, lsr #1
    1fa8:	e2b11000 	adcs	r1, r1, #0	; 0x0
    1fac:	e0a00a04 	adc	r0, r0, r4, lsl #20
    1fb0:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
    1fb4:	e20ee102 	and	lr, lr, #-2147483648	; 0x80000000
    1fb8:	e18e0620 	orr	r0, lr, r0, lsr #12
    1fbc:	e09440ac 	adds	r4, r4, ip, lsr #1
    1fc0:	c074500c 	rsbgts	r5, r4, ip
    1fc4:	c1800a04 	orrgt	r0, r0, r4, lsl #20
    1fc8:	c8bd8070 	ldmgtia	sp!, {r4, r5, r6, pc}
    1fcc:	e3800601 	orr	r0, r0, #1048576	; 0x100000
    1fd0:	e3a0e000 	mov	lr, #0	; 0x0
    1fd4:	e2544001 	subs	r4, r4, #1	; 0x1
    1fd8:	eaffff3a 	b	1cc8 <__aeabi_dmul+0xe4>
    1fdc:	e185e006 	orr	lr, r5, r6
    1fe0:	eaffff38 	b	1cc8 <__aeabi_dmul+0xe4>
    1fe4:	e00c5a22 	and	r5, ip, r2, lsr #20
    1fe8:	e134000c 	teq	r4, ip
    1fec:	0135000c 	teqeq	r5, ip
    1ff0:	0affff93 	beq	1e44 <__aeabi_dmul+0x260>
    1ff4:	e134000c 	teq	r4, ip
    1ff8:	1a000006 	bne	2018 <__aeabi_ddiv+0x1c8>
    1ffc:	e1914600 	orrs	r4, r1, r0, lsl #12
    2000:	1affff8f 	bne	1e44 <__aeabi_dmul+0x260>
    2004:	e135000c 	teq	r5, ip
    2008:	1affff87 	bne	1e2c <__aeabi_dmul+0x248>
    200c:	e1a01003 	mov	r1, r3
    2010:	e1a00002 	mov	r0, r2
    2014:	eaffff8a 	b	1e44 <__aeabi_dmul+0x260>
    2018:	e135000c 	teq	r5, ip
    201c:	1a000004 	bne	2034 <__aeabi_ddiv+0x1e4>
    2020:	e1935602 	orrs	r5, r3, r2, lsl #12
    2024:	0affff6d 	beq	1de0 <__aeabi_dmul+0x1fc>
    2028:	e1a01003 	mov	r1, r3
    202c:	e1a00002 	mov	r0, r2
    2030:	eaffff83 	b	1e44 <__aeabi_dmul+0x260>
    2034:	e1916080 	orrs	r6, r1, r0, lsl #1
    2038:	11936082 	orrnes	r6, r3, r2, lsl #1
    203c:	1affff4d 	bne	1d78 <__aeabi_dmul+0x194>
    2040:	e1914080 	orrs	r4, r1, r0, lsl #1
    2044:	1affff78 	bne	1e2c <__aeabi_dmul+0x248>
    2048:	e1935082 	orrs	r5, r3, r2, lsl #1
    204c:	1affff63 	bne	1de0 <__aeabi_dmul+0x1fc>
    2050:	eaffff7b 	b	1e44 <__aeabi_dmul+0x260>

00002054 <__aeabi_d2uiz>:
    2054:	e1b02080 	movs	r2, r0, lsl #1
    2058:	2a00000a 	bcs	2088 <__aeabi_d2uiz+0x34>
    205c:	e2922602 	adds	r2, r2, #2097152	; 0x200000
    2060:	2a00000a 	bcs	2090 <__aeabi_d2uiz+0x3c>
    2064:	5a000007 	bpl	2088 <__aeabi_d2uiz+0x34>
    2068:	e3e03e3e 	mvn	r3, #992	; 0x3e0
    206c:	e0532ac2 	subs	r2, r3, r2, asr #21
    2070:	4a000008 	bmi	2098 <__aeabi_d2uiz+0x44>
    2074:	e1a03580 	mov	r3, r0, lsl #11
    2078:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
    207c:	e1833aa1 	orr	r3, r3, r1, lsr #21
    2080:	e1a00233 	mov	r0, r3, lsr r2
    2084:	e12fff1e 	bx	lr
    2088:	e3a00000 	mov	r0, #0	; 0x0
    208c:	e12fff1e 	bx	lr
    2090:	e1911600 	orrs	r1, r1, r0, lsl #12
    2094:	1a000001 	bne	20a0 <__aeabi_d2uiz+0x4c>
    2098:	e3e00000 	mvn	r0, #0	; 0x0
    209c:	e12fff1e 	bx	lr
    20a0:	e3a00000 	mov	r0, #0	; 0x0
    20a4:	e12fff1e 	bx	lr

000020a8 <C.1.1194>:
    20a8:	06040301 0e0c0b09 504c0a0d 30313243     ..........LPC210
    20b8:	202d2036 38315344 20303278 706d6554     6 - DS18x20 Temp
    20c8:	65532d2e 726f736e 746e6920 61667265     .-Sensor interfa
    20d8:	0a0d6563 00000000 69572061 4d52416e     ce......a WinARM
    20e8:	6d654420 70412d6f 63696c70 6f697461      Demo-Applicatio
    20f8:	7962206e 72614d20 206e6974 6d6f6854     n by Martin Thom
    2108:	0a0d7361 00000a0d 63530a0d 696e6e61     as........Scanni
    2118:	4220676e 66207375 4420726f 58383153     ng Bus for DS18X
    2128:	0a0d3032 00000000 53206f4e 6f736e65     20......No Senso
    2138:	6f662072 0d646e75 0000000a 20737542     r found.....Bus 
    2148:	6f727245 000a0d72 0d373432 0000000a     Error...247.....
    2158:	0a0d3633 00000000 31534420 30325838     36...... DS18X20
    2168:	6e655320 73726f73 61766120 62616c69      Sensors availab
    2178:	0d3a656c 0000000a 736e6553 2023726f     le:.....Sensor# 
    2188:	00000000 20736920 00002061 38315344     .... is a ..DS18
    2198:	2f303253 38315344 00003032 38315344     S20/DS1820..DS18
    21a8:	00303242 69687720 69206863 00002073     B20. which is ..
    21b8:	61726170 65746973 00000000 65747865     parasite....exte
    21c8:	6c616e72 0000796c 776f7020 64657265     rnally.. powered
    21d8:	0000000d 20656874 0000003c 656b203e     ....the <...> ke
    21e8:	61682079 65622073 70206e65 73736572     y has been press
    21f8:	0a0d6465 00000000 72617453 6f632074     ed......Start co
    2208:	7265766e 6e6f6973 6c6c6120 6e657320     nversion all sen
    2218:	73726f73 00000020 00204b4f 6c696166     sors ...OK .fail
    2228:	28206465 726f6873 69632074 69756372     ed (short circui
    2238:	00293f74 00203d20 5b2043b0 00000000     t?). = ..C [....
    2248:	0000002e 005d43b0 20435243 6f727245     .....C].CRC Erro
    2258:	6c282072 2074736f 6e6e6f63 69746365     r (lost connecti
    2268:	293f6e6f 00000000                       on?)....
